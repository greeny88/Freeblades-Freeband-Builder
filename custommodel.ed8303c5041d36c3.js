(self.webpackChunkfreeblades_freeband_builder=self.webpackChunkfreeblades_freeband_builder||[]).push([[829],{2953:(Ze,Ge,J)=>{"use strict";J.r(Ge),J.d(Ge,{CustomModelModule:()=>qq});var De={};J.r(De),J.d(De,{assertParamsValid:()=>wh,computeFlatOffset:()=>Sh,computeOutShape:()=>vh,getNormalizedAxes:()=>qS,isSliceContinous:()=>Ch,maskToAxes:()=>jS,parseSliceParams:()=>cu,sliceInfo:()=>Ih,startForAxis:()=>Lg,startIndicesWithElidedDims:()=>Fg,stopForAxis:()=>Mg,stopIndicesWithElidedDims:()=>Og,stridesForAxis:()=>Pg,stridesWithElidedDims:()=>Ag});var Pt={};J.r(Pt),J.d(Pt,{collectGatherOpShapeInfo:()=>Sp,computeOutShape:()=>By,segOpComputeOptimalWindowSize:()=>zy});var Ae={};J.r(Ae),J.d(Ae,{ERF_A1:()=>up,ERF_A2:()=>cp,ERF_A3:()=>dp,ERF_A4:()=>hp,ERF_A5:()=>pp,ERF_P:()=>lp,PARALLELIZE_THRESHOLD:()=>sp,RowPartitionType:()=>Yn,SELU_SCALE:()=>_u,SELU_SCALEALPHA:()=>ku,applyActivation:()=>Cu,assertAndGetBroadcastShape:()=>Oe,assertAxesAreInnerMostDims:()=>sn,assertParamsConsistent:()=>np,assignToTypedArray:()=>Iy,axesAreInnerMostDims:()=>Rh,calculateShapes:()=>jr,checkEinsumDimSizes:()=>xp,checkPadOnDimRoundingMode:()=>yn,combineLocations:()=>Kg,combineRaggedTensorToTensorShapes:()=>gy,complexWithEvenIndex:()=>Cy,complexWithOddIndex:()=>Sy,computeConv2DInfo:()=>Kt,computeConv3DInfo:()=>ir,computeDefaultPad:()=>Nh,computeDilation2DInfo:()=>ai,computeOptimalWindowSize:()=>Nu,computeOutAndReduceShapes:()=>Xt,computeOutShape:()=>Cs,computePool2DInfo:()=>Kn,computePool3DInfo:()=>Ps,convertConv2DDataFormat:()=>Ls,decodeEinsumEquation:()=>gp,eitherStridesOrDilationsAreOne:()=>nn,expandShapeToKeepDim:()=>Et,exponent:()=>Ny,exponents:()=>Ty,fromStringArrayToUint8:()=>Wy,fromUint8ToStringArray:()=>Hs,getAxesPermutation:()=>St,getBroadcastDims:()=>Ia,getComplexWithIndex:()=>fp,getEinsumComputePath:()=>bp,getEinsumPermutation:()=>yp,getFusedBiasGradient:()=>vu,getFusedDyActivation:()=>wu,getImageCenter:()=>rp,getInnerMostAxes:()=>At,getPermuted:()=>yi,getRaggedRank:()=>xy,getReductionAxes:()=>zt,getReshaped:()=>gi,getReshapedPermuted:()=>xi,getRowPartitionTypesHelper:()=>yy,getSliceBeginCoords:()=>ap,getSliceSize:()=>op,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>$y,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Ey,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Ay,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Fy,getSparseReshapeInputOutputMismatchErrorMessage:()=>Py,getSparseReshapeInputOutputMultipleErrorMessage:()=>Oy,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Dy,getSparseReshapeNegativeOutputDimErrorMessage:()=>Ry,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Vy,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Cp,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Ly,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>My,getUndoAxesPermutation:()=>ur,isIdentityPermutation:()=>wp,log:()=>hC,mergeRealAndImagArrays:()=>Gs,prepareAndValidate:()=>ip,prepareSplitSize:()=>vp,segment_util:()=>Pt,shouldFuse:()=>Su,slice_util:()=>De,splitRealAndImagArrays:()=>vy,stridesOrDilationsArePositive:()=>zr,tupleValuesAreOne:()=>lr,upcastType:()=>An,validateDefaultValueShape:()=>by,validateInput:()=>Kk,validateUpdateShape:()=>wy,warn:()=>On});var yt={};J.r(yt),J.d(yt,{addImpl:()=>lw,bincountImpl:()=>Rf,bincountReduceImpl:()=>fw,bitwiseAndImpl:()=>mw,castImpl:()=>iw,ceilImpl:()=>gw,concatImpl:()=>yw,equalImpl:()=>ww,expImpl:()=>Cw,expm1Impl:()=>Iw,floorDivImpl:()=>_w,floorImpl:()=>kw,gatherNdImpl:()=>$w,gatherV2Impl:()=>Ew,greaterEqualImpl:()=>Dw,greaterImpl:()=>Aw,lessEqualImpl:()=>Fw,lessImpl:()=>Rw,linSpaceImpl:()=>Ow,logImpl:()=>Pw,maxImpl:()=>Lw,maximumImpl:()=>Vw,minimumImpl:()=>zw,multiplyImpl:()=>Ff,negImpl:()=>Ww,notEqualImpl:()=>Uw,prodImpl:()=>qw,raggedGatherImpl:()=>Xw,raggedRangeImpl:()=>Yw,raggedTensorToTensorImpl:()=>e1,rangeImpl:()=>t1,rsqrtImpl:()=>n1,scatterImpl:()=>na,sigmoidImpl:()=>vR,simpleAbsImpl:()=>cw,sliceImpl:()=>pw,sparseFillEmptyRowsImpl:()=>r1,sparseReshapeImpl:()=>a1,sparseSegmentReductionImpl:()=>zf,sqrtImpl:()=>qM,squaredDifferenceImpl:()=>o1,staticRegexReplaceImpl:()=>i1,stridedSliceImpl:()=>l1,stringNGramsImpl:()=>u1,stringSplitImpl:()=>c1,stringToHashBucketFastImpl:()=>d1,subImpl:()=>Tw,tileImpl:()=>h1,topKImpl:()=>f1,transposeImpl:()=>Af,uniqueImpl:()=>g1});var _e=J(3075),Ne=J(9808),Le=J(7322),ge=J(7531),M=J(4107),ae=J(7423),he=J(8099),Q=J(7446),v=J(5e3),be=J(6360),we=J(508);const ct=["*",[["mat-card-footer"]]],Qt=["*","mat-card-footer"];let tt=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275dir=v.lG2({type:n,selectors:[["mat-card-content"],["","mat-card-content",""],["","matCardContent",""]],hostAttrs:[1,"mat-card-content"]}),n})(),Mt=(()=>{class n{constructor(e){this._animationMode=e}}return n.\u0275fac=function(e){return new(e||n)(v.Y36(be.Qb,8))},n.\u0275cmp=v.Xpm({type:n,selectors:[["mat-card"]],hostAttrs:[1,"mat-card","mat-focus-indicator"],hostVars:2,hostBindings:function(e,s){2&e&&v.ekj("_mat-animation-noopable","NoopAnimations"===s._animationMode)},exportAs:["matCard"],ngContentSelectors:Qt,decls:2,vars:0,template:function(e,s){1&e&&(v.F$t(ct),v.Hsn(0),v.Hsn(1,1))},styles:[".mat-card{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:block;position:relative;padding:16px;border-radius:4px}._mat-animation-noopable.mat-card{transition:none;animation:none}.mat-card .mat-divider-horizontal{position:absolute;left:0;width:100%}[dir=rtl] .mat-card .mat-divider-horizontal{left:auto;right:0}.mat-card .mat-divider-horizontal.mat-divider-inset{position:static;margin:0}[dir=rtl] .mat-card .mat-divider-horizontal.mat-divider-inset{margin-right:0}.cdk-high-contrast-active .mat-card{outline:solid 1px}.mat-card-actions,.mat-card-subtitle,.mat-card-content{display:block;margin-bottom:16px}.mat-card-title{display:block;margin-bottom:8px}.mat-card-actions{margin-left:-8px;margin-right:-8px;padding:8px 0}.mat-card-actions-align-end{display:flex;justify-content:flex-end}.mat-card-image{width:calc(100% + 32px);margin:0 -16px 16px -16px;display:block;overflow:hidden}.mat-card-image img{width:100%}.mat-card-footer{display:block;margin:0 -16px -16px -16px}.mat-card-actions .mat-button,.mat-card-actions .mat-raised-button,.mat-card-actions .mat-stroked-button{margin:0 8px}.mat-card-header{display:flex;flex-direction:row}.mat-card-header .mat-card-title{margin-bottom:12px}.mat-card-header-text{margin:0 16px}.mat-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;object-fit:cover}.mat-card-title-group{display:flex;justify-content:space-between}.mat-card-sm-image{width:80px;height:80px}.mat-card-md-image{width:112px;height:112px}.mat-card-lg-image{width:152px;height:152px}.mat-card-xl-image{width:240px;height:240px;margin:-8px}.mat-card-title-group>.mat-card-xl-image{margin:-8px 0 8px}@media(max-width: 599px){.mat-card-title-group{margin:0}.mat-card-xl-image{margin-left:0;margin-right:0}}.mat-card>:first-child,.mat-card-content>:first-child{margin-top:0}.mat-card>:last-child:not(.mat-card-footer),.mat-card-content>:last-child:not(.mat-card-footer){margin-bottom:0}.mat-card-image:first-child{margin-top:-16px;border-top-left-radius:inherit;border-top-right-radius:inherit}.mat-card>.mat-card-actions:last-child{margin-bottom:-8px;padding-bottom:0}.mat-card-actions:not(.mat-card-actions-align-end) .mat-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-raised-button:first-child,.mat-card-actions:not(.mat-card-actions-align-end) .mat-stroked-button:first-child{margin-left:0;margin-right:0}.mat-card-actions-align-end .mat-button:last-child,.mat-card-actions-align-end .mat-raised-button:last-child,.mat-card-actions-align-end .mat-stroked-button:last-child{margin-left:0;margin-right:0}.mat-card-title:not(:first-child),.mat-card-subtitle:not(:first-child){margin-top:-4px}.mat-card-header .mat-card-subtitle:not(:first-child){margin-top:-8px}.mat-card>.mat-card-xl-image:first-child{margin-top:-8px}.mat-card>.mat-card-xl-image:last-child{margin-bottom:-8px}\n"],encapsulation:2,changeDetection:0}),n})(),$n=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=v.oAB({type:n}),n.\u0275inj=v.cJS({imports:[[we.BQ],we.BQ]}),n})();var _t=J(3191),fn=J(925),ca=J(727),Mv=J(8962);function Vv(n,t){if(1&n&&(v.O4$(),v._UZ(0,"circle",4)),2&n){const e=v.oxw(),s=v.MAs(1);v.Udp("animation-name","mat-progress-spinner-stroke-rotate-"+e._spinnerAnimationLabel)("stroke-dashoffset",e._getStrokeDashOffset(),"px")("stroke-dasharray",e._getStrokeCircumference(),"px")("stroke-width",e._getCircleStrokeWidth(),"%")("transform-origin",e._getCircleTransformOrigin(s)),v.uIk("r",e._getCircleRadius())}}function zv(n,t){if(1&n&&(v.O4$(),v._UZ(0,"circle",4)),2&n){const e=v.oxw(),s=v.MAs(1);v.Udp("stroke-dashoffset",e._getStrokeDashOffset(),"px")("stroke-dasharray",e._getStrokeCircumference(),"px")("stroke-width",e._getCircleStrokeWidth(),"%")("transform-origin",e._getCircleTransformOrigin(s)),v.uIk("r",e._getCircleRadius())}}const Wv=(0,we.pj)(class{constructor(n){this._elementRef=n}},"primary"),Uv=new v.OlP("mat-progress-spinner-default-options",{providedIn:"root",factory:function Gv(){return{diameter:100}}});class Rs extends Wv{constructor(t,e,s,r,a,o,i,l){super(t),this._document=s,this._diameter=100,this._value=0,this._resizeSubscription=ca.w0.EMPTY,this.mode="determinate";const u=Rs._diameters;this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),u.has(s.head)||u.set(s.head,new Set([100])),this._noopAnimations="NoopAnimations"===r&&!!a&&!a._forceAnimations,"mat-spinner"===t.nativeElement.nodeName.toLowerCase()&&(this.mode="indeterminate"),a&&(a.diameter&&(this.diameter=a.diameter),a.strokeWidth&&(this.strokeWidth=a.strokeWidth)),e.isBrowser&&e.SAFARI&&i&&o&&l&&(this._resizeSubscription=i.change(150).subscribe(()=>{"indeterminate"===this.mode&&l.run(()=>o.markForCheck())}))}get diameter(){return this._diameter}set diameter(t){this._diameter=(0,_t.su)(t),this._spinnerAnimationLabel=this._getSpinnerAnimationLabel(),this._styleRoot&&this._attachStyleNode()}get strokeWidth(){return this._strokeWidth||this.diameter/10}set strokeWidth(t){this._strokeWidth=(0,_t.su)(t)}get value(){return"determinate"===this.mode?this._value:0}set value(t){this._value=Math.max(0,Math.min(100,(0,_t.su)(t)))}ngOnInit(){const t=this._elementRef.nativeElement;this._styleRoot=(0,fn.kV)(t)||this._document.head,this._attachStyleNode(),t.classList.add("mat-progress-spinner-indeterminate-animation")}ngOnDestroy(){this._resizeSubscription.unsubscribe()}_getCircleRadius(){return(this.diameter-10)/2}_getViewBox(){const t=2*this._getCircleRadius()+this.strokeWidth;return`0 0 ${t} ${t}`}_getStrokeCircumference(){return 2*Math.PI*this._getCircleRadius()}_getStrokeDashOffset(){return"determinate"===this.mode?this._getStrokeCircumference()*(100-this._value)/100:null}_getCircleStrokeWidth(){return this.strokeWidth/this.diameter*100}_getCircleTransformOrigin(t){var e;const s=50*(null!==(e=t.currentScale)&&void 0!==e?e:1);return`${s}% ${s}%`}_attachStyleNode(){const t=this._styleRoot,e=this._diameter,s=Rs._diameters;let r=s.get(t);if(!r||!r.has(e)){const a=this._document.createElement("style");a.setAttribute("mat-spinner-animation",this._spinnerAnimationLabel),a.textContent=this._getAnimationText(),t.appendChild(a),r||(r=new Set,s.set(t,r)),r.add(e)}}_getAnimationText(){const t=this._getStrokeCircumference();return"\n @keyframes mat-progress-spinner-stroke-rotate-DIAMETER {\n    0%      { stroke-dashoffset: START_VALUE;  transform: rotate(0); }\n    12.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(0); }\n    12.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(72.5deg); }\n    25%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(72.5deg); }\n\n    25.0001%   { stroke-dashoffset: START_VALUE;  transform: rotate(270deg); }\n    37.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(270deg); }\n    37.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(161.5deg); }\n    50%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(161.5deg); }\n\n    50.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(180deg); }\n    62.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(180deg); }\n    62.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(251.5deg); }\n    75%     { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(251.5deg); }\n\n    75.0001%  { stroke-dashoffset: START_VALUE;  transform: rotate(90deg); }\n    87.5%   { stroke-dashoffset: END_VALUE;    transform: rotate(90deg); }\n    87.5001%  { stroke-dashoffset: END_VALUE;    transform: rotateX(180deg) rotate(341.5deg); }\n    100%    { stroke-dashoffset: START_VALUE;  transform: rotateX(180deg) rotate(341.5deg); }\n  }\n".replace(/START_VALUE/g,""+.95*t).replace(/END_VALUE/g,""+.2*t).replace(/DIAMETER/g,`${this._spinnerAnimationLabel}`)}_getSpinnerAnimationLabel(){return this.diameter.toString().replace(".","_")}}Rs._diameters=new WeakMap,Rs.\u0275fac=function(t){return new(t||Rs)(v.Y36(v.SBq),v.Y36(fn.t4),v.Y36(Ne.K0,8),v.Y36(be.Qb,8),v.Y36(Uv),v.Y36(v.sBO),v.Y36(Mv.rL),v.Y36(v.R0b))},Rs.\u0275cmp=v.Xpm({type:Rs,selectors:[["mat-progress-spinner"],["mat-spinner"]],hostAttrs:["role","progressbar","tabindex","-1",1,"mat-progress-spinner","mat-spinner"],hostVars:10,hostBindings:function(t,e){2&t&&(v.uIk("aria-valuemin","determinate"===e.mode?0:null)("aria-valuemax","determinate"===e.mode?100:null)("aria-valuenow","determinate"===e.mode?e.value:null)("mode",e.mode),v.Udp("width",e.diameter,"px")("height",e.diameter,"px"),v.ekj("_mat-animation-noopable",e._noopAnimations))},inputs:{color:"color",diameter:"diameter",strokeWidth:"strokeWidth",mode:"mode",value:"value"},exportAs:["matProgressSpinner"],features:[v.qOj],decls:4,vars:8,consts:[["preserveAspectRatio","xMidYMid meet","focusable","false","aria-hidden","true",3,"ngSwitch"],["svg",""],["cx","50%","cy","50%",3,"animation-name","stroke-dashoffset","stroke-dasharray","stroke-width","transform-origin",4,"ngSwitchCase"],["cx","50%","cy","50%",3,"stroke-dashoffset","stroke-dasharray","stroke-width","transform-origin",4,"ngSwitchCase"],["cx","50%","cy","50%"]],template:function(t,e){1&t&&(v.O4$(),v.TgZ(0,"svg",0,1),v.YNc(2,Vv,1,11,"circle",2),v.YNc(3,zv,1,9,"circle",3),v.qZA()),2&t&&(v.Udp("width",e.diameter,"px")("height",e.diameter,"px"),v.Q6J("ngSwitch","indeterminate"===e.mode),v.uIk("viewBox",e._getViewBox()),v.xp6(2),v.Q6J("ngSwitchCase",!0),v.xp6(1),v.Q6J("ngSwitchCase",!1))},directives:[Ne.RF,Ne.n9],styles:[".mat-progress-spinner{display:block;position:relative;overflow:hidden}.mat-progress-spinner svg{position:absolute;transform:rotate(-90deg);top:0;left:0;transform-origin:center;overflow:visible}.mat-progress-spinner circle{fill:transparent;transition:stroke-dashoffset 225ms linear}._mat-animation-noopable.mat-progress-spinner circle{transition:none;animation:none}.cdk-high-contrast-active .mat-progress-spinner circle{stroke:CanvasText}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{animation:mat-progress-spinner-linear-rotate 2000ms linear infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] svg{transition:none;animation:none}.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition-property:stroke;animation-duration:4000ms;animation-timing-function:cubic-bezier(0.35, 0, 0.25, 1);animation-iteration-count:infinite}._mat-animation-noopable.mat-progress-spinner.mat-progress-spinner-indeterminate-animation[mode=indeterminate] circle{transition:none;animation:none}@keyframes mat-progress-spinner-linear-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes mat-progress-spinner-stroke-rotate-100{0%{stroke-dashoffset:268.606171575px;transform:rotate(0)}12.5%{stroke-dashoffset:56.5486677px;transform:rotate(0)}12.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(72.5deg)}25%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(72.5deg)}25.0001%{stroke-dashoffset:268.606171575px;transform:rotate(270deg)}37.5%{stroke-dashoffset:56.5486677px;transform:rotate(270deg)}37.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(161.5deg)}50%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(161.5deg)}50.0001%{stroke-dashoffset:268.606171575px;transform:rotate(180deg)}62.5%{stroke-dashoffset:56.5486677px;transform:rotate(180deg)}62.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(251.5deg)}75%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(251.5deg)}75.0001%{stroke-dashoffset:268.606171575px;transform:rotate(90deg)}87.5%{stroke-dashoffset:56.5486677px;transform:rotate(90deg)}87.5001%{stroke-dashoffset:56.5486677px;transform:rotateX(180deg) rotate(341.5deg)}100%{stroke-dashoffset:268.606171575px;transform:rotateX(180deg) rotate(341.5deg)}}\n"],encapsulation:2,changeDetection:0});let jv=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=v.oAB({type:n}),n.\u0275inj=v.cJS({imports:[[we.BQ,Ne.ez],we.BQ]}),n})();var om=J(6696);function im(n,t,e,s,r,a,o){try{var i=n[a](o),l=i.value}catch(u){return void e(u)}i.done?t(l):Promise.resolve(l).then(s,r)}function Z(n){return function(){var t=this,e=arguments;return new Promise(function(s,r){var a=n.apply(t,e);function o(l){im(a,s,r,o,i,"next",l)}function i(l){im(a,s,r,o,i,"throw",l)}o(void 0)})}}var qv=J(8855),_r=J(2640);class lm{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Mc{refCount(t){return En("refCount")}incRef(t){return En("incRef")}timerAvailable(){return!0}time(t){return En("time")}read(t){return En("read")}readSync(t){return En("readSync")}readToGPU(t,e){return En("readToGPU")}numDataIds(){return En("numDataIds")}disposeData(t,e){return En("disposeData")}write(t,e,s){return En("write")}move(t,e,s,r,a){return En("move")}createTensorFromGPUData(t,e,s){return En("createTensorFromGPUData")}memory(){return En("memory")}floatPrecision(){return En("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return En("dispose")}}function En(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function um(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Ys(n,t,e)}function $r(n,t,e){return Math.max(n,Math.min(t,e))}function Vc(n){return n%2==0?n:n+1}function Ys(n,t,e){const s=n[t];n[t]=n[e],n[e]=s}function I(n,t){if(!n)throw new Error("string"==typeof t?t:t())}function Hn(n,t,e=""){I(Qe(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function cm(n){I(null!=n,()=>"The input to the tensor constructor must be a non-null value.")}function W(n){if(0===n.length)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function Qe(n,t){if(n===t)return!0;if(null==n||null==t||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function da(n){return n%1==0}function zc(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function ha(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function dm(n,t=(r=>0),e,s){return new Promise((r,a)=>{let o=0;const i=()=>{if(n())return void r();o++;const l=t(o);null!=e&&o>=e?a():null!=s?s(i,l):setTimeout(i,l)};i()})}function hm(n,t){let e=1,s=-1;for(let a=0;a<n.length;++a)if(n[a]>=0)e*=n[a];else if(-1===n[a]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(n[a]<0)throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);if(-1===s){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(0===e)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const r=n.slice();return r[s]=t/e,r}function ze(n,t){const e=t.length;return I((n=null==n?t.map((s,r)=>r):[].concat(n)).every(s=>s>=-e&&s<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),I(n.every(s=>da(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?e+s:s)}function Js(n,t){const e=[],s=[],r=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||r?null:ze(t,n).sort();let o=0;for(let i=0;i<n.length;++i){if(null!=a){if(a[o]===i&&1!==n[i])throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(null==a[o]||a[o]>i)&&1===n[i]&&(e.push(n[i]),s.push(i)),a[o]<=i&&o++}1!==n[i]&&(e.push(n[i]),s.push(i))}return{newShape:e,keptDims:s}}function ln(n,t){return $t(n,t)}function $t(n,t){let e=null;if(null==n||"float32"===n)e=new Float32Array(t);else if("int32"===n)e=new Int32Array(t);else if("bool"===n)e=new Uint8Array(t);else{if("string"!==n)throw new Error(`Unknown data type ${n}`);e=new Array(t)}return e}function pm(n,t){return!("complex64"===t||"float32"===t&&"complex64"!==n||"int32"===t&&"float32"!==n&&"complex64"!==n||"bool"===t&&"bool"===n)}function Hi(n){if("float32"===n||"int32"===n)return 4;if("complex64"===n)return 8;if("bool"===n)return 1;throw new Error(`Unknown dtype ${n}`)}function eo(n){return"string"==typeof n||n instanceof String}function Bc(n){return"number"==typeof n}function pa(n){return Array.isArray(n)?pa(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Bc(n)?"float32":eo(n)?"string":function eC(n){return"boolean"==typeof n}(n)?"bool":"float32"}function Wc(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Uc(n,t){for(let e=t;e<n;++e)if(n%e==0)return e;return n}function Ie(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let s=t-3;s>=0;--s)e[s]=e[s+1]*n[s+1];return e}function fm(n,t,e,s=!1){const r=new Array;if(1===t.length){const a=t[0]*(s?2:1);for(let o=0;o<a;o++)r[o]=e[n+o]}else{const a=t[0],o=t.slice(1),i=o.reduce((l,u)=>l*u)*(s?2:1);for(let l=0;l<a;l++)r[l]=fm(n+l*i,o,e,s)}return r}function ss(n,t,e=!1){if(0===n.length)return t[0];const s=n.reduce((r,a)=>r*a)*(e?2:1);if(0===s)return[];if(s!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return fm(0,n,t,e)}function Gc(n,t){const e=un(n,t);for(let s=0;s<e.length;s++)e[s]=1;return e}function un(n,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t)return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function mm(n,t){const e=n.reduce((s,r)=>s*r,1);if(null==t||"float32"===t)return ss(n,new Float32Array(e));if("int32"===t)return ss(n,new Int32Array(e));if("bool"===t)return ss(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Fs(n){n.forEach(t=>{I(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function gs(n,t,e){if(0===t)return 0;if(1===t)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=e[r]*n[r];return s}function fa(n,t,e){if(0===t)return[];if(1===t)return[n];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/e[r]),n-=s[r]*e[r];return s[s.length-1]=n,s}function Hc(n){return n&&n.then&&"function"==typeof n.then}const gm="tfjsflags";class nC{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=sC,this.populateURLFlags()}setPlatform(t,e){null!=this.platform&&(V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,s){if(this.flagRegistry[t]={evaluationFn:e,setHook:s},null!=this.urlFlags[t]){const r=this.urlFlags[t];V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}getAsync(t){var e=this;return Z(function*(){return t in e.flags||(e.flags[t]=yield e.evaluateFlag(t)),e.flags[t]})()}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Hc(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(null==this.flagRegistry[t])throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,null!=this.flagRegistry[t].setHook&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(null==this.flagRegistry[t])throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const t=this.getQueryParams(this.global.location.search);gm in t&&t[gm].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=function aC(n,t){const e=t.toLowerCase();return"true"===e||"false"===e?"true"===e:""+ +e===e?+e:t}(0,a)})}}function sC(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...s)=>(function rC(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}(t,s[0],s[1]),s.join("="))),t}function V(){return ym}let jc,ym=null;function xm(){if(null==jc){let n;if("undefined"!=typeof window)n=window;else if("undefined"!=typeof global)n=global;else if("undefined"!=typeof process)n=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}jc=n}return jc}function qc(n,t){const e=function iC(){const n=xm();return null==n._tfGlobals&&(n._tfGlobals=new Map),n._tfGlobals}();if(e.has(n))return e.get(n);{const s=t();return e.set(n,s),e.get(n)}}const ji="Abs",to="Acos",no="Acosh",ma="Add",Kc="AddN",qi="ArgMax",Ki="ArgMin",so="Asin",ro="Asinh",ao="Atan",oo="Atanh",lo="Atan2",Xi="AvgPool",Yc="AvgPoolGrad",Zi="AvgPool3D",Jc="AvgPool3DGrad",Yi="BatchMatMul",Ji="BatchToSpaceND",Qc="Bincount",ed="BitwiseAnd",bm="BroadcastArgs",uo="Cast",co="Ceil",ho="ClipByValue",td="Complex",Qi="ComplexAbs",el="Concat",tl="Conv2D",nd="Conv2DBackpropFilter",nl="Conv2DBackpropInput",sl="Conv3D",sd="Conv3DBackpropFilterV2",rd="Conv3DBackpropInputV2",po="Cos",fo="Cosh",ad="Cumprod",rl="Cumsum",od="CropAndResize",id="DenseBincount",ld="DepthToSpace",al="DepthwiseConv2dNative",ud="DepthwiseConv2dNativeBackpropFilter",cd="DepthwiseConv2dNativeBackpropInput",ol="Dilation2D",dd="Dilation2DBackpropInput",hd="Dilation2DBackpropFilter",mo="RealDiv",pd="Einsum",go="Elu",fd="EluGrad",yo="Erf",il="Equal",xo="Exp",ll="ExpandDims",bo="Expm1",gd="Fill",yd="FlipLeftRight",wo="Floor",vo="FloorDiv",ul="FusedBatchNorm",cl="GatherV2",vm="GatherNd",dl="Greater",Co="GreaterEqual",So="Identity",xd="IFFT",bd="Imag",Io="IsFinite",To="IsInf",No="IsNan",hl="LeakyRelu",pl="Less",fl="LessEqual",Cm="LinSpace",ko="Log",_o="Log1p",ml="LogicalAnd",gl="LogicalNot",yl="LogicalOr",xl="LRN",wd="LRNGrad",bl="Max",$o="Maximum",wl="MaxPool",vd="MaxPoolGrad",vl="MaxPool3D",Cd="MaxPool3DGrad",Sm="MaxPoolWithArgmax",Cl="Mean",Sl="Min",Eo="Minimum",Il="MirrorPad",Ao="Mod",Im="Multinomial",Do="Multiply",Tl="Neg",Nl="NotEqual",Sd="NonMaxSuppressionV3",Id="NonMaxSuppressionV4",Td="NonMaxSuppressionV5",kl="OnesLike",_l="OneHot",$l="Pack",El="PadV2",Ro="Pow",Al="Prelu",Dl="Prod",Tm="RaggedGather",Nm="RaggedRange",km="RaggedTensorToTensor",Nd="Range",kd="Real",Fo="Reciprocal",Oo="Relu",Rl="Reshape",Fl="ResizeNearestNeighbor",_d="ResizeNearestNeighborGrad",Ol="ResizeBilinear",$d="ResizeBilinearGrad",Po="Relu6",Pl="Reverse",Lo="Round",Mo="Rsqrt",_m="ScatterNd",$m="TensorScatterUpdate",Em="SearchSorted",Ll="Select",Vo="Selu",Ml="Slice",zo="Sin",Bo="Sinh",Wo="Sign",Uo="Sigmoid",Go="Softplus",Ho="Sqrt",Vl="Sum",zl="SpaceToBatchND",Bl="SplitV",Wl="Softmax",Ed="SparseFillEmptyRows",Ad="SparseReshape",Dd="SparseSegmentMean",Rd="SparseSegmentSum",Am="SparseToDense",jo="SquaredDifference",Fd="Square",Ul="StaticRegexReplace",Od="StridedSlice",Pd="StringNGrams",Ld="StringSplit",Md="StringToHashBucketFast",qo="Sub",Ko="Tan",Xo="Tanh",Zo="Tile",Vd="TopK",zd="Transform",ga="Transpose",Bd="Unique",Gl="Unpack",Hl="UnsortedSegmentSum",jl="ZerosLike",Yo="Step",Wd="RotateWithOffset",ql="_FusedMatMul",Kl="FusedConv2D",Xl="FusedDepthwiseConv2D";function On(...n){V().getBool("IS_TEST")||V().getBool("PROD")||console.warn(...n)}function hC(...n){V().getBool("IS_TEST")||V().getBool("PROD")||console.log(...n)}const ya=qc("kernelRegistry",()=>new Map),Jo=qc("gradRegistry",()=>new Map);function Dm(n,t){const e=Hd(n,t);return ya.get(e)}function Rm(n){return Jo.get(n)}function Ud(n){const t=ya.entries(),e=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[a,o]=r,[i]=a.split("_");i===n&&e.push(o)}return e}function Gd(n){const{kernelName:t,backendName:e}=n,s=Hd(t,e);ya.has(s)&&On(`The kernel '${t}' for backend '${e}' is already registered`),ya.set(s,n)}function pC(n){const{kernelName:t}=n;Jo.has(t)&&V().getBool("DEBUG")&&On(`Overriding the gradient for '${t}'`),Jo.set(t,n)}function Hd(n,t){return`${t}_${n}`}function Fm(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Om=J(7658);const Er=J.n(Om)()||Om;function Zl(n){return Er.fromString(n,!0,16)}const Pm=Zl("c3a5c85c97cb3127"),Ar=Zl("b492b66fbe98f273"),mn=Zl("9ae16a3b2f90404f");function jd(n){return n.xor(n.shru(47))}function Lm(n,t,e){const s=n.slice(t,t+e);return Er.fromBytes(Array.from(s),!0,!0)}function ht(n,t){return Lm(n,t,8)}function Mm(n,t){return Lm(n,t,4)}function jt(n,t){return 0===t?n:n.shru(t).or(n.shl(64-t))}function Qs(n,t,e=Zl("9ddfea08eb382d69")){let s=n.xor(t).mul(e);s=s.xor(s.shru(47));let r=t.xor(s).mul(e);return r=r.xor(r.shru(47)),r=r.mul(e),r}function Yl(n,t,e,s){return function mC(n,t,e,s,r,a){r=r.add(n),a=jt(a.add(r).add(s),21);const o=r;return r=(r=r.add(t)).add(e),a=a.add(jt(r,44)),[r.add(s),a.add(o)]}(ht(n,t),ht(n,t+8),ht(n,t+16),ht(n,t+24),e,s)}function bC(n,t=n.length){const e=Er.fromNumber(81,!0);if(t<=32)return t<=16?function gC(n,t=n.length){if(t>=8){const e=mn.add(2*t),s=ht(n,0).add(mn),r=ht(n,t-8);return Qs(jt(r,37).mul(e).add(s),jt(s,25).add(r).mul(e),e)}if(t>=4){const e=mn.add(2*t);return Qs(Mm(n,0).shl(3).add(t),Mm(n,t-4),e)}if(t>0){const o=t+(n[t-1]<<2);return jd(mn.mul(n[0]+(n[t>>1]<<8)).xor(Pm.mul(o))).mul(mn)}return mn}(n,t):function yC(n,t=n.length){const e=mn.add(2*t),s=ht(n,0).mul(Ar),r=ht(n,8),a=ht(n,t-8).mul(e),o=ht(n,t-16).mul(mn);return Qs(jt(s.add(r),43).add(jt(a,30)).add(o),s.add(jt(r.add(mn),18)).add(a),e)}(n,t);if(t<=64)return function xC(n,t=n.length){const e=mn.add(2*t),s=ht(n,0).mul(mn),r=ht(n,8),a=ht(n,t-8).mul(e),o=ht(n,t-16).mul(mn),i=jt(s.add(r),43).add(jt(a,30)).add(o),l=Qs(i,s.add(jt(r.add(mn),18)).add(a),e),u=ht(n,16).mul(e),c=ht(n,24),d=i.add(ht(n,t-32)).mul(e),h=l.add(ht(n,t-24)).mul(e);return Qs(jt(u.add(c),43).add(jt(d,30)).add(h),u.add(jt(c.add(s),18)).add(d),e)}(n,t);let s=e,r=e.mul(Ar).add(113),a=jd(r.mul(mn).add(113)).mul(mn),o=[Er.UZERO,Er.UZERO],i=[Er.UZERO,Er.UZERO];s=s.mul(mn).add(ht(n,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{s=jt(s.add(r).add(o[0]).add(ht(n,l+8)),37).mul(Ar),r=jt(r.add(o[1]).add(ht(n,l+48)),42).mul(Ar),s=s.xor(i[1]),r=r.add(o[0]).add(ht(n,l+40)),a=jt(a.add(i[0]),33).mul(Ar),o=Yl(n,l,o[1].mul(Ar),s.add(i[0])),i=Yl(n,l+32,a.add(i[1]),r.add(ht(n,l+16))),[a,s]=[s,a],l+=64}while(l!==u);const d=Ar.add(a.and(255).shl(1));return l=c,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),s=jt(s.add(r).add(o[0]).add(ht(n,l+8)),37).mul(d),r=jt(r.add(o[1]).add(ht(n,l+48)),42).mul(d),s=s.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(ht(n,l+40))),a=jt(a.add(i[0]),33).mul(d),o=Yl(n,l,o[1].mul(d),s.add(i[0])),i=Yl(n,l+32,a.add(i[1]),r.add(ht(n,l+16))),[a,s]=[s,a],Qs(Qs(o[0],i[0],d).add(jd(r).mul(Pm)).add(a),Qs(o[1],i[1],d).add(s),d)}function er(n,t){return"string"===t?tr(n):Dr([n],t)}function Dr(n,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Rr(n)),V().getBool("DEBUG")&&function Yv(n,t){for(let e=0;e<n.length;e++){const s=n[e];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}(n,t),function wC(n,t){return n instanceof Float32Array&&"float32"===t||n instanceof Int32Array&&"int32"===t||n instanceof Uint8Array&&"bool"===t}(n,t))return n;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(n);if("int32"===t)return new Int32Array(n);if("bool"===t){const e=new Uint8Array(n.length);for(let s=0;s<e.length;++s)0!==Math.round(n[s])&&(e[s]=1);return e}throw new Error(`Unknown data type ${t}`)}function In(){return V().platform.now()}function tr(n,t="utf-8"){return t=t||"utf-8",V().platform.encode(n,t)}function nr(n,t="utf-8"){return t=t||"utf-8",V().platform.decode(n,t)}function jn(n){return null!=V().platform.isTypedArray?V().platform.isTypedArray(n):Fm(n)}function Rr(n,t=[],e=!1){if(null==t&&(t=[]),"boolean"==typeof n||"number"==typeof n||"string"==typeof n||Hc(n)||null==n||jn(n)&&e)t.push(n);else if(Array.isArray(n)||jn(n))for(let s=0;s<n.length;++s)Rr(n[s],t,e);else{let s=-1;for(const r of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)Rr(n[r],t,e)}return t}class vC{constructor(t,e){this.backendTimer=t,this.logger=e,null==e&&(this.logger=new SC)}profileKernel(t,e,s){let r;const a=()=>{r=s()};let o;const i=In();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const u of r)u.dataSync();o=Promise.resolve({kernelMs:In()-i})}if(V().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<r.length;u++){const c=r[u];c.data().then(d=>{CC(d,c.dtype,t)})}return{kernelName:t,outputs:r,inputs:e,timeMs:o.then(u=>u.kernelMs),extraInfo:o.then(u=>null!=u.getExtraProfileInfo?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:s,timeMs:r,inputs:a,extraInfo:o}=t;s.forEach(i=>{Promise.all([i.data(),r,o]).then(l=>{this.logger.logKernelProfile(e,i,l[0],l[1],a,l[2])})})}}function CC(n,t,e){if("float32"!==t)return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${e}'`),!0}return!1}class SC{logKernelProfile(t,e,s,r,a,o){const i="number"==typeof r?ha(`${r}ms`,9):r.error,l=ha(t,25),u=e.rank,c=e.size,d=ha(e.shape.toString(),14);let h="";for(const p in a){const f=a[p];if(null!=f){const g=f.shape||e.shape,m=g.length;h+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}\t%c${i}\t%c${u}D ${d}\t%c${c}\t%c${h}\t%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function NC(n,t,e,s){const r=Ie(t),a=function kC(n,t,e,s){const r=W(t),a=s[s.length-1],o=new Array(a).fill(0),i=t.length,l="complex64"===e?ti(n):n;if(i>1)for(let u=0;u<r/a;u++){const c=u*a;for(let d=0;d<a;d++)o[d]=Math.max(o[d],ei(l[c+d],0,e).length)}return o}(n,t,e,r),o=t.length,i=Jl(n,t,e,r,a),l=["Tensor"];return s&&(l.push(`  dtype: ${e}`),l.push(`  rank: ${o}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(i.map(u=>"    "+u).join("\n")),l.join("\n")}function ei(n,t,e){let s;return s=Array.isArray(n)?`${parseFloat(n[0].toFixed(7))} + ${parseFloat(n[1].toFixed(7))}j`:eo(n)?`'${n}'`:"bool"===e?zm(n):parseFloat(n.toFixed(7)).toString(),ha(s,t)}function zm(n){return 0===n?"false":"true"}function Jl(n,t,e,s,r,a=!0){const o="complex64"===e?2:1,i=t[0],l=t.length;if(0===l)return"complex64"===e?[ei(ti(n)[0],0,e)]:"bool"===e?[zm(n[0])]:[n[0].toString()];if(1===l){if(i>20){let y=Array.from(n.slice(0,3*o)),x=Array.from(n.slice((i-3)*o,i*o));return"complex64"===e&&(y=ti(y),x=ti(x)),["["+y.map((b,w)=>ei(b,r[w],e)).join(", ")+", ..., "+x.map((b,w)=>ei(b,r[i-3+w],e)).join(", ")+"]"]}return["["+("complex64"===e?ti(n):Array.from(n)).map((m,y)=>ei(m,r[y],e)).join(", ")+"]"]}const u=t.slice(1),c=s.slice(1),d=s[0]*o,h=[];if(i>20){for(let g=0;g<3;g++){const m=g*d;h.push(...Jl(n.slice(m,m+d),u,e,c,r,!1))}h.push("...");for(let g=i-3;g<i;g++){const m=g*d;h.push(...Jl(n.slice(m,m+d),u,e,c,r,g===i-1))}}else for(let g=0;g<i;g++){const m=g*d;h.push(...Jl(n.slice(m,m+d),u,e,c,r,g===i-1))}const p=2===l?",":"";h[0]="["+(i>0?h[0]+p:"");for(let g=1;g<h.length-1;g++)h[g]=" "+h[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function ti(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class tn{constructor(t,e,s){if(this.dtype=e,this.shape=t.slice(),this.size=W(t),null!=s){const r=s.length;I(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===e)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||$t(e,this.size),this.strides=Ie(t)}set(t,...e){0===e.length&&(e=[0]),I(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const s=this.locToIndex(e);this.values[s]=t}get(...t){0===t.length&&(t=[0]);let e=0;for(const r of t){if(r<0||r>=this.shape[e])throw new Error(`Requested out of range element at ${t}.   Buffer shape=${this.shape}`);e++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(0===this.rank)return 0;if(1===this.rank)return t[0];let e=t[t.length-1];for(let s=0;s<t.length-1;++s)e+=this.strides[s]*t[s];return e}indexToLoc(t){if(0===this.rank)return[];if(1===this.rank)return[t];const e=new Array(this.shape.length);for(let s=0;s<e.length-1;++s)e[s]=Math.floor(t/this.strides[s]),t-=e[s]*this.strides[s];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return rs().makeTensor(this.values,this.shape,this.dtype)}}let rs=null,xa=null,Bm=null;class Vt{constructor(t,e,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=W(t),this.strides=Ie(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var t=this;return Z(function*(){const e=yield t.data();return xa.buffer(t.shape,t.dtype,e)})()}bufferSync(){return xa.buffer(this.shape,this.dtype,this.dataSync())}array(){var t=this;return Z(function*(){const e=yield t.data();return ss(t.shape,e,"complex64"===t.dtype)})()}arraySync(){return ss(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var t=this;return Z(function*(){t.throwIfDisposed();const e=rs().read(t.dataId);if("string"===t.dtype){const s=yield e;try{return s.map(r=>nr(r))}catch(r){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e})()}dataToGPU(t){return this.throwIfDisposed(),rs().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=rs().readSync(this.dataId);if("string"===this.dtype)try{return t.map(e=>nr(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}bytes(){var t=this;return Z(function*(){t.throwIfDisposed();const e=yield rs().read(t.dataId);return"string"===t.dtype?e:new Uint8Array(e.buffer)})()}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),rs().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return xa.print(this,t)}clone(){return this.throwIfDisposed(),xa.clone(this)}toString(t=!1){return NC(this.dataSync(),this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),xa.cast(this,t)}variable(t=!0,e,s){return this.throwIfDisposed(),rs().makeVariable(this,t,e,s)}}function j(){return qc("Tensor",()=>Vt)}Object.defineProperty(Vt,Symbol.hasInstance,{value:n=>!!n&&null!=n.data&&null!=n.dataSync&&null!=n.throwIfDisposed}),j();class Ql extends Vt{constructor(t,e,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=e,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Qe(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);rs().disposeTensor(this),this.dataId=t.dataId,rs().incRef(this,null)}dispose(){rs().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ql,Symbol.hasInstance,{value:n=>n instanceof Vt&&null!=n.assign&&n.assign instanceof Function});var eu=(()=>{return(n=eu||(eu={})).float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64",eu;var n})(),tu=(()=>{return(n=tu||(tu={})).float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64",tu;var n})(),nu=(()=>{return(n=nu||(nu={})).float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64",nu;var n})(),su=(()=>{return(n=su||(su={})).float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64",su;var n})();const AC={float32:nu,int32:eu,bool:tu,complex64:su};function An(n,t){if("string"===n||"string"===t){if("string"===n&&"string"===t)return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return AC[n][t]}function Kd(n){return An(n,"int32")}function Wm(n){return null!=n&&"object"==typeof n&&"texture"in n&&n.texture instanceof WebGLTexture}function Um(n){return"undefined"!=typeof GPUBuffer&&null!=n&&"object"==typeof n&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Nt(n,t){if(n.dtype===t.dtype)return[n,t];const e=An(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function Gm(n){const t=[];return Hm(n,t,new Set),t}function Hm(n,t,e){if(null==n)return;if(n instanceof Vt)return void t.push(n);if(!function DC(n){return Array.isArray(n)||"object"==typeof n}(n))return;const s=n;for(const r in s){const a=s[r];e.has(a)||(e.add(a),Hm(a,t,e))}}function Xd(n){return null!=n.kernelName}class jm{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}let RC=(()=>{class n{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new jm}ready(){var e=this;return Z(function*(){if(null!=e.pendingBackendInit)return e.pendingBackendInit.then(()=>{});if(null!=e.backendInstance)return;const s=e.getSortedBackends();for(let r=0;r<s.length;r++){const a=s[r];if(yield e.initializeBackend(a).success)return void(yield e.setBackend(a))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:s}=this.initializeBackendsAndReturnBest();if(s)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:s}=this.initializeBackend(e);if(s)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,s,r=1){return e in this.registryFactory?(On(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:s,priority:r},!0)}setBackend(e){var s=this;return Z(function*(){if(null==s.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(s.backendName=e,null==s.registry[e]){s.backendInstance=null;const{success:r,asyncInit:a}=s.initializeBackend(e);if(!(a?yield r:r))return!1}return s.backendInstance=s.registry[e],s.setupRegisteredKernels(),s.profiler=new vC(s.backendInstance),!0})()}setupRegisteredKernels(){Ud(this.backendName).forEach(s=>{null!=s.setupFunc&&s.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Ud(e).forEach(r=>{null!=r.disposeFunc&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const s=this.registryFactory[e];if(null==s)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=s.factory();if(!r||r instanceof Mc||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{const a=++this.pendingBackendInitId,o=r.then(i=>!(a<this.pendingBackendInitId||(this.registry[e]=i,this.pendingBackendInit=null,0))).catch(i=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,On(`Initialization of backend ${e} failed`),On(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}}catch(r){return On(`Initialization of backend ${e} failed`),On(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,s)=>this.registryFactory[s].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let s=0;s<e.length;s++){const r=e[s],{success:a,asyncInit:o}=this.initializeBackend(r);if(o||a)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,s){const r=this.state.tensorInfo.get(s),a=r.backend,o=this.readSync(s),i=a.refCount(s);a.disposeData(s,!0),r.backend=e,e.move(s,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,s){let a,r=null;if(null==s){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");s=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof s)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=s(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(e,s,r){e();try{const a=r();return s(),a}catch(a){throw s(),a}}nextTensorId(){return n.nextTensorId++}nextVariableId(){return n.nextVariableId++}clone(e){const s=R.runKernel(So,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[s],i=>({x:()=>R.runKernel(uo,{x:i},{dtype:"float32"})}),[],{}),s}runKernel(e,s,r){if(null==Dm(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:s,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,s,r){const a=this.backend.numDataIds();let o=0;r.forEach(u=>{o+="complex64"===u.dtype?3:1});const l=a-s-o-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${e}'`)}runKernelFunc(e){let s,r=[];const a=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;let l,u;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const c=Xd(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Xd(e)){const{kernelName:g,inputs:m,attrs:y}=e,x=Dm(g,this.backendName);I(null!=x,()=>`Cannot find registered kernel '${g}' for backend '${this.backendName}'`),l=()=>{const b=this.backend.numDataIds();u=x.kernelFunc({inputs:m,attrs:y,backend:this.backend});const w=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,b,w);const C=w.map(S=>null!=S.rank?S:this.makeTensorFromTensorInfo(S));if(a){const S=this.getTensorsForGradient(g,m,C);r=this.saveTensorsForBackwardMode(S)}return C}}else{const{forwardFunc:g}=e,m=y=>{!a||(r=y.map(x=>this.keep(this.clone(x))))};l=()=>{const y=this.backend.numDataIds();u=this.tidy(()=>g(this.backend,m));const x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,x),x}}const{inputs:d,attrs:h}=e,p=Xd(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(f=this.profiler.profileKernel(c,d,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),s=f.outputs):s=l()}),a&&this.addTapeNode(c,d,s,p,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(g=>null!=d[g]?d[g].shape:null),outputShapes:s.map(g=>g.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?s:s[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,s,r){const a=Rm(e);if(null!=a){const o=a.inputsToSave||[],i=a.outputsToSave||[];let l;a.saveAllInputs?(I(Array.isArray(s),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(s).map(c=>s[c])):l=o.map(c=>s[c]);const u=r.filter((c,d)=>i[d]);return l.concat(u)}return[]}makeTensor(e,s,r,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");a=a||this.backend;let o=e;"string"===(r=r||"float32")&&eo(e[0])&&(o=e.map(u=>tr(u)));const i=a.write(o,s,r),l=new Vt(s,r,i,this.nextTensorId());if(this.trackTensor(l,a),"string"===r){const u=this.state.tensorInfo.get(i),c=function Qv(n){if(null==n)return 0;let t=0;return n.forEach(e=>t+=e.length),t}(o);this.state.numBytes+=c-u.bytes,u.bytes=c}return l}makeTensorFromDataId(e,s,r,a){return this.makeTensorFromTensorInfo({dataId:e,shape:s,dtype:r=r||"float32"},a)}makeTensorFromTensorInfo(e,s){const{dataId:r,shape:a,dtype:o}=e,i=new Vt(a,o,r,this.nextTensorId());return this.trackTensor(i,s),i}makeVariable(e,s=!0,r,a){r=r||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const o=new Ql(e,s,r,this.nextTensorId());if(null!=this.state.registeredVariables[o.name])throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,s){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*Hi(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:s||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ql||this.track(e)}incRef(e,s){this.trackTensor(e,s),this.backend.incRef(e.dataId)}removeDataId(e,s){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===s&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const s=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=s.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const r=e.size*Hi(e.dtype);this.state.numBytes-=r}s.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,s.backend)}disposeVariables(){for(const e in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[e])}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}profile(e){var s=this;return Z(function*(){s.state.profiling=!0;const r=s.state.numBytes,a=s.state.numTensors;s.state.activeProfile.kernels=[],s.state.activeProfile.result=yield e(),s.state.profiling=!1,s.state.activeProfile.peakBytes=Math.max(...s.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),s.state.activeProfile.newBytes=s.state.numBytes-r,s.state.activeProfile.newTensors=s.state.numTensors-a;for(const o of s.state.activeProfile.kernels)o.kernelTimeMs=yield o.kernelTimeMs,o.extraInfo=yield o.extraInfo;return s.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,s,r,a,o,i){const l={id:this.state.nextTapeNodeId++,kernelName:e,inputs:s,outputs:r,saved:o},u=Rm(e);null!=u&&(a=u.gradFunc),null!=a&&(l.gradient=c=>(c=c.map((d,h)=>{if(null==d){const p=r[h],f=un(p.size,p.dtype);return this.makeTensor(f,p.shape,p.dtype)}return d}),a(c.length>1?c:c[0],o,i))),this.state.activeTape.push(l)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const s={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(s.name=e),this.state.scopeStack.push(s),this.state.activeScope=s}endScope(e){const s=Gm(e),r=new Set(s.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],s.forEach(o=>{!o.kept&&o.scopeId===a.id&&this.track(o)})}gradients(e,s,r,a=!1){if(I(s.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof Vt,()=>"The result y returned by f() must be a tensor.");const i=function IC(n,t,e){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<n.length;l++){const u=n[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<t.length;f++)if(s[h.id]){u.outputs.forEach(g=>s[g.id]=!0),p=!0,r[u.id]=!0;break}if(p)break}}const a={};a[e.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const u=n[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(const h in c)a[c[h].id]=!0,o[u.id]=!0;break}}const i=[];for(let l=0;l<n.length;l++){const u=n[l];if(r[u.id]&&o[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];s[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,i.push(d)}}return i}(this.state.activeTape,s,o);if(!a&&0===i.length&&s.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const l={};l[o.id]=null==r?function FC(n){const t=Gc(W(n),"float32");return R.makeTensor(t,n,"float32")}(o.shape):r,function TC(n,t,e,s){for(let r=t.length-1;r>=0;r--){const a=t[r],o=[];if(a.outputs.forEach(l=>{const u=n[l.id];o.push(null!=u?u:null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const l in a.inputs){if(!(l in i))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(i)}.`);const u=e(()=>i[l]());if("float32"!==u.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=a.inputs[l];if(!Qe(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(null==n[c.id])n[c.id]=u;else{const d=n[c.id];n[c.id]=s(d,u),d.dispose()}}}}(l,i,c=>this.tidy(c),OC);const u=s.map(c=>l[c.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(c=>{for(const d of c.saved)d.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return I(Wc(e),()=>"The f passed in customGrad(f) must be a function."),(...s)=>{let r;I(s.every(l=>l instanceof Vt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const a={};return s.forEach((l,u)=>{a[u]=l}),this.runKernelFunc({forwardFunc:(l,u)=>(r=e(...s,u),I(r.value instanceof Vt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(Wc(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(l,u)=>{const c=r.gradFunc(l,u),d=Array.isArray(c)?c:[c];I(d.length===s.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(d.every(p=>p instanceof Vt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return d.forEach((p,f)=>{h[f]=()=>p}),h},inputs:a})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,s){return this.state.tensorInfo.get(e).backend.readToGPU(e,s)}time(e){var s=this;return Z(function*(){const r=In(),a=yield s.backend.time(e);return a.wallMs=In()-r,a})()}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new jm;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return n.nextTensorId=0,n.nextVariableId=0,n})();function qm(){const n=xm();if(null==n._tfengine){const t=new nC(n);n._tfengine=new RC(t)}return function oC(n){ym=n}(n._tfengine.ENV),function _C(n){rs=n}(()=>n._tfengine),n._tfengine}const R=qm();function OC(n,t){return R.runKernel(ma,{a:n,b:t})}function Km(n){if(n||function PC(){return"undefined"!=typeof navigator&&null!=navigator}()){if(n||(n=navigator),"ReactNative"===n.product)return!0;const t=n.userAgent||n.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Xm(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Tn=V();function ru(n,t){let e=n;if(jn(n))return"string"===t?[]:[n.length];if(Wm(n))return[n.height,n.width*(n.channels||"RGBA").length];if(Um(n))return[n.buffer.size/(null==t?4:Hi(t))];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(e)||jn(e)&&"string"!==t;)s.push(e.length),e=e[0];return Array.isArray(n)&&V().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Zm(n,s,[]),s}function Zm(n,t,e){if(e=e||[],!Array.isArray(n)&&!jn(n))return void I(0===t.length,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);I(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const s=t.slice(1);for(let r=0;r<n.length;++r)Zm(n[r],s,e.concat(r))}function Ym(n,t,e,s){if("string_or_numeric"!==n){if(null==n)throw new Error("Expected dtype cannot be null.");if("numeric"!==n&&n!==t||"numeric"===n&&"string"===t)throw new Error(`Argument '${e}' passed to '${s}' must be ${n} tensor, but got ${t} tensor`)}}function N(n,t,e,s="numeric"){if(n instanceof j())return Ym(s,n.dtype,t,e),n;let r=pa(n);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Ym(s,r,t,e),null==n||!jn(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${null==n?"null":n.constructor.name}'`);const a=ru(n,r);!jn(n)&&!Array.isArray(n)&&(n=[n]);const i="string"!==r?Dr(n,r):Rr(n,[],!0);return R.makeTensor(i,a,r)}function Jm(n,t,e,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,o)=>N(a,`${t}[${o}]`,e,s))}function F(n){const t=Object.keys(n);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const s=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e+="__op";const r=(...a)=>{R.startScope(e);try{const o=s(...a);return Hc(o)&&console.error("Cannot return a Promise inside of tidy."),R.endScope(o),o}catch(o){throw R.endScope(null),o}};return Object.defineProperty(r,"name",{value:e,configurable:!0}),r}Tn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Tn.registerFlag("IS_BROWSER",()=>Xm()),Tn.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Tn.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Tn.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Tn.registerFlag("PROD",()=>!1),Tn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Tn.getBool("DEBUG")),Tn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Tn.registerFlag("IS_TEST",()=>!1),Tn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Tn.getBool("DEBUG")),Tn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Tn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Tn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const Fr=F({complex_:function MC(n,t){const e=N(n,"real","complex"),s=N(t,"imag","complex");return Hn(e.shape,s.shape,`real and imag shapes, ${e.shape} and ${s.shape}, must match in call to tf.complex().`),R.runKernel(td,{real:e,imag:s})}});function au(n,t,e,s){if(null==s)s=pa(n);else if("complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Um(n)||Wm(n)){if("float32"!==s&&"int32"!==s)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return R.backend.createTensorFromGPUData(n,t||e,s)}if(!jn(n)&&!Array.isArray(n)&&"number"!=typeof n&&"boolean"!=typeof n&&"string"!=typeof n)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Fs(t);const r=W(t),a=W(e);I(r===a,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${a}`);for(let o=0;o<e.length;++o){const i=e[o],l=o!==e.length-1||i!==W(t.slice(o));I(e[o]===t[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!jn(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n="string"!==s?Dr(n,s):Rr(n,[],!0),R.makeTensor(n,t,s)}function ni(n,t,e){return au(n,t,ru(n,e),e)}class ys{static join(t){return new ys(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,null==t||(t instanceof Array||(t=[t]),0===(t=t.map(s=>jn(s)?s.buffer:s)).length))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=e+r.byteLength;this.shards.push({buffer:r,start:e,end:a}),e=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),(e=Math.min(this.byteLength,e))<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(-1===s)throw new Error(`Could not find start shard for byte ${t}`);const a=new ArrayBuffer(e-t),o=new Uint8Array(a);let i=0;for(let l=s;l<this.shards.length;l++){const u=this.shards[l],d=t+i-u.start,h=i,f=Math.min(e,u.end)-u.start,g=new Uint8Array(u.buffer,d,f-d);if(o.set(g,h),i+=g.length,e<u.end)break}return a}findShardForByte(t){if(0===this.shards.length||t<0||t>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(r){return t<r.start?-1:t>=r.end?1:0}if(0===e(this.shards[this.previousShardIndex]))return this.previousShardIndex;const s=function VC(n,t){let e=0,s=n.length;for(;e<=s;){const r=Math.floor((s-e)/2)+e,a=t(n[r]);if(0===a)return r;a<0?s=r:e=r+1}return-1}(this.shards,e);return-1===s?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function xs(){return R}function Yd(){return R.memory()}function L(n,t){return R.tidy(n,t)}function Ue(n){Gm(n).forEach(e=>e.dispose())}function bs(n){return R.keep(n)}function Qm(n,t,e=1){return R.registerBackend(n,t,e)}function tg(n,t){return Jd.apply(this,arguments)}function Jd(){return Jd=Z(function*(n,t){const e=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const i=r[o],l=Array.isArray(n)?n[o].tensor:n[i];if("float32"!==l.dtype&&"int32"!==l.dtype&&"bool"!==l.dtype&&"string"!==l.dtype&&"complex64"!==l.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${l.dtype}`);const u={name:i,shape:l.shape,dtype:l.dtype};if("string"===l.dtype){const c=new Promise(function(){var d=Z(function*(h){const p=yield l.bytes(),f=p.reduce((y,x)=>y+x.length,0)+4*p.length,g=new Uint8Array(f);let m=0;for(let y=0;y<p.length;y++){const x=p[y],b=new Uint8Array(new Uint32Array([x.length]).buffer);g.set(b,m),m+=4,g.set(x,m),m+=x.length}h(g)});return function(h){return d.apply(this,arguments)}}());s.push(c)}else s.push(l.data());null!=t&&(u.group=t),e.push(u)}return{data:HC(yield Promise.all(s)),specs:e}}),Jd.apply(this,arguments)}function HC(n){if(null===n)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(a=>{if(t+=a.byteLength,e.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(t);let r=0;return e.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}!function EC(n){Bm=n}(function zC(n){V().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")});const nh="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function rg(n){return nh?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function og(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return null!=n.signature&&(e.signature=n.signature),null!=n.userDefinedMetadata&&(e.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(e.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(e.initializerSignature=n.initializerSignature),null!=n.trainingConfig&&(e.trainingConfig=n.trainingConfig),e}function XC(n,t,e){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(null!=n.trainingConfig&&(s.trainingConfig=n.trainingConfig),null!=n.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=e}return null!=n.signature&&(s.signature=n.signature),null!=n.userDefinedMetadata&&(s.userDefinedMetadata=n.userDefinedMetadata),null!=n.modelInitializer&&(s.modelInitializer=n.modelInitializer),null!=n.initializerSignature&&(s.initializerSignature=n.initializerSignature),s}function sh(){return(sh=Z(function*(n,t){let e,s;return null!=n.weightsManifest&&([e,s]=yield t(n.weightsManifest)),XC(n,e,s)})).apply(this,arguments)}function ou(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==n.modelTopology?0:rg(JSON.stringify(n.modelTopology)),weightSpecsBytes:null==n.weightSpecs?0:rg(JSON.stringify(n.weightSpecs)),weightDataBytes:null==n.weightData?0:new ys(n.weightData).byteLength}}function lg(n){const t=[];for(const e of n)t.push(...e.weights);return t}class Ct{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ct.instance&&(Ct.instance=new Ct),Ct.instance}static registerSaveRouter(t){Ct.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Ct.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Ct.getHandlers(t,"save")}static getLoadHandlers(t,e){return Ct.getHandlers(t,"load",e)}static getHandlers(t,e,s){const r=[];return("load"===e?Ct.getInstance().loadRouters:Ct.getInstance().saveRouters).forEach(o=>{const i=o(t,s);null!==i&&r.push(i)}),r}}const iu="tensorflowjs",Pr="models_store",rr="model_info_store";function oh(){if(!V().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n="undefined"==typeof window?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ih(n){const t=n.result;t.createObjectStore(Pr,{keyPath:"modelPath"}),t.createObjectStore(rr,{keyPath:"modelPath"})}let ba=(()=>{class n{constructor(e){if(this.indexedDB=oh(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}save(e){var s=this;return Z(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return s.databaseAction(s.modelPath,e)})()}load(){var e=this;return Z(function*(){return e.databaseAction(e.modelPath)})()}databaseAction(e,s){return new Promise((r,a)=>{const o=this.indexedDB.open(iu,1);o.onupgradeneeded=()=>ih(o),o.onsuccess=()=>{const i=o.result;if(null==s){const l=i.transaction(Pr,"readonly"),c=l.objectStore(Pr).get(this.modelPath);c.onsuccess=()=>{if(null==c.result)return i.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=d=>(i.close(),a(c.error)),l.oncomplete=()=>i.close()}else{s.weightData=ys.join(s.weightData);const l=ou(s),u=i.transaction(rr,"readwrite");let d,h,c=u.objectStore(rr);try{d=c.put({modelPath:this.modelPath,modelArtifactsInfo:l})}catch(p){return a(p)}d.onsuccess=()=>{h=i.transaction(Pr,"readwrite");const p=h.objectStore(Pr);let f;try{f=p.put({modelPath:this.modelPath,modelArtifacts:s,modelArtifactsInfo:l})}catch(g){return a(g)}f.onsuccess=()=>r({modelArtifactsInfo:l}),f.onerror=g=>{c=u.objectStore(rr);const m=c.delete(this.modelPath);m.onsuccess=()=>(i.close(),a(f.error)),m.onerror=y=>(i.close(),a(f.error))}},d.onerror=p=>(i.close(),a(d.error)),u.oncomplete=()=>{null==h?i.close():h.oncomplete=()=>i.close()}}},o.onerror=i=>a(o.error)})}}return n.URL_SCHEME="indexeddb://",n})();const ug=n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ba.URL_SCHEME)?function tS(n){return new ba(n)}(n.slice(ba.URL_SCHEME.length)):null;Ct.registerSaveRouter(ug),Ct.registerLoadRouter(ug);class sS{constructor(){this.indexedDB=oh()}listModels(){var t=this;return Z(function*(){return new Promise((e,s)=>{const r=t.indexedDB.open(iu,1);r.onupgradeneeded=()=>ih(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(rr,"readonly"),l=o.objectStore(rr).getAll();l.onsuccess=()=>{const u={};for(const c of l.result)u[c.modelPath]=c.modelArtifactsInfo;e(u)},l.onerror=u=>(a.close(),s(l.error)),o.oncomplete=()=>a.close()},r.onerror=a=>s(r.error)})})()}removeModel(t){var e=this;return Z(function*(){return t=function nS(n){return n.startsWith(ba.URL_SCHEME)?n.slice(ba.URL_SCHEME.length):n}(t),new Promise((s,r)=>{const a=e.indexedDB.open(iu,1);a.onupgradeneeded=()=>ih(a),a.onsuccess=()=>{const o=a.result,i=o.transaction(rr,"readwrite"),l=i.objectStore(rr),u=l.get(t);let c;u.onsuccess=()=>{if(null==u.result)return o.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const d=l.delete(t),h=()=>{c=o.transaction(Pr,"readwrite");const f=c.objectStore(Pr).delete(t);f.onsuccess=()=>s(u.result.modelArtifactsInfo),f.onerror=g=>r(u.error)};d.onsuccess=h,d.onerror=p=>(h(),o.close(),r(u.error))}},u.onerror=d=>(o.close(),r(u.error)),i.oncomplete=()=>{null==c?o.close():c.oncomplete=()=>o.close()}},a.onerror=o=>r(a.error)})})()}}const ws="/",Lr="tensorflowjs_models",cg="info",rS="model_topology",aS="weight_specs",oS="weight_data",iS="model_metadata";function dg(n){return{info:[Lr,n,cg].join(ws),topology:[Lr,n,rS].join(ws),weightSpecs:[Lr,n,aS].join(ws),weightData:[Lr,n,oS].join(ws),modelMetadata:[Lr,n,iS].join(ws)}}function hg(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function pg(n){const t=n.split(ws);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(ws)}let wa=(()=>{class n{constructor(e){if(!V().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=dg(this.modelPath)}save(e){var s=this;return Z(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const r=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),o=ou(e),i=ys.join(e.weightData);try{return s.LS.setItem(s.keys.info,JSON.stringify(o)),s.LS.setItem(s.keys.topology,r),s.LS.setItem(s.keys.weightSpecs,a),s.LS.setItem(s.keys.weightData,function jC(n){if(nh)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let s=0,r=t.length;s<r;s++)e+=String.fromCharCode(t[s]);return btoa(e)}(i)),s.LS.setItem(s.keys.modelMetadata,JSON.stringify({format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0})),{modelArtifactsInfo:o}}catch(l){throw hg(s.keys),new Error(`Failed to save model '${s.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}})()}load(){var e=this;return Z(function*(){const s=JSON.parse(e.LS.getItem(e.keys.info));if(null==s)throw new Error(`In local storage, there is no model with name '${e.modelPath}'`);if("JSON"!==s.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const r={},a=JSON.parse(e.LS.getItem(e.keys.topology));if(null==a)throw new Error(`In local storage, the topology of model '${e.modelPath}' is missing.`);r.modelTopology=a;const o=JSON.parse(e.LS.getItem(e.keys.weightSpecs));if(null==o)throw new Error(`In local storage, the weight specs of model '${e.modelPath}' are missing.`);r.weightSpecs=o;const i=e.LS.getItem(e.keys.modelMetadata);if(null!=i){const u=JSON.parse(i);r.format=u.format,r.generatedBy=u.generatedBy,r.convertedBy=u.convertedBy,null!=u.signature&&(r.signature=u.signature),null!=u.userDefinedMetadata&&(r.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(r.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(r.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(r.trainingConfig=u.trainingConfig)}const l=e.LS.getItem(e.keys.weightData);if(null==l)throw new Error(`In local storage, the binary weight values of model '${e.modelPath}' are missing.`);return r.weightData=function qC(n){if(nh){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let s=0;s<t.length;++s)e.set([t.charCodeAt(s)],s);return e.buffer}(l),r})()}}return n.URL_SCHEME="localstorage://",n})();const fg=n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(wa.URL_SCHEME)?function uS(n){return new wa(n)}(n.slice(wa.URL_SCHEME.length)):null;Ct.registerSaveRouter(fg),Ct.registerLoadRouter(fg);class cS{constructor(){I(V().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var t=this;return Z(function*(){const e={},s=Lr+ws,r=ws+cg;for(let a=0;a<t.LS.length;++a){const o=t.LS.key(a);o.startsWith(s)&&o.endsWith(r)&&(e[pg(o)]=JSON.parse(t.LS.getItem(o)))}return e})()}removeModel(t){var e=this;return Z(function*(){const s=dg(t=function lS(n){return n.startsWith(wa.URL_SCHEME)?n.slice(wa.URL_SCHEME.length):n}(t));if(null==e.LS.getItem(s.info))throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(e.LS.getItem(s.info));return hg(s),r})()}}class gn{constructor(){this.managers={}}static getInstance(){return null==gn.instance&&(gn.instance=new gn),gn.instance}static registerManager(t,e){I(null!=t,()=>"scheme must not be undefined or null."),t.endsWith("://")&&(t=t.slice(0,t.indexOf("://"))),I(t.length>0,()=>"scheme must not be an empty string.");const s=gn.getInstance();I(null==s.managers[t],()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=e}static getManager(t){const e=gn.getInstance().managers[t];if(null==e)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(gn.getInstance().managers)}}class dS{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){"undefined"!=typeof window&&V().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{s.source===window&&s.data.name===this.messageName&&(s.stopPropagation(),this.functionRefs[s.data.index](),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(t,e)}isTypedArray(t){return Fm(t)}}if(V().get("IS_BROWSER")){V().setPlatform("browser",new dS);try{gn.registerManager(wa.URL_SCHEME,new cS)}catch(n){}try{gn.registerManager(ba.URL_SCHEME,new sS)}catch(n){}}let Ca;function Be(n,t="float32",e){return t=t||"float32",Fs(n),new tn(n,t,e)}V().get("IS_NODE")&&!V().get("IS_BROWSER")&&V().setPlatform("node",new class pS{constructor(){this.util=J(8628),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return null!=V().global.fetch?V().global.fetch(t,e):(null==Ca&&(Ca=J(5410)),Ca(t,e))}now(){const t=process.hrtime();return 1e3*t[0]+t[1]/1e6}encode(t,e){if("utf-8"!==e&&"utf8"!==e)throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return 0===t.length?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}});const de=F({cast_:function fS(n,t){const e=N(n,"x","cast");if(!function Jv(n){return"bool"===n||"complex64"===n||"float32"===n||"int32"===n||"string"===n}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==e.dtype||"string"!==t&&"string"===e.dtype)throw new Error("Only strings can be casted to strings");return R.runKernel(uo,{x:e},{dtype:t})}}),Mr=F({clone_:function mS(n){const e={x:N(n,"x","clone","string_or_numeric")};return R.runKernel(So,e)}});qm(),function $C(n){xa=n}({buffer:Be,cast:de,clone:Mr,print:function gS(n,t=!1){console.log(n.toString(t))}});const te=F({add_:function yS(n,t){let e=N(n,"a","add"),s=N(t,"b","add");return[e,s]=Nt(e,s),R.runKernel(ma,{a:e,b:s})}}),gg=F({floorDiv_:function xS(n,t){let e=N(n,"a","floorDiv"),s=N(t,"b","floorDiv");return[e,s]=Nt(e,s),R.runKernel(vo,{a:e,b:s})}}),Se=F({div_:function bS(n,t){let e=N(n,"a","div"),s=N(t,"b","div");return[e,s]=Nt(e,s),"int32"===e.dtype&&"int32"===s.dtype?gg(e,s):R.runKernel(mo,{a:e,b:s},{})}}),A=F({mul_:function wS(n,t){let e=N(n,"a","mul"),s=N(t,"b","mul");return[e,s]=Nt(e,s),R.runKernel(Do,{a:e,b:s})}}),cn=F({sqrt_:function vS(n){const e={x:N(n,"x","sqrt","float32")};return R.runKernel(Ho,e)}}),pt=F({square_:function CS(n){const t=N(n,"x","square");return R.runKernel("Square",{x:t},{})}}),je=F({zerosLike_:function SS(n){const e={x:N(n,"x","zerosLike")};return R.runKernel(jl,e)}});function Os(n){return R.customGrad(n)}function Re(n,t){if((jn(n)&&"string"!==t||Array.isArray(n))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&jn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return au(n,[],[],t)}const TS=new Map,ph=new Map;class Sa{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class qn{constructor(){this.classNameMap={}}static getMap(){return null==qn.instance&&(qn.instance=new qn),qn.instance}static register(t){qn.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function ee(n,t,e){I(null!=n.className,()=>"Class being registered does not have the static className property defined."),I("string"==typeof n.className,()=>"className is required to be a string, but got type "+typeof n.className),I(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===e&&(e=n.className);const r=t+">"+e;return qn.register(n),TS.set(r,n),ph.set(n,r),n}class ar extends Sa{minimize(t,e=!1,s){const{value:r,grads:a}=this.computeGradients(t,s);if(null!=s){const o=s.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return Ue(a),e?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return function IS(n,t){I(Wc(n),()=>"The f passed in variableGrads(f) must be a function"),I(null==t||Array.isArray(t)&&t.every(u=>u instanceof Ql),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=null!=t;if(!e){t=[];for(const u in R.registeredVariables)t.push(R.registeredVariables[u])}const s=e?t.filter(u=>!u.trainable):null,r=t.length;I((t=t.filter(u=>u.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const{value:o,grads:i}=R.gradients(n,t,null,!0);I(i.some(u=>null!=u),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),I(0===o.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const l={};return t.forEach((u,c)=>{null!=i[c]&&(l[u.name]=i[c])}),null!=s&&s.forEach(u=>l[u.name]=null),{value:o,grads:l}}(t,e)}dispose(){null!=this.iterations_&&Ue(this.iterations_)}saveIterations(){var t=this;return Z(function*(){return null==t.iterations_&&(t.iterations_=0),{name:"iter",tensor:Re(t.iterations_,"int32")}})()}getWeights(){return Z(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(t){var e=this;return Z(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${e.getClassName()}`)})()}extractIterations(t){var e=this;return Z(function*(){return e.iterations_=(yield t[0].tensor.data())[0],t.slice(1)})()}}Object.defineProperty(ar,Symbol.hasInstance,{value:n=>null!=n.minimize&&null!=n.computeGradients&&null!=n.applyGradients});class yg extends ar{static get className(){return"Adadelta"}constructor(t,e,s=null){super(),this.learningRate=t,this.rho=e,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==s&&(this.epsilon=R.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=R.registeredVariables[s];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:L(()=>je(a).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:L(()=>je(a).variable(!1))});const i=Array.isArray(t)?t[r].tensor:t[s];if(null==i)return;const l=this.accumulatedGrads[r].variable,u=this.accumulatedUpdates[r].variable;L(()=>{const c=te(A(l,this.rho),A(pt(i),1-this.rho)),d=A(Se(cn(te(u,this.epsilon)),cn(te(l,this.epsilon))),i),h=te(A(u,this.rho),A(pt(d),1-this.rho));l.assign(c),u.assign(h);const p=te(A(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Ue(this.accumulatedGrads.map(t=>t.variable)),Ue(this.accumulatedUpdates.map(t=>t.variable)))}getWeights(){var t=this;return Z(function*(){const e=[...t.accumulatedGrads,...t.accumulatedUpdates];return[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return Z(function*(){const s=(t=yield e.extractIterations(t)).length/2;e.accumulatedGrads=t.slice(0,s).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),e.accumulatedUpdates=t.slice(s,2*s).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}function si(n,t,e){return Fs(n),e=e||pa(t),R.runKernel(gd,{},{shape:n,value:t,dtype:e})}class xg extends ar{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=R.registeredVariables[s];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:L(()=>si(a.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[r].tensor:t[s];if(null==o)return;const i=this.accumulatedGrads[r].variable;L(()=>{const l=te(i,pt(o));i.assign(l);const u=te(A(Se(o,cn(te(l,R.backend.epsilon()))),-this.learningRate),a);a.assign(u)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Ue(this.accumulatedGrads.map(t=>t.variable))}getWeights(){var t=this;return Z(function*(){return[yield t.saveIterations()].concat(t.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return Z(function*(){t=yield e.extractIterations(t),e.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}const Vr=F({pow_:function NS(n,t){let e=N(n,"base","pow"),s=N(t,"exp","pow");return[e,s]=Nt(e,s),R.runKernel(Ro,{a:e,b:s})}}),ye=F({sub_:function kS(n,t){let e=N(n,"a","sub"),s=N(t,"b","sub");return[e,s]=Nt(e,s),R.runKernel(qo,{a:e,b:s})}});class bg extends ar{static get className(){return"Adam"}constructor(t,e,s,r=null){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],L(()=>{this.accBeta1=Re(e).variable(),this.accBeta2=Re(s).variable()}),null==r&&(this.epsilon=R.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);L(()=>{const s=ye(1,this.accBeta1),r=ye(1,this.accBeta2);e.forEach((a,o)=>{const i=R.registeredVariables[a];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:L(()=>je(i).variable(!1))}),null==this.accumulatedSecondMoment[o]&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:L(()=>je(i).variable(!1))});const u=Array.isArray(t)?t[o].tensor:t[a];if(null==u)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,h=te(A(c,this.beta1),A(u,1-this.beta1)),p=te(A(d,this.beta2),A(pt(u),1-this.beta2)),f=Se(h,s),g=Se(p,r);c.assign(h),d.assign(p);const m=te(A(Se(f,te(cn(g),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(A(this.accBeta1,this.beta1)),this.accBeta2.assign(A(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Ue(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedSecondMoment&&Ue(this.accumulatedSecondMoment.map(t=>t.variable))}getWeights(){var t=this;return Z(function*(){const e=[...t.accumulatedFirstMoment,...t.accumulatedSecondMoment];return[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return Z(function*(){t=yield e.extractIterations(t),L(()=>{e.accBeta1.assign(Vr(e.beta1,e.iterations_+1)),e.accBeta2.assign(Vr(e.beta2,e.iterations_+1))});const s=t.length/2;e.accumulatedFirstMoment=t.slice(0,s).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)})),e.accumulatedSecondMoment=t.slice(s,2*s).map(a=>({originalName:a.name,variable:a.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}const qt=F({abs_:function _S(n){const t=N(n,"x","abs");return R.runKernel("complex64"===t.dtype?Qi:ji,{x:t})}});function Ia(n,t){const e=n.length,s=[];for(let r=0;r<e;r++){const a=e-1-r,o=n[a]||1;(t[t.length-1-r]||1)>1&&1===o&&s.unshift(a)}return s}function zt(n,t){const e=[];for(let s=0;s<t.length;s++){const r=n[n.length-s-1],a=t.length-s-1,o=t[a];(null==r||1===r&&o>1)&&e.unshift(a)}return e}function Oe(n,t){const e=Math.max(n.length,t.length),s=new Array(e);for(let r=0;r<e;r++){let a=n[n.length-r-1];null==a&&(a=1);let o=t[t.length-r-1];if(null==o&&(o=1),1===a)s[e-r-1]=o;else if(1===o)s[e-r-1]=a;else{if(a!==o)throw Error(`Operands could not be broadcast together with shapes ${n} and ${t}.`);s[e-r-1]=a}}return s}const or=F({maximum_:function $S(n,t){let e=N(n,"a","maximum"),s=N(t,"b","maximum");return[e,s]=Nt(e,s),"bool"===e.dtype&&(e=de(e,"int32"),s=de(s,"int32")),Oe(e.shape,s.shape),R.runKernel($o,{a:e,b:s})}});class wg extends ar{static get className(){return"Adamax"}constructor(t,e,s,r=null,a=0){super(),this.learningRate=t,this.beta1=e,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],L(()=>{this.iteration=Re(0).variable(),this.accBeta1=Re(e).variable()}),null==r&&(this.epsilon=R.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);L(()=>{const s=ye(1,this.accBeta1),r=Se(-this.learningRate,te(A(this.iteration,this.decay),1));e.forEach((a,o)=>{const i=R.registeredVariables[a];null==this.accumulatedFirstMoment[o]&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:je(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[o]&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:je(i).variable(!1)});const u=Array.isArray(t)?t[o].tensor:t[a];if(null==u)return;const c=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,h=te(A(c,this.beta1),A(u,1-this.beta1)),p=A(d,this.beta2),f=qt(u),g=or(p,f);c.assign(h),d.assign(g);const m=te(A(Se(r,s),Se(h,te(g,this.epsilon))),i);i.assign(m)}),this.iteration.assign(te(this.iteration,1)),this.accBeta1.assign(A(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Ue(this.accumulatedFirstMoment.map(t=>t.variable)),null!=this.accumulatedWeightedInfNorm&&Ue(this.accumulatedWeightedInfNorm.map(t=>t.variable))}getWeights(){return Z(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(t){return Z(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class fh extends ar{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=Array.isArray(t)?t[r].tensor:t[s];if(null==a)return;const o=R.registeredVariables[s];L(()=>{const i=te(A(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,null!=this.c&&this.c.dispose(),this.c=bs(Re(-t))}dispose(){this.c.dispose()}getWeights(){var t=this;return Z(function*(){return[yield t.saveIterations()]})()}setWeights(t){var e=this;return Z(function*(){if(0!==(t=yield e.extractIterations(t)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class vg extends fh{static get className(){return"Momentum"}constructor(t,e,s=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=s,this.accumulations=[],this.m=Re(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=R.registeredVariables[s];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:L(()=>je(a).variable(!1))});const o=this.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[s];null!=i&&L(()=>{let l;const u=te(A(this.m,o),i);l=te(A(this.c,this.useNesterov?te(i,A(u,this.m)):u),a),o.assign(u),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Ue(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}getWeights(){var t=this;return Z(function*(){return[yield t.saveIterations()].concat(t.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))})()}setWeights(t){var e=this;return Z(function*(){t=yield e.extractIterations(t),e.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class Cg extends ar{static get className(){return"RMSProp"}constructor(t,e=.9,s=0,r=null,a=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==r&&(this.epsilon=R.backend.epsilon()),null==t)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const a=R.registeredVariables[s],o=!1;null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:L(()=>je(a).variable(o))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:L(()=>je(a).variable(o))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:L(()=>je(a).variable(o))});const i=Array.isArray(t)?t[r].tensor:t[s];if(null==i)return;const l=this.accumulatedMeanSquares[r].variable,u=this.accumulatedMoments[r].variable;L(()=>{const c=te(A(l,this.decay),A(pt(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,h=te(A(d,this.decay),A(i,1-this.decay)),p=Se(A(i,this.learningRate),cn(ye(c,te(pt(h),this.epsilon)))),f=te(A(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const g=ye(a,f);a.assign(g)}else{const d=te(A(l,this.decay),A(pt(i),1-this.decay)),h=te(A(u,this.momentum),Se(A(i,this.learningRate),cn(te(d,this.epsilon))));l.assign(d),u.assign(h);const p=ye(a,h);a.assign(p)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Ue(this.accumulatedMeanSquares.map(t=>t.variable)),null!=this.accumulatedMeanGrads&&this.centered&&Ue(this.accumulatedMeanGrads.map(t=>t.variable)),null!=this.accumulatedMoments&&Ue(this.accumulatedMoments.map(t=>t.variable))}getWeights(){var t=this;return Z(function*(){const e=[...t.accumulatedMeanSquares,...t.accumulatedMoments];return t.centered&&e.push(...t.accumulatedMeanGrads),[yield t.saveIterations()].concat(e.map(s=>({name:s.originalName,tensor:s.variable})))})()}setWeights(t){var e=this;return Z(function*(){t=yield e.extractIterations(t);const s=e.centered?t.length/3:t.length/2,r=!1;e.accumulatedMeanSquares=t.slice(0,s).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),e.accumulatedMoments=t.slice(s,2*s).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),e.centered&&(e.accumulatedMeanGrads=t.slice(2*s,3*s).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const ES=[yg,xg,bg,wg,vg,Cg,fh];function Sg(n){return new Promise(t=>setTimeout(t)).then(n)}let mh=(()=>{class n{constructor(e){if(!V().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(n.URL_SCHEME)&&(e=e.slice(n.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}save(e){var s=this;return Z(function*(){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const r=ys.join(e.weightData),a=window.URL.createObjectURL(new Blob([r],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=og(e,[{paths:["./"+s.weightDataFileName],weights:e.weightSpecs}]),l=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),u=null==s.modelJsonAnchor?document.createElement("a"):s.modelJsonAnchor;if(u.download=s.modelJsonFileName,u.href=l,yield Sg(()=>u.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const c=null==s.weightDataAnchor?document.createElement("a"):s.weightDataAnchor;c.download=s.weightDataFileName,c.href=a,yield Sg(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ou(e)}}})()}}return n.URL_SCHEME="downloads://",n})();function Ig(n,t,e,s){(function o(l){I(null!=l&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")})(n),function i(l,u){I(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),I(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}(e=null==e?0:e,s=null==s?1:s);let r=0;return Promise.all(n.map(l=>(l.then(u=>{const c=e+ ++r/n.length*(s-e);return t(c),u}),l)))}function Tg(n,t){return gh.apply(this,arguments)}function gh(){return(gh=Z(function*(n,t){null==t&&(t={});const e=null==t.fetchFunc?V().platform.fetch:t.fetchFunc,s=n.map(d=>e(d,t.requestInit,{isBinary:!0})),i=(null==t.onProgress?yield Promise.all(s):yield Ig(s,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return null==t.onProgress?yield Promise.all(i):yield Ig(i,t.onProgress,.5,1)})).apply(this,arguments)}Ct.registerSaveRouter(n=>V().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(mh.URL_SCHEME)?function LS(n="model"){return new mh(n)}(n.slice(mh.URL_SCHEME.length)):null);let Ng=(()=>{class n{constructor(e,s){if(this.DEFAULT_METHOD="POST",null==s&&(s={}),this.weightPathPrefix=s.weightPathPrefix,this.weightUrlConverter=s.weightUrlConverter,null!=s.fetchFunc?(I("function"==typeof s.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=s.fetchFunc):this.fetch=V().platform.fetch,I(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=s.requestInit&&null!=s.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=s.requestInit||{},this.loadOptions=s}save(e){var s=this;return Z(function*(){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const r=Object.assign({method:s.DEFAULT_METHOD},s.requestInit);r.body=new FormData;const o=og(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(r.body.append("model.json",new Blob([JSON.stringify(o)],{type:"application/json"}),"model.json"),null!=e.weightData){const l=ys.join(e.weightData);r.body.append("model.weights.bin",new Blob([l],{type:"application/octet-stream"}),"model.weights.bin")}const i=yield s.fetch(s.path,r);if(i.ok)return{modelArtifactsInfo:ou(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)})()}loadModelJSON(){var e=this;return Z(function*(){const s=yield e.fetch(e.path,e.requestInit);if(!s.ok)throw new Error(`Request to ${e.path} failed with status code ${s.status}. Please verify this URL points to the model JSON of the model to load.`);let r;try{r=yield s.json()}catch(i){let l=`Failed to parse model JSON of response from ${e.path}.`;throw e.path.endsWith(".pb")?l+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":l+=" Please make sure the server is serving valid JSON for this request.",new Error(l)}if(null==r.modelTopology&&null==r.weightsManifest)throw new Error(`The JSON from HTTP path ${e.path} contains neither model topology or manifest for weights.`);return r})()}load(){var e=this;return Z(function*(){return e.loadOptions.streamWeights?e.loadStream():function ig(n,t){return sh.apply(this,arguments)}(yield e.loadModelJSON(),r=>e.loadWeights(r))})()}loadStream(){var e=this;return Z(function*(){const s=yield e.loadModelJSON(),r=yield e.getWeightUrls(s.weightsManifest),a=lg(s.weightsManifest);return Object.assign(Object.assign({},s),{weightSpecs:a,getWeightStream:()=>function MS(n,t){var e;const s=null==t.fetchFunc?V().platform.fetch:t.fetchFunc;let a,r=0;return null===(e=t.onProgress)||void 0===e||e.call(t,0),new ReadableStream({pull:(o=Z(function*(i){for(var l;r<n.length;){a||(a=(yield s(n[r],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:c}=yield a.read();if(!u)return void i.enqueue(c);r++,a=void 0,null===(l=t.onProgress)||void 0===l||l.call(t,r/n.length)}i.close()}),function(l){return o.apply(this,arguments)})});var o}(r,e.loadOptions)})})()}getWeightUrls(e){var s=this;return Z(function*(){const r=Array.isArray(s.path)?s.path[1]:s.path,[a,o]=function WS(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?");return[n.substring(0,t)+"/",e>t?n.substring(e):""]}(r),i=s.weightPathPrefix||a,l=[],u=[];for(const c of e)for(const d of c.paths)null!=s.weightUrlConverter?u.push(s.weightUrlConverter(d)):l.push(i+d+o);return s.weightUrlConverter&&l.push(...yield Promise.all(u)),l})()}loadWeights(e){var s=this;return Z(function*(){const r=yield s.getWeightUrls(e);return[lg(e),yield Tg(r,s.loadOptions)]})()}}return n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function kg(n){return null!=n.match(Ng.URL_SCHEME_REGEX)}const _g=(n,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let e=!0;if(e=Array.isArray(n)?n.every(s=>kg(s)):kg(n),e)return function $g(n,t){return new Ng(n,t)}(n,t)}return null};function wh(n,t,e){const s=n.shape.length;I(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`),I(s===e.length,()=>`Error in slice${s}D: Length of size ${e} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)I(t[r]+e[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+e[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function jS(n){const t=[];let e=0;for(;n>0;)1&n&&t.push(e),n/=2,e++;return t}function vh(n,t,e){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((t[r]-n[r])/e[r]);return s}function Ag(n,t,e,s){const r=[...n];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<e;a++)0===a?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Dg(n,t,e){return e<=n?e:e-(t-1)}function Rg(n,t){const e=[];for(let s=0;s<n;s++)e.push(t+s);return e}function qS(n,t,e,s,r,a,o,i,l){const u=n.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&e>0){const p=t[0],f=e+1;c=Fg(o,p,f,s,n),d=Og(i,p,f,r,n),h=Ag(a,p,f,n)}else for(let p=0;p<u;p++)c[p]=Lg(o,s,a,n,p,l),d[p]=Mg(i,r,a,n,p,l),h[p]=Pg(a,p,l);return{begin:c,end:d,strides:h}}function Fg(n,t,e,s,r){const a=[...r],o=Rg(e,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const l=Dg(t,e,i);let u=s[l];n&1<<l&&(u=0),a[i]=u}return a}function Og(n,t,e,s,r){const a=[...r],o=Rg(e,t);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const l=Dg(t,e,i);let u=s[l];n&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[i]=u}for(let i=0;i<a.length;i++){const l=r[i];a[i]<0&&(a[i]+=l),a[i]=$r(0,a[i],r[i])}return a}function Pg(n,t,e){let s=n[t];return(e&1<<t||null==s)&&(s=1),s}function Lg(n,t,e,s,r,a){let o=t[r];(n&1<<r||a&1<<r||null==o)&&(o=(e[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=$r(0,o,l-1),o}function Mg(n,t,e,s,r,a){let o=t[r];const i=e[r]||1;(n&1<<r||a&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=i>0?$r(0,o,l):$r(-1,o,l-1),o}function Ch(n,t,e){let s=e.length;for(let r=0;r<e.length;r++)if(e[r]>1){s=r;break}for(let r=s+1;r<e.length;r++)if(t[r]>0||e[r]!==n[r])return!1;return!0}function Sh(n,t){let e=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)e+=n[s]*t[s];return e}function cu(n,t,e){let s;const r=n.shape.length;let a;return s="number"==typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),s.forEach(o=>{I(-1!==o,()=>"slice() does not support negative begin indexing.")}),a=null==e?new Array(r).fill(-1):"number"==typeof e?[e,...new Array(r-1).fill(-1)]:e.length<r?e.concat(new Array(r-e.length).fill(-1)):e,a=a.map((o,i)=>o>=0?o:(I(-1===o,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),n.shape[i]-s[i])),[s,a]}function Ih(n,t,e,s,r,a,o,i,l){let u;if(null==s?(u=new Array(t.length),u.fill(1)):u=s,null!=o&&0!=(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:u.slice(),beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&0!=(1<<b&i)&&d.numAddAxisAfterEllipsis++,1<<b&o&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function KS(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=null!=n.begin,t.endValid=null!=n.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(t.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<r;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=s}else if(1<<s&n.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=n.begin&&(t.begin[e]=n.begin[s]),null!=n.end&&(t.end[e]=n.end[s]),t.strides[e]=n.strides[s],n.beginMask&1<<s&&(t.beginMask|=1<<e),n.endMask&1<<s&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[e]=s,e++}}(d,h);let p=!0,f=!0,g=!0;const m=[],y=[];for(let b=0;b<n.length;++b){if(0===h.strides[b])throw Error(`strides[${b}] must be non-zero`);const w=!!(h.shrinkAxisMask&1<<b),C=n[b];if(-1===C){m.push(w?1:-1);continue}const S=[h.beginMask&1<<b,h.endMask&1<<b],T=[h.strides[b]>0?0:-1,h.strides[b]>0?C:C-1];if(w&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===h.strides[b];const k=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(w){const z=h.begin[b]<0?C+h.begin[b]:h.begin[b];if(h.begin[b]=z,h.end[b]=h.begin[b]+1,z<0||z>=C)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=Vg(h.begin[b],0,h.strides[b],C,S,T),h.end[b]=Vg(h.end[b],1,h.strides[b],C,S,T);const P=1===h.strides[b]&&0===h.begin[b]&&h.end[b]===C;p=p&&P,f=f&&(0===b&&1===h.strides[b]||P)}else p=p&&1===h.strides[b]&&k,f=f&&(0===b&&1===h.strides[b]||k);let $,E=!1;if(h.beginValid&&h.endValid?($=h.end[b]-h.begin[b],E=!0):w?($=1,E=!0):k&&C>=0&&($=h.strides[b]<0?-C:C,E=!0),E){let P;P=0===$||$<0!=h.strides[b]<0?0:Math.trunc($/h.strides[b])+($%h.strides[b]!=0?1:0),m.push(P)}else m.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){const w=h.finalShapeGatherIndices[b];w>=0?y.push(m[w]):-2===w&&y.push(1)}return{finalShapeSparse:y.filter((b,w)=>-2!==h.finalShapeGatherIndices[w]),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function Vg(n,t,e,s,r,a){if(r[t])return e>0?a[t]:a[t+1&1];{const o=n<0?s+n:n;return o<a[0]?a[0]:o>a[1]?a[1]:o}}Ct.registerSaveRouter(_g),Ct.registerLoadRouter(_g);const zg=F({all_:function ZS(n,t=null,e=!1){const r={x:N(n,"x","all","bool")};return R.runKernel("All",r,{axis:t,keepDims:e})}}),Th=F({any_:function YS(n,t=null,e=!1){const r={x:N(n,"x","any","bool")};return R.runKernel("Any",r,{axis:t,keepDims:e})}}),ri=F({argMax_:function JS(n,t=0){const s={x:N(n,"x","argMax")};return R.runKernel(qi,s,{axis:t})}});function ai(n,t,e,s,r="NHWC",a){return Kt(n,[...t,n[3]],e,a,s,null,null,Ls(r))}function Kn(n,t,e,s,r,a,o="channelsLast"){const[i,l]=oi(t);let u;if("channelsLast"===o)u=[i,l,n[3],n[3]];else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);u=[i,l,n[1],n[1]]}return Kt(n,u,e,s,r,a,!1,o)}function Ps(n,t,e,s,r,a,o="NDHWC"){const[i,l,u]=kh(t);let c,d;if("NDHWC"===o)d="channelsLast",c=[i,l,u,n[4],n[4]];else{if("NCDHW"!==o)throw new Error(`Unknown dataFormat ${o}`);d="channelsFirst",c=[i,l,u,n[1],n[1]]}return ir(n,c,e,s,r,!1,d,a)}function Kt(n,t,e,s,r,a,o=!1,i="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d]=n;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,d,u,c]=n}const[h,p,,f]=t,[g,m]=oi(e),[y,x]=oi(s),b=Ta(h,y),w=Ta(p,x),{padInfo:C,outHeight:S,outWidth:T}=function tI(n,t,e,s,r,a,o,i,l){let u,c,d;if("number"==typeof n){u={top:n,bottom:n,left:n,right:n,type:0===n?"VALID":"NUMBER"};const p=function QS(n,t,e,s,r){null==s&&(s=Nh(n,t,e));const o=n[1];return[ii((n[0]-t+2*s)/e+1,r),ii((o-t+2*s)/e+1,r)]}([t,e],a,s,n,i);c=p[0],d=p[1]}else if("same"===n){c=Math.ceil(t/s),d=Math.ceil(e/r);const h=Math.max(0,(c-1)*s+a-t),p=Math.max(0,(d-1)*r+o-e),f=Math.floor(h/2),g=h-f,m=Math.floor(p/2);u={top:f,bottom:g,left:m,right:p-m,type:"SAME"}}else if("valid"===n)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/s),d=Math.ceil((e-o+1)/r);else{if("object"!=typeof n)throw Error(`Unknown padding parameter: ${n}`);{const h="channelsLast"===l?n[1][0]:n[2][0],p="channelsLast"===l?n[1][1]:n[2][1],f="channelsLast"===l?n[2][0]:n[3][0],g="channelsLast"===l?n[2][1]:n[3][1];u={top:h,bottom:p,left:f,right:g,type:0===h&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=ii((t-a+h+p)/s+1,i),d=ii((e-o+f+g)/r+1,i)}}return{padInfo:u,outHeight:c,outWidth:d}}(r,u,c,g,m,b,w,a,i),k=o?f*d:f;let $;return"channelsFirst"===i?$=[l,k,S,T]:"channelsLast"===i&&($=[l,S,T,k]),{batchSize:l,dataFormat:i,inHeight:u,inWidth:c,inChannels:d,outHeight:S,outWidth:T,outChannels:k,padInfo:C,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:x,inShape:n,outShape:$,filterShape:t}}function ir(n,t,e,s,r,a=!1,o="channelsLast",i){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d,h]=n;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c,d]=n}const[p,f,g,,m]=t,[y,x,b]=kh(e),[w,C,S]=kh(s),T=Ta(p,w),k=Ta(f,C),$=Ta(g,S),{padInfo:E,outDepth:P,outHeight:z,outWidth:B}=function nI(n,t,e,s,r,a,o,i,l,u,c){let d,h,p,f;if("valid"===n&&(n=0),"number"==typeof n){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:0===n?"VALID":"NUMBER"};const m=function eI(n,t,e,s,r,a){null==r&&(r=Nh(n,t[0],s[0]));const o=[0,0,0,e];for(let i=0;i<3;i++)n[i]+2*r>=t[i]&&(o[i]=ii((n[i]-t[i]+2*r)/s[i]+1,a));return o}([t,e,s,1],[i,l,u],1,[r,a,o],n,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==n)throw Error(`Unknown padding parameter: ${n}`);{h=Math.ceil(t/r),p=Math.ceil(e/a),f=Math.ceil(s/o);const g=(h-1)*r+i-t,m=(p-1)*a+l-e,y=(f-1)*o+u-s,x=Math.floor(g/2),b=g-x,w=Math.floor(m/2),C=m-w,S=Math.floor(y/2);d={top:w,bottom:C,left:S,right:y-S,front:x,back:b,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(r,u,c,d,y,x,b,T,k,$,i),U=a?m*h:m;let G;return"channelsFirst"===o?G=[l,U,P,z,B]:"channelsLast"===o&&(G=[l,P,z,B,U]),{batchSize:l,dataFormat:o,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:P,outHeight:z,outWidth:B,outChannels:U,padInfo:E,strideDepth:y,strideHeight:x,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:T,effectiveFilterHeight:k,effectiveFilterWidth:$,dilationDepth:w,dilationHeight:C,dilationWidth:S,inShape:n,outShape:G,filterShape:t}}function Nh(n,t,e,s=1){const r=Ta(t,s);return Math.floor((n[0]*(e-1)-e+r)/2)}function oi(n){return"number"==typeof n?[n,n,n]:2===n.length?[n[0],n[1],1]:n}function kh(n){return"number"==typeof n?[n,n,n]:n}function Ta(n,t){return t<=1?n:n+(n-1)*(t-1)}function ii(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function lr(n){const[t,e,s]=oi(n);return 1===t&&1===e&&1===s}function nn(n,t){return lr(n)||lr(t)}function zr(n){return oi(n).every(t=>t>0)}function Ls(n){if("NHWC"===n)return"channelsLast";if("NCHW"===n)return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function yn(n,t,e){if(null!=e){if("string"==typeof t)throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if("number"==typeof t)I(da(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${n}: Unknown padding parameter: ${t}`);t.forEach(s=>{s.forEach(r=>{I(da(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${r}.`)})})}}}const O=F({reshape_:function sI(n,t){const s={x:N(n,"x","reshape","string_or_numeric")};return R.runKernel(Rl,s,{shape:t})}}),_h=F({avgPool_:function rI(n,t,e,s,r){const a=N(n,"x","avgPool","float32");I(nn(e,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`);let i=a,l=!1;3===a.rank&&(l=!0,i=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),yn("avgPool",s,r);let d=R.runKernel(Xi,{x:i},{filterSize:t,strides:e,pad:s,dimRoundingMode:r});return d=de(d,a.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),oI=F({avgPool3d_:function aI(n,t,e,s,r,a="NDHWC"){const o=N(n,"x","avgPool3d","float32");let i=o,l=!1;4===o.rank&&(l=!0,i=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(5===i.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),I("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),I("number"==typeof e&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),yn("avgPool3d",s,r);let d=R.runKernel(Zi,{x:i},{filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:a});return d=de(d,i.dtype),l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});function iI(n){let t;return t=0===n.rank||1===n.rank?O(n,[1,1,1,n.size]):2===n.rank?O(n,[1,1,n.shape[0],n.shape[1]]):3===n.rank?O(n,[1,n.shape[0],n.shape[1],n.shape[2]]):n,t}const du=F({batchNorm_:function lI(n,t,e,s,r,a){null==a&&(a=.001);const o=N(n,"x","batchNorm"),i=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm");let u,c;null!=r&&(u=N(r,"scale","batchNorm")),null!=s&&(c=N(s,"offset","batchNorm")),I(i.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(null==c||i.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(null==u||i.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:iI(o),scale:u,offset:c,mean:i,variance:l},f=R.runKernel(ul,h,{varianceEpsilon:a});return O(f,o.shape)}}),cI=F({batchNorm2d_:function uI(n,t,e,s,r,a){const o=N(n,"x","batchNorm"),i=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm");let u,c;return null!=r&&(u=N(r,"scale","batchNorm")),null!=s&&(c=N(s,"offset","batchNorm")),I(2===o.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),I(2===i.rank||1===i.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),I(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&I(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&I(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),du(o,i,l,c,u,a)}}),hI=F({batchNorm3d_:function dI(n,t,e,s,r,a){const o=N(n,"x","batchNorm"),i=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm");let u,c;return null!=r&&(u=N(r,"scale","batchNorm")),null!=s&&(c=N(s,"offset","batchNorm")),I(3===o.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),I(3===i.rank||1===i.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),I(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&I(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&I(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),du(o,i,l,c,u,a)}}),fI=F({batchNorm4d_:function pI(n,t,e,s,r,a){const o=N(n,"x","batchNorm"),i=N(t,"mean","batchNorm"),l=N(e,"variance","batchNorm");let u,c;return null!=r&&(u=N(r,"scale","batchNorm")),null!=s&&(c=N(s,"offset","batchNorm")),I(4===o.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),I(4===i.rank||1===i.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),I(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&I(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&I(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),du(o,i,l,c,u,a)}}),li=F({broadcastTo_:function mI(n,t){let e=N(n,"broadcastTo","x");const s=e.shape;if(Fs(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const u=e.shape.slice();for(;u.length<t.length;)u.unshift(1);e=O(e,u)}const r=e.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(r[u]===t[u])a[u]=1;else if(1!==e.shape[u])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);return 0===a.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length?Mr(e):R.runKernel(Zo,{x:e},{reps:a})}}),Pn=F({clipByValue_:function gI(n,t,e){const s=N(n,"x","clipByValue");return I(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e?si(s.shape,t,s.dtype):R.runKernel(ho,{x:s},{clipValueMin:t,clipValueMax:e})}}),dn=F({concat_:function yI(n,t=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const e=Jm(n,"tensors","concat","string_or_numeric");return"complex64"===e[0].dtype&&e.forEach(a=>{if("complex64"!==a.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${a.dtype}. `)}),1===e.length?Mr(e[0]):R.runKernel(el,e,{axis:t})}}),bI=F({concat1d_:function xI(n){return dn(n,0)}}),vI=F({concat2d_:function wI(n,t){return dn(n,t)}}),SI=F({concat3d_:function CI(n,t){return dn(n,t)}}),TI=F({concat4d_:function II(n,t){return dn(n,t)}}),Br=F({conv2d_:function NI(n,t,e,s,r="NHWC",a=[1,1],o){const i=N(n,"x","conv2d","float32"),l=N(t,"filter","conv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),I(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),yn("conv2d",s,o);const d="NHWC"===r?u.shape[3]:u.shape[1];I(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),I(nn(e,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),I(zr(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),I(zr(e),()=>"Error in conv2D: Strides should be larger than 0.");const f=R.runKernel(tl,{x:u,filter:l},{strides:e,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o});return c?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Bg=F({conv1d_:function kI(n,t,e,s,r="NWC",a=1,o){const i=N(n,"x","conv1d"),l=N(t,"filter","conv1d");let u=i,c=!1;2===i.rank&&(c=!0,u=O(i,[1,i.shape[0],i.shape[1]])),I(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),I(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),yn("conv1d",s,o),I(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),I(nn(e,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${a}'`),I(zr(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),I(zr(e),()=>"Error in conv1D: Stride should be larger than 0."),I("NWC"===r,()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=O(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=O(u,[u.shape[0],1,u.shape[1],u.shape[2]]),m=Br(h,d,[1,e],s,"NHWC",[1,a],o);return O(m,c?[m.shape[2],m.shape[3]]:[m.shape[0],m.shape[2],m.shape[3]])}}),$h=F({conv2DBackpropInput_:function _I(n,t,e,s,r,a="NHWC",o){I(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,l=t,u=!1;3===t.rank&&(u=!0,l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,n[0],n[1],n[2]]),I(4===i.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),I(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),I(4===e.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const c="NHWC"===a?i[3]:i[1],d="NHWC"===a?l.shape[3]:l.shape[1];I(c===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${e.shape[2]}.`),I(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),yn("conv2dDerInput",r,o);const f=R.runKernel(nl,{dy:l,filter:e},{strides:s,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i});return u?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Wg=F({conv2dTranspose_:function $I(n,t,e,s,r,a){const o=N(n,"x","conv2dTranspose"),i=N(t,"filter","conv2dTranspose");return $h(e,o,i,s,r,"NHWC",a)}}),AI=F({conv3d_:function EI(n,t,e,s,r="NDHWC",a=[1,1,1]){const o=N(n,"x","conv3d"),i=N(t,"filter","conv3d");let l=o,u=!1;4===o.rank&&(u=!0,l=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),I(5===i.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),I(l.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${i.shape[3]}.`),I(nn(e,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),I("NDHWC"===r,()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),I(zr(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),I(zr(e),()=>"Error in conv3D: Strides should be larger than 0.");const h=R.runKernel(sl,{x:l,filter:i},{strides:e,pad:s,dataFormat:r,dilations:a});return u?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),Ug=F({conv3DBackpropInput_:function DI(n,t,e,s,r){I(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let a=n,o=t,i=!1;4===t.rank&&(i=!0,o=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const l=a[4],u=o.shape[4];I(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),I(5===o.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),I(5===e.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),I(l===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[3]}.`),I(u===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${e.shape[4]}.`);const h=R.runKernel(rd,{dy:o,filter:e},{pad:r,strides:s,inputShape:a});return i?O(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),FI=F({conv3dTranspose_:function RI(n,t,e,s,r){const a=N(n,"x","conv3dTranspose"),o=N(t,"filter","conv3dTranspose");return Ug(e,a,o,s,r)}}),Gg=F({denseBincount_:function OI(n,t,e,s=!1){const r=N(n,"x","denseBincount"),a=N(t,"weights","denseBincount");return I("int32"===r.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),I(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),I(e>=0,()=>`size must be non-negative, but got ${e}.`),I(a.size===r.size||0===a.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`),R.runKernel(id,{x:r,weights:a},{size:e,binaryOutput:s})}}),hu=F({depthwiseConv2d_:function PI(n,t,e,s,r="NHWC",a=[1,1],o){const i=N(n,"x","depthwiseConv2d","float32"),l=N(t,"filter","depthwiseConv2d","float32");let u=i,c=!1;3===i.rank&&(c=!0,u=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),I(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===r?u.shape[3]:u.shape[1];I(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),yn("depthwiseConv2d",s,o);const f=R.runKernel(al,{x:u,filter:l},{strides:e,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o});return c?O(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),pu=F({elu_:function LI(n){const e={x:N(n,"x","elu","float32")};return R.runKernel(go,e)}}),vs=F({equal_:function MI(n,t){let e=N(n,"a","equal","string_or_numeric"),s=N(t,"b","equal","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(il,{a:e,b:s})}}),Hg=F({erf_:function VI(n){let t=N(n,"x","erf");return I("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=de(t,"float32")),R.runKernel(yo,{x:t})}}),Ln=F({exp_:function zI(n){const e={x:N(n,"x","exp")};return R.runKernel(xo,e)}}),Nn=F({expandDims_:function BI(n,t=0){const e=N(n,"x","expandDims","string_or_numeric");return I(t<=e.rank,()=>"Axis must be <= rank of the tensor"),R.runKernel(ll,{input:e},{dim:t})}}),as=F({tile_:function WI(n,t){const e=N(n,"x","tile","string_or_numeric");return I(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`),R.runKernel(Zo,{x:e},{reps:t})}}),jg=F({eye_:function UI(n,t,e,s="float32"){null==t&&(t=n);const r=Be([n,t],s),a=n<=t?n:t;for(let i=0;i<a;++i)r.set(1,i,i);const o=O(r.toTensor(),[n,t]);if(null==e)return o;if(1===e.length)return as(Nn(o,0),[e[0],1,1]);if(2===e.length)return as(Nn(Nn(o,0),0),[e[0],e[1],1,1]);if(3===e.length)return as(Nn(Nn(Nn(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}}),fu=F({floor_:function GI(n){const e={x:N(n,"x","floor","float32")};return R.runKernel(wo,e)}}),Eh=F({gather_:function HI(n,t,e=0,s=0){const r=N(n,"x","gather"),a=N(t,"indices","gather","int32");return R.runKernel(cl,{x:r,indices:a},{axis:e,batchDims:s})}}),Mn=F({greater_:function jI(n,t){let e=N(n,"a","greater","string_or_numeric"),s=N(t,"b","greater","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(dl,{a:e,b:s})}}),Wr=F({greaterEqual_:function qI(n,t){let e=N(n,"a","greaterEqual","string_or_numeric"),s=N(t,"b","greaterEqual","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(Co,{a:e,b:s})}}),Ah=F({leakyRelu_:function KI(n,t=.2){const s={x:N(n,"x","leakyRelu")};return R.runKernel(hl,s,{alpha:t})}}),Xn=F({log_:function XI(n){const e={x:N(n,"x","log","float32")};return R.runKernel(ko,e)}}),Dh=F({log1p_:function ZI(n){const e={x:N(n,"x","log1p")};return R.runKernel(_o,e)}}),os=F({max_:function YI(n,t=null,e=!1){const r={x:N(n,"x","max")};return R.runKernel(bl,r,{reductionIndices:t,keepDims:e})}}),ve=F({sum_:function JI(n,t=null,e=!1){let s=N(n,"x","sum");return"bool"===s.dtype&&(s=de(s,"int32")),R.runKernel(Vl,{x:s},{axis:t,keepDims:e})}}),qg=F({logSoftmax_:function QI(n,t=-1){const e=N(n,"logits","logSoftmax");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Os((r,a)=>{const i=os(r,t,!0),l=ye(r,i),u=ye(de(l,"float32"),Xn(ve(Ln(l),t,!0)));return a([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,g=Ln(p);return ye(d,A(ve(d,t,!0),g))}}})(e)}});function Rh(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function Kg(n,t,e){const s=n.length+t.length,r=[];let a=0,o=0;for(let i=0;i<s;i++)-1===e.indexOf(i)?r.push(n[a++]):r.push(t[o++]);return r}function Xt(n,t){const e=[],s=n.length;for(let a=0;a<s;a++)-1===t.indexOf(a)&&e.push(n[a]);return[e,t.map(a=>n[a])]}function Et(n,t){return Kg(n,t.map(s=>1),t)}function sn(n,t,e){I(Rh(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function St(n,t){if(Rh(n,t))return null;const e=[];for(let s=0;s<t;++s)-1===n.indexOf(s)&&e.push(s);return n.forEach(s=>e.push(s)),e}function ur(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function At(n,t){const e=[];for(let s=t-n;s<t;++s)e.push(s);return e}const Fh=F({logSumExp_:function eT(n,t=null,e=!1){const s=N(n,"x","logSumExp"),r=ze(t,s.shape),a=os(s,r,!0),o=ye(s,a),i=Ln(o),l=ve(i,r),u=Xn(l),c=te(O(a,u.shape),u);if(e){const d=Et(c.shape,r);return O(c,d)}return c}}),Ms=F({logicalAnd_:function tT(n,t){const e=N(n,"a","logicalAnd","bool"),s=N(t,"b","logicalAnd","bool");return Oe(e.shape,s.shape),R.runKernel(ml,{a:e,b:s})}}),et=F({matMul_:function nT(n,t,e=!1,s=!1){let r=N(n,"a","matMul"),a=N(t,"b","matMul");return[r,a]=Nt(r,a),R.runKernel(Yi,{a:r,b:a},{transposeA:e,transposeB:s})}}),Oh=F({maxPool_:function sT(n,t,e,s,r){const a=N(n,"x","maxPool");let i=a,l=!1;3===a.rank&&(l=!0,i=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),I(nn(e,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '1'`),yn("maxPool",s,r);const d=R.runKernel(wl,{x:i},{filterSize:t,strides:e,pad:s,dimRoundingMode:r});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),aT=F({maxPool3d_:function rT(n,t=[1,1,1],e,s,r,a="NDHWC"){const o=N(n,"x","maxPool3d");let i=o,l=!1;4===o.rank&&(l=!0,i=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),I(5===i.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),I("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),yn("maxPool3d",s,r);const d=R.runKernel(vl,{x:i},{filterSize:t,strides:e,pad:s,dimRoundingMode:r,dataFormat:a});return l?O(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Dt=F({mean_:function oT(n,t=null,e=!1){const r={x:N(n,"x","mean")};return R.runKernel(Cl,r,{axis:t,keepDims:e})}}),mu=F({min_:function iT(n,t=null,e=!1){const r={x:N(n,"x","min")};return R.runKernel(Sl,r,{axis:t,keepDims:e})}}),Na=F({minimum_:function lT(n,t){let e=N(n,"a","minimum"),s=N(t,"b","minimum");return[e,s]=Nt(e,s),"bool"===e.dtype&&(e=de(e,"int32"),s=de(s,"int32")),Oe(e.shape,s.shape),R.runKernel(Eo,{a:e,b:s})}}),Ph=F({moments_:function uT(n,t=null,e=!1){const s=ze(t,(n=N(n,"x","moments")).shape),r=Dt(n,s,e);let a=r.shape;e||(a=Et(r.shape,s));const o=pt(ye(de(n,"float32"),O(r,a)));return{mean:r,variance:Dt(o,s,e)}}}),xt=F({neg_:function cT(n){const e={x:N(n,"x","neg")};return R.runKernel(Tl,e)}}),ui=F({notEqual_:function dT(n,t){let e=N(n,"a","notEqual","string_or_numeric"),s=N(t,"b","notEqual","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(Nl,{a:e,b:s})}}),Xg=F({oneHot_:function hT(n,t,e=1,s=0,r="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:N(n,"indices","oneHot","int32")};return R.runKernel(_l,o,{dtype:r,depth:t,onValue:e,offValue:s})}});function Zt(n,t="float32"){if(Fs(n),"complex64"===t){const s=Zt(n,"float32"),r=Zt(n,"float32");return Fr(s,r)}const e=un(W(n),t);return R.makeTensor(e,n,t)}function Vs(n,t="float32"){if(Fs(n),"complex64"===t){const s=Vs(n,"float32"),r=Zt(n,"float32");return Fr(s,r)}const e=Gc(W(n),t);return R.makeTensor(e,n,t)}const Zn=F({onesLike_:function pT(n){const e={x:N(n,"x","onesLike")};return R.runKernel(kl,e)}}),Lh=F({pad_:function fT(n,t,e=0){const s=N(n,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return R.runKernel(El,{x:s},{paddings:t,constantValue:e})}}),Mh=F({prelu_:function mT(n,t){const e=N(n,"x","prelu"),s=N(t,"alpha","prelu");return R.runKernel(Al,{x:e,alpha:s})}});var Vh=J(340);class zh{constructor(t,e,s,r,a){this.mean=t,this.stdDev=e,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const o=a||Math.random();this.random=Vh.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let t,e,s=!1;for(;!s;){let r,a,o;do{r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a}while(o>=1||0===o);const i=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*r*i,e=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(t))&&(s=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return null==this.dtype||"float32"===this.dtype?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class gT{constructor(t=0,e=1,s,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=t,this.range=e-t,this.dtype=s,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Vh.alea(r)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const vT=F({randomNormal_:function wT(n,t=0,e=1,s,r){if(Fs(n),null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const a=new zh(t,e,s,!1,r),o=Be(n,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}}),ci=F({randomUniform_:function CT(n,t=0,e=1,s="float32",r){Fs(n);const a=Be(n,s),o=new gT(t,e,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}});function di(n,t,e=1,s="float32"){if(0===e)throw new Error("Cannot have a step of zero");return R.runKernel(Nd,{},{start:n,stop:t,step:e,dtype:s})}const zs=F({relu_:function ST(n){const e={x:N(n,"x","relu")};return R.runKernel(Oo,e)}}),Ur=F({reverse_:function IT(n,t){const s={x:N(n,"x","reverse")};return R.runKernel(Pl,s,{dims:t})}}),Zg=F({selu_:function TT(n){const e={x:N(n,"x","selu")};return R.runKernel(Vo,e)}}),Yg=F({separableConv2d_:function NT(n,t,e,s,r,a=[1,1],o="NHWC"){const i=N(n,"x","separableConv2d"),l=N(t,"depthwiseFilter","separableConv2d"),u=N(e,"pointwiseFilter","separableConv2d");let c=i,d=!1;if(3===i.rank&&(d=!0,c=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),I(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),I(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),I(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),I(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];I(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=hu(c,l,s,r,o,a),m=Br(f,u,1,"valid",o);return d?O(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),ka=F({sigmoid_:function kT(n){const e={x:N(n,"x","sigmoid","float32")};return R.runKernel(Uo,e)}}),it=F({slice_:function _T(n,t,e){const s=N(n,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");return R.runKernel(Ml,{x:s},{begin:t,size:e})}}),Wh=F({slice1d_:function $T(n,t,e){const s=N(n,"x","slice1d");return I(1===s.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),it(s,[t],[e])}}),Jg=F({slice2d_:function ET(n,t,e){const s=N(n,"x","slice2d");return I(2===s.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),it(s,t,e)}}),Uh=F({slice3d_:function AT(n,t,e){const s=N(n,"x","slice3d");return I(3===s.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),it(s,t,e)}}),gu=F({slice4d_:function DT(n,t,e){const s=N(n,"x","slice4d");return I(4===s.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),it(s,t,e)}}),Gh=F({softmax_:function RT(n,t=-1){const e=N(n,"logits","softmax","float32");if(-1===t&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);return R.runKernel(Wl,{logits:e},{dim:t})}}),hi=F({softplus_:function FT(n){const e={x:N(n,"x","softplus")};return R.runKernel(Go,e)}}),Vn=F({split_:function OT(n,t,e=0){const r={x:N(n,"x","split")};return R.runKernel(Bl,r,{numOrSizeSplits:t,axis:e})}}),pi=F({squeeze_:function PT(n,t){const e=N(n,"x","squeeze","string_or_numeric");return O(e,Js(e.shape,t).newShape)}}),Bs=F({stack_:function LT(n,t=0){const e=Jm(n,"tensors","stack","string_or_numeric");return I(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&I(t<=e[0].rank,()=>"Axis must be <= rank of the tensor"),R.runKernel($l,e,{axis:t})}}),yu=F({tanh_:function MT(n){const e={x:N(n,"x","tanh","float32")};return R.runKernel(Xo,e)}});function xn(n,t){cm(n);const e=ru(n,t);if(1!==e.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return au(n,null,e,t)}function _a(n,t,e){if(cm(n),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const s=ru(n,e);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return au(n,t,s,e)}const Qg=F({truncatedNormal_:function VT(n,t=0,e=1,s,r){if(Fs(n),null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const a=new zh(t,e,s,!0,r),o=Be(n,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}}),Gr=F({unstack_:function zT(n,t=0){const e=N(n,"x","unstack","string_or_numeric");return I(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`),R.runKernel(Gl,{value:e},{axis:t})}}),bn=F({where_:function WT(n,t,e){const s=N(t,"a","where"),r=N(e,"b","where"),a=N(n,"condition","where","bool"),o=Oe(Oe(a.shape,s.shape),r.shape),i=li(a,o),l=li(s,o),u=li(r,o);return R.runKernel(Ll,{condition:i,t:l,e:u})}}),Hh=F({imag_:function UT(n){const e={input:N(n,"input","imag")};return R.runKernel(bd,e)}}),xu=F({real_:function GT(n){const e={input:N(n,"input","real")};return R.runKernel(kd,e)}}),qe=F({transpose_:function HT(n,t,e){const s=N(n,"x","transpose");if(null==t&&(t=s.shape.map((o,i)=>i).reverse()),I(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`),t.forEach(o=>{I(o>=0&&o<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)}),s.rank<=1)return s.clone();const r={x:s},a={perm:t};return"complex64"===s.dtype?L(()=>{let o=xu(s),i=Hh(s);return o=R.runKernel(ga,{x:o},a),i=R.runKernel(ga,{x:i},a),e&&(i=xt(i)),Fr(o,i)}):R.runKernel(ga,r,a)}}),KT=F({dropout_:function qT(n,t,e,s){const r=N(n,"x","dropout");if(I("float32"===r.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),I(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return n instanceof Vt?r.clone():r;const a=function jT(n,t){if(null==t)return n.shape.slice();if(Qe(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let s=0;s<n.shape.length;s++)e.push(null==t[s]&&null!=n.shape[s]?n.shape[s]:t[s]);return e}return t}(r,e),o=1-t,i=Se(fu(te(ci(a,0,1,"float32",s),o)),o);return A(r,i)}}),jh=F({fft_:function XT(n){return I("complex64"===n.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`),R.runKernel("FFT",{input:n})}}),qh=F({rfft_:function ZT(n,t){I("float32"===n.dtype,()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const s=n.size/e;let r;if(null!=t&&t<e){const f=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=t,r=it(n,f,g),e=t}else if(null!=t&&t>e){const f=n.shape.map(g=>g);f[n.shape.length-1]=t-e,r=dn([n,Zt(f)],n.shape.length-1),e=t}else r=n;const a=je(r),o=O(Fr(r,a),[s,e]),i=jh(o),l=Math.floor(e/2)+1,u=xu(i),c=Hh(i),d=Vn(u,[l,e-l],u.shape.length-1),h=Vn(c,[l,e-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,O(Fr(d[0],h[0]),p)}}),bu=F({ifft_:function YT(n){return I("complex64"===n.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`),R.runKernel(xd,{input:n})}}),ey=F({irfft_:function JT(n){const t=n.shape[n.shape.length-1],e=n.size/t;let s;if(t<=2){const r=O(n,[e,t]);s=bu(r)}else{const r=[e,2*(t-1)],a=O(xu(n),[e,t]),o=O(Hh(n),[e,t]),i=Ur(it(a,[0,1],[e,t-2]),1),l=A(Ur(it(o,[0,1],[e,t-2]),1),Re(-1)),u=dn([a,i],1),c=dn([o,l],1),d=O(Fr(u,c),[r[0],r[1]]);s=bu(d)}if(s=xu(s),3===n.rank&&0!==n.shape[0]){const r=s,a=n.shape[0];s=O(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}}),Kh=F({conv2DBackpropFilter_:function QT(n,t,e,s,r,a="NHWC",o){let i=n;3===n.rank&&(i=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;3===l.rank&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),I(4===i.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),I(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),I(4===e.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const u="NHWC"===a?i.shape[3]:i.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];return I(u===e[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${e[2]}.`),I(c===e[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${e[3]}).`),yn("conv2dDerFilter",r,o),R.runKernel(nd,{x:i,dy:l},{strides:s,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:e})}}),ty=F({relu6_:function eN(n){const e={x:N(n,"x","relu6")};return R.runKernel(Po,e)}}),fi=F({step_:function tN(n,t=0){const s={x:N(n,"x","step")};return R.runKernel(Yo,s,{alpha:t})}});function wu(n,t,e){if(null==e||"linear"===e)return n;if("relu"===e)return A(n,fi(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function vu(n,t){let e=t;const s=zt(n.shape,t.shape);return s.length>0&&(e=ve(e,s)),O(e,n.shape)}function Cu(n,t,e,s){if("linear"===t)return n;if("relu"===t)return zs(n);if("elu"===t)return pu(n);if("relu6"===t)return ty(n);if("prelu"===t)return Mh(n,e);if("leakyrelu"===t)return Ah(n,s);if("sigmoid"===t)return ka(n);throw new Error(`Unknown fused activation ${t}.`)}const Su=(n,t)=>!(n>0)||"linear"===t,sN=F({fusedConv2d_:function nN({x:n,filter:t,strides:e,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===Su(R.state.gradientDepth,l=l||"linear")){I("NHWC"===r,()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=Br(n,t,e,s,r,a,o);return null!=i&&(S=te(S,i)),Cu(S,l,u,c)}const d=N(n,"x","conv2d","float32"),h=N(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=O(d,[1,d.shape[0],d.shape[1],d.shape[2]])),I(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),I(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),yn("fused conv2d",s,o);const g="NHWC"===r?p.shape[3]:p.shape[1];I(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),I(nn(e,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);const m=Kt(p.shape,h.shape,e,a,s,o);let y,x;if(null!=i&&(y=N(i,"bias","fused conv2d"),[y]=Nt(y,d),"NHWC"===r?Oe(m.outShape,y.shape):(I(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),I(0===y.shape.length||y.shape[0]===m.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${m.outChannels})`))),null!=u){const S=u.shape;if(I(S.length<=1||3===S.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`),1===S.length)I(1===S[0]||S[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${m.outChannels}).`);else if(3===S.length)try{Oe(S,m.outShape)}catch(T){throw Error(`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${m.outShape}).`)}x=N(u,"prelu weights","fused conv2d")}const b=(S,T)=>{I("NHWC"===r,()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[k,$,E,P]=T,z=wu(S,E,l);I(lr(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const G=[$h($.shape,z,k,e,s),Kh($,z,k.shape,e,s)];if(null!=P){const q=vu(P,z);G.push(q)}return G},w={x:p,filter:h,bias:y,preluActivationWeights:x},C={strides:e,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:l,leakyreluAlpha:c};return null==i?Os((T,k,$)=>{let E=R.runKernel(Kl,w,C);return $([k,T,E]),f&&(E=O(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:b}})(p,h):Os((T,k,$,E)=>{let P=R.runKernel(Kl,w,C);return E([k,T,P,$]),f&&(P=O(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:b}})(p,h,y)}}),ny=F({depthwiseConv2dNativeBackpropFilter_:function rN(n,t,e,s,r,a=[1,1],o){let i=n;3===n.rank&&(i=O(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=t;return 3===l.rank&&(l=O(t,[1,t.shape[0],t.shape[1],t.shape[2]])),R.runKernel(ud,{x:i,dy:l},{strides:s,pad:r,dimRoundingMode:o,dilations:a,filterShape:e})}}),sy=F({depthwiseConv2dNativeBackpropInput_:function aN(n,t,e,s,r,a=[1,1],o){let i=t,l=!1;3===t.rank&&(l=!0,i=O(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const d=R.runKernel(cd,{dy:i,filter:e},{strides:s,pad:r,dimRoundingMode:o,dilations:a,inputShape:n});return l?O(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),ry=F({fusedMatMul_:function iN({a:n,b:t,transposeA:e=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(!1===Su(R.state.gradientDepth,a)){let P=et(n,t,e,s);return null!=r&&(P=te(P,r)),Cu(P,a,o,i)}let l=N(n,"a","fused matMul"),u=N(t,"b","fused matMul");[l,u]=Nt(l,u);const c=e?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?u.shape[u.rank-1]:u.shape[u.rank-2],h=e?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),g=u.shape.slice(0,-2),m=W(f),y=W(g);I(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${e} and transposeB=${s} must match.`);const b=Oe(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),w=O(l,e?[m,c,h]:[m,h,c]),C=O(u,s?[y,p,d]:[y,d,p]);let S,T;null!=r&&(S=N(r,"bias","fused matMul"),[S]=Nt(S,l),Oe(b,S.shape)),null!=o&&(T=N(o,"prelu weights","fused matMul"));const k=(P,z)=>{const[B,U,G,q]=z,K=wu(O(P,G.shape),G,a);let H,X;return e||s?!e&&s?(H=et(K,U,!1,!1),X=et(K,B,!0,!1)):e&&!s?(H=et(U,K,!1,!0),X=et(B,K,!1,!1)):(H=et(U,K,!0,!0),X=et(K,B,!0,!0)):(H=et(K,U,!1,!0),X=et(B,K,!0,!1)),null!=r?[H,X,vu(q,K)]:[H,X]},$={a:w,b:C,bias:S,preluActivationWeights:T},E={transposeA:e,transposeB:s,activation:a,leakyreluAlpha:i};return null==r?Os((z,B,U)=>{const G=R.runKernel(ql,$,E);return U([z,B,G]),{value:O(G,b),gradFunc:k}})(w,C):Os((z,B,U,G)=>{const q=R.runKernel(ql,$,E);return G([z,B,q,U]),{value:O(q,b),gradFunc:k}})(w,C,S)}}),gN=F({cropAndResize_:function mN(n,t,e,s,r="bilinear",a=0){const o=N(n,"image","cropAndResize"),i=N(t,"boxes","cropAndResize","float32"),l=N(e,"boxInd","cropAndResize","int32"),u=i.shape[0];return I(4===o.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),I(2===i.rank&&4===i.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${i.shape}.`),I(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${i.shape}.`),I(2===s.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),I(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),I("bilinear"===r||"nearest"===r,()=>`method must be bilinear or nearest, but was ${r}`),R.runKernel(od,{image:o,boxes:i,boxInd:l},{method:r,extrapolationValue:a,cropSize:s})}}),xN=F({flipLeftRight_:function yN(n){const t=N(n,"image","flipLeftRight","float32");return I(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`),R.runKernel(yd,{image:t},{})}}),wN=F({grayscaleToRGB_:function bN(n){const t=N(n,"image","grayscaleToRGB"),e=t.rank-1,s=t.shape[e];I(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),I(1===s,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);return r.fill(1,0,e),r[e]=3,as(t,r)}}),mi=F({einsum_:function vN(n,...t){const e=t.map((r,a)=>N(r,`tensors${a}`,"einsum"));return R.runKernel(pd,e,{equation:n})}}),SN=F({rgbToGrayscale_:function CN(n){const t=N(n,"image","RGBToGrayscale"),s=t.shape[t.rank-1];I(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),I(3===s,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`);const r=t.dtype,a=de(t,"float32"),o=xn([.2989,.587,.114]);let i;switch(t.rank){case 2:i=mi("ij,j->i",a,o);break;case 3:i=mi("ijk,k->ij",a,o);break;case 4:i=mi("ijkl,l->ijk",a,o);break;case 5:i=mi("ijklm,m->ijkl",a,o);break;case 6:i=mi("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=Nn(i,-1),de(i,r)}}),TN=F({rotateWithOffset_:function IN(n,t,e=0,s=.5){const r=N(n,"image","rotateWithOffset","float32");return I(4===r.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`),R.runKernel(Wd,{image:r},{radians:t,fillValue:e,center:s})}});function $a(n,t,e,s,r,a){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==a&&(a=0);const o=n.shape[0];return e=Math.min(e,o),I(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),I(2===n.rank,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(4===n.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(1===t.rank,()=>"scores must be a 1D tensor"),I(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),I(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:e,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}const kN=F({nonMaxSuppression_:function NN(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const a=N(n,"boxes","nonMaxSuppression","float32"),o=N(t,"scores","nonMaxSuppression","float32"),i=$a(a,o,e,s,r);return R.runKernel(Sd,{boxes:a,scores:o},{maxOutputSize:e=i.maxOutputSize,iouThreshold:s=i.iouThreshold,scoreThreshold:r=i.scoreThreshold})}});function _N(n,t,e){const s=function $N(n,t,e){return function AN(n,t,e){let s=0,r=n.length,a=0,o=!1;for(;s<r;){a=s+(r-s>>>1);const i=e(t,n[a]);i>0?s=a+1:(r=a,o=!i)}return o?s:-s-1}(n,t,e||EN)}(n,t,e);n.splice(s<0?-(s+1):s,0,t)}function EN(n,t){return n>t?1:n<t?-1:0}function Xh(n,t,e,s,r){return Jh(n,t,e,s,r,0)}function Zh(n,t,e,s,r,a){return Jh(n,t,e,s,r,0,!1,a,!0)}function Yh(n,t,e,s,r,a){return Jh(n,t,e,s,r,a,!0)}function Jh(n,t,e,s,r,a,o=!1,i=!1,l=!1){const u=[];for(let m=0;m<t.length;m++)t[m]>r&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(ly);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<e&&u.length>0;){const m=u.pop(),{score:y,boxIndex:x,suppressBeginIndex:b}=m;if(y<r)break;let w=!1;for(let C=d.length-1;C>=b;--C){const S=DN(n,x,d[C]);if(S>=s){w=!0;break}if(m.score=m.score*RN(s,c,S),m.score<=r)break}m.suppressBeginIndex=d.length,w||(m.score===y?(d.push(x),h.push(m.score)):m.score>r&&_N(u,m,ly))}const p=d.length,f=e-p;i&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const g={selectedIndices:d};return o&&(g.selectedScores=h),l&&(g.validOutputs=p),g}function DN(n,t,e){const s=n.subarray(4*t,4*t+4),r=n.subarray(4*e,4*e+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),p=(i-a)*(l-o),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const g=Math.max(a,u),m=Math.max(o,c),y=Math.min(i,d),x=Math.min(l,h),b=Math.max(y-g,0)*Math.max(x-m,0);return b/(p+f-b)}function RN(n,t,e){const s=Math.exp(t*e*e);return e<=n?s:0}function ly(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function Qh(){return(Qh=Z(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY){const a=N(n,"boxes","nonMaxSuppressionAsync"),o=N(t,"scores","nonMaxSuppressionAsync"),i=$a(a,o,e,s,r);e=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const l=yield Promise.all([a.data(),o.data()]),u=l[0],c=l[1],{selectedIndices:d}=Xh(u,c,e,s,r);return a!==n&&a.dispose(),o!==t&&o.dispose(),xn(d,"int32")})).apply(this,arguments)}const LN=F({nonMaxSuppressionWithScore_:function PN(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=N(n,"boxes","nonMaxSuppression"),i=N(t,"scores","nonMaxSuppression"),l=$a(o,i,e,s,r,a),d=R.runKernel(Td,{boxes:o,scores:i},{maxOutputSize:e=l.maxOutputSize,iouThreshold:s=l.iouThreshold,scoreThreshold:r=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma});return{selectedIndices:d[0],selectedScores:d[1]}}});function ep(){return(ep=Z(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=N(n,"boxes","nonMaxSuppressionAsync"),i=N(t,"scores","nonMaxSuppressionAsync"),l=$a(o,i,e,s,r,a);e=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,a=l.softNmsSigma;const u=yield Promise.all([o.data(),i.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=Yh(c,d,e,s,r,a);return o!==n&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:xn(h,"int32"),selectedScores:xn(p)}})).apply(this,arguments)}const BN=F({nonMaxSuppressionPadded_:function zN(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=N(n,"boxes","nonMaxSuppression"),i=N(t,"scores","nonMaxSuppression"),l=$a(o,i,e,s,r,null),f=R.runKernel(Id,{boxes:o,scores:i},{maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a});return{selectedIndices:f[0],validOutputs:f[1]}}});function tp(){return(tp=Z(function*(n,t,e,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=N(n,"boxes","nonMaxSuppressionAsync"),i=N(t,"scores","nonMaxSuppressionAsync"),l=$a(o,i,e,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=yield Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:g}=Zh(h,p,u,c,d,a);return o!==n&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:xn(f,"int32"),validOutputs:Re(g,"int32")}})).apply(this,arguments)}const uy=F({resizeBilinear_:function GN(n,t,e=!1,s=!1){const r=N(n,"images","resizeBilinear");I(3===r.rank||4===r.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),I(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),I(!1===s||!1===e,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;3===r.rank&&(o=!0,a=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,u=R.runKernel(Ol,{images:a},{alignCorners:e,halfPixelCenters:s,size:t});return o?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),cy=F({resizeNearestNeighbor_:function HN(n,t,e=!1,s=!1){const r=N(n,"images","resizeNearestNeighbor");I(3===r.rank||4===r.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),I(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),I("float32"===r.dtype||"int32"===r.dtype,()=>"`images` must have `int32` or `float32` as dtype"),I(!1===s||!1===e,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;3===r.rank&&(o=!0,a=O(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,u=R.runKernel(Fl,{images:a},{alignCorners:e,halfPixelCenters:s,size:t});return o?O(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),qN=F({bincount_:function jN(n,t,e){const s=N(n,"x","bincount"),r=N(t,"weights","bincount");return I("int32"===s.dtype,()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),I(e>=0,()=>`size must be non-negative, but got ${e}.`),I(r.size===s.size||0===r.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`),R.runKernel(Qc,{x:s,weights:r},{size:e})}}),Ea=F({lessEqual_:function KN(n,t){let e=N(n,"a","lessEqual","string_or_numeric"),s=N(t,"b","lessEqual","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(fl,{a:e,b:s})}}),dy=F({round_:function XN(n){const e={x:N(n,"x","round")};return R.runKernel(Lo,e)}}),JN=F({threshold_:function ZN(n,t="binary",e=!1,s=.5){const r=N(n,"image","threshold"),l=r.shape[0]*r.shape[1];let c,d,h,p,u=A(xn([s]),255);if(I(3===r.rank,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),I(3===r.shape[2]||1===r.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),I("int32"===r.dtype||"float32"===r.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),I("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===r.shape[2]){[c,d,h]=Vn(r,[1,1,1],-1);const m=A(c,.2989),y=A(d,.587),x=A(h,.114);p=te(te(m,y),x)}else p=n;"otsu"===t&&(u=function YN(n,t){let a,o,i,l,u,c,e=xn([-1]),s=xn([0]),r=xn([0]);for(let d=0;d<n.size-1;d++){a=it(n,0,d+1),o=it(n,d+1),u=Se(ve(a),t),c=Se(ve(o),t);const h=ve(A(a,di(0,a.size)));i=Se(h,ve(a));const p=si(o.shape,a.size),f=te(di(0,o.size),p),g=A(o,f);l=Se(ve(g),ve(o));const m=ye(i,l),y=ye(i,l),x=A(u,c);r=A(A(x,m),y);const b=Mn(r,s);s=bn(b,r,s),e=bn(b,xn([d]),e)}return e}(qN(de(dy(p),"int32"),ni([]),256),l));const f=e?Ea(p,u):Mn(p,u);return de(A(f,255),"int32")}}),ek=F({transform_:function QN(n,t,e="nearest",s="constant",r=0,a){const o=N(n,"image","transform","float32"),i=N(t,"transforms","transform","float32");return I(4===o.rank,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),I(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`),R.runKernel(zd,{image:o,transforms:i},{interpolation:e,fillMode:s,fillValue:r,outputShape:a})}}),Iu=F({less_:function tk(n,t){let e=N(n,"a","less","string_or_numeric"),s=N(t,"b","less","string_or_numeric");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(pl,{a:e,b:s})}}),sk=F({bandPart_:function nk(n,t,e){const s=N(n,"a","bandPart");I(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,o]=s.shape.slice(-2);let i,l;"number"==typeof t?(I(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),I(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),i=N(t<0?a:t,"numLower","bandPart")):(I("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),i=bn(Iu(t,0),a,Na(t,a))),"number"==typeof e?(I(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),I(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),l=N(e<0?o:e,"numUpper","bandPart")):(I("int32"===e.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=bn(Iu(e,0),o,Na(e,o)));const u=O(di(0,a,1,"int32"),[-1,1]),c=di(0,o,1,"int32"),d=ye(u,c),h=Ms(Ea(d,i),Wr(d,xt(l))),p=Zt([a,o],s.dtype);return O(Bs(Gr(O(s,[-1,a,o])).map(f=>bn(h,f,p))),r)}});function hy(n,t,e=null){if(0===n.rank)return qt(n);if(1!==n.rank&&null===e)return hy(O(n,[-1]),t,e);if(1===n.rank||"number"==typeof e||Array.isArray(e)&&1===e.length){if(1===t)return ve(qt(n),e);if(t===1/0)return os(qt(n),e);if(t===-1/0)return mu(qt(n),e);if("euclidean"===t||2===t)return cn(ve(Vr(qt(n),Re(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&2===e.length){if(1===t)return os(ve(qt(n),e[0]),e[1]-1);if(t===1/0)return os(ve(qt(n),e[1]),e[0]);if(t===-1/0)return mu(ve(qt(n),e[1]),e[0]);if("fro"===t||"euclidean"===t)return cn(ve(pt(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const Tu=F({norm_:function rk(n,t="euclidean",e=null,s=!1){const r=hy(n=N(n,"x","norm"),t,e);let a=r.shape;if(s){const o=ze(e,n.shape);a=Et(r.shape,o)}return O(r,a)}}),ok=F({gramSchmidt_:function ak(n){let t;if(Array.isArray(n)){t=!1,I(null!=n&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let a=1;a<n.length;++a)I(n[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${r})`)}else t=!0,n=Vn(n,n.shape[0],0).map(r=>pi(r,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],s=n;for(let r=0;r<n.length;++r)e.push(R.tidy(()=>{let a=s[r];if(r>0)for(let o=0;o<r;++o){const i=A(ve(A(e[o],a)),e[o]);a=ye(a,i)}return Se(a,Tu(a,"euclidean"))}));return t?Bs(e,0):e}});function py(n,t=!1){return R.tidy(()=>{I(2===n.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],s=n.shape[1];let r=jg(e),a=Mr(n);const o=_a([[1]],[1,1]);let i=Mr(o);const l=e>=s?s:e;for(let u=0;u<l;++u){const c=a,d=i,h=r;[i,a,r]=R.tidy(()=>{const p=it(a,[u,u],[e-u,1]),f=Tu(p),g=it(a,[u,u],[1,1]),m=bn(Mn(g,0),_a([[-1]]),_a([[1]])),y=ye(g,A(m,f)),x=Se(p,y);i=1===x.shape[0]?Mr(o):dn([o,it(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const b=xt(Se(et(m,y),f)),w=it(a,[u,0],[e-u,s]),C=A(b,i),S=qe(i);if(0===u)a=ye(w,et(C,et(S,w)));else{const $=ye(w,et(C,et(S,w)));a=dn([it(a,[0,0],[u,s]),$],0)}const T=qe(C),k=it(r,[0,u],[e,r.shape[1]-u]);if(0===u)r=ye(k,et(et(k,i),T));else{const $=ye(k,et(et(k,i),T));r=dn([it(r,[0,0],[e,u]),$],1)}return[i,a,r]}),Ue([c,d,h])}return!t&&e>s&&(r=it(r,[0,0],[e,s]),a=it(a,[0,0],[s,s])),[r,a]})}const lk=F({qr_:function ik(n,t=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),2===n.rank)return py(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((l,u)=>l*u),s=Gr(O(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],a=[];return s.forEach(l=>{const[u,c]=py(l,t);r.push(u),a.push(c)}),[O(Bs(r,0),n.shape),O(Bs(a,0),n.shape)]}}}),fy=F({squaredDifference_:function wk(n,t){let e=N(n,"a","squaredDifference"),s=N(t,"b","squaredDifference");return[e,s]=Nt(e,s),Oe(e.shape,s.shape),R.runKernel(jo,{a:e,b:s},{})}}),Us={flipLeftRight:xN,grayscaleToRGB:wN,resizeNearestNeighbor:cy,resizeBilinear:uy,rgbToGrayscale:SN,rotateWithOffset:TN,cropAndResize:gN,nonMaxSuppression:kN,nonMaxSuppressionAsync:function FN(n,t,e){return Qh.apply(this,arguments)},nonMaxSuppressionWithScore:LN,nonMaxSuppressionWithScoreAsync:function MN(n,t,e){return ep.apply(this,arguments)},nonMaxSuppressionPadded:BN,nonMaxSuppressionPaddedAsync:function WN(n,t,e){return tp.apply(this,arguments)},threshold:JN,transform:ek},Hk={bandPart:sk,gramSchmidt:ok,qr:lk},Hr=class jk{static sgd(t){return new fh(t)}static momentum(t,e,s=!1){return new vg(t,e,s)}static rmsprop(t,e=.9,s=0,r=null,a=!1){return new Cg(t,e,s,r,a)}static adam(t=.001,e=.9,s=.999,r=null){return new bg(t,e,s,r)}static adadelta(t=.001,e=.95,s=null){return new yg(t,e,s)}static adamax(t=.002,e=.9,s=.999,r=null,a=0){return new wg(t,e,s,r,a)}static adagrad(t,e=.1){return new xg(t,e)}},qk="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:n=>n();function my(){return new Promise(n=>qk(()=>n()))}function np(n,t){const e=n[0].length;n.forEach((r,a)=>{I(r.length===e,()=>`Error in concat${e}D: rank of tensors[${a}] must be the same as the rank of the rest (${e})`)}),I(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const s=n[0];n.forEach((r,a)=>{for(let o=0;o<e;o++)I(o===t||r[o]===s[o],()=>`Error in concat${e}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function Cs(n,t){const e=n[0].slice();for(let s=1;s<n.length;s++)e[t]+=n[s][t];return e}var Yn=(()=>{return(n=Yn||(Yn={}))[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS",Yn;var n})();function gy(n,t,e){let s=new Array;if(null==e&&null==t)return s;if(null==t)for(;s.length<n+e.length;)s.push(-1);else s=t.slice();if(null==e)return s;if(n+e.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${s.length}`);for(let r=1;r<e.length;++r){const a=e[r],o=s[s.length-e.length+r],i=s[o];if(a>=0)if(i>=0){if(i!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+n}] = ${a} but shape[${r+n}] = ${i}`)}else s[o]=a}return s}function yy(n){const t={FIRST_DIM_SIZE:Yn.FIRST_DIM_SIZE,VALUE_ROWIDS:Yn.VALUE_ROWIDS,ROW_LENGTHS:Yn.ROW_LENGTHS,ROW_SPLITS:Yn.ROW_SPLITS,ROW_LIMITS:Yn.ROW_LIMITS,ROW_STARTS:Yn.ROW_STARTS},e=[];for(const s of n){if(!(s in t))break;e.push(t[s])}return e}function xy(n){return 0===n.length?0:n[0]===Yn.FIRST_DIM_SIZE?n.length-1:n.length}function by(n,t){if(null==n||null==t)return;const e=n.length,s=t.length;if(e>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(e,s-1);++r){const a=n[r],o=t[r+1];if(a>=0&&o>=0&&1!==a&&a!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-n.length}] = ${a} but ragged tensor input.flatValues.shape[${r-n.length}] = ${o}`)}}const sp=30;function Nu(n){return n<=sp?n:Uc(n,Math.floor(Math.sqrt(n)))}function rp(n,t,e){return[e*("number"==typeof n?n:n[0]),t*("number"==typeof n?n:n[1])]}function gi(n,t,e,s=!0){let r=[];if(s)r=r.concat(t.slice(0)),r.push(n[0]/e),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const a=t.length;for(let o=0;o<a;++o)r=r.concat([n[o+1]/t[o],t[o]]);r=r.concat(n.slice(a+1))}return r}function yi(n,t,e=!0){const s=[];if(e){s.push(t);for(let r=t+1;r<n;++r)r<=2*t?(s.push(r),s.push(r-(t+1))):s.push(r)}else{const r=[],a=[];for(let o=1;o<n;++o)o>=2*t+1||o%2==1?a.push(o):r.push(o);s.push(...r),s.push(0),s.push(...a)}return s}function xi(n,t,e,s=!0){const r=[];r.push(s?n[0]/e:n[0]*e);for(let a=1;a<n.length;++a)r.push(a<=t.length?s?t[a-1]*n[a]:n[a]/t[a-1]:n[a]);return r}function ap(n,t){const e=[0];for(let s=0;s<t;++s)e.push(n[s][0]);return e}function op(n,t,e){const s=n.slice(0,1);for(let r=0;r<e;++r)s.push(n[r+1]-t[r][0]-t[r][1]);return s}function ip(n,t){const e=n.shape.length,s=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${e}`);if(0===W(n.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=t.shape,a=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const i=n.shape,l=r.slice();l.pop();let u=1;for(let d=a;d<e;++d)u*=i[d],l.push(i[d]);const c=[...Ie(n.shape).map(d=>d/u),1].slice(0,a);return[l,o,u,c]}function wy(n,t,e){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(e.rank<r)throw new Error(a+` update.rank < ${r}. `);if(n.length<s+(e.rank-r))throw new Error(a+` Output shape length < ${s+(e.rank-r)}`);if(e.rank!==r+n.length-s)throw new Error(a+" update.rank != "+(r+n.length-s));for(let o=0;o<r;++o)if(e.shape[o]!==t.shape[o])throw new Error(a+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-r;++o)if(e.shape[o+r]!==n[o+s])throw new Error(a+` updates.shape[${o+r}] (${e.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function Kk(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(0===e.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===n.size)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}wy(e,t,n)}function jr(n,t,e){const s=t.shape.length,r=s>1?t.shape[s-1]:1,a=e.length;let o=1;for(let d=r;d<a;++d)o*=e[d];const i=r<1?1:r;return{sliceRank:r,numUpdates:W(t.shape)/i,sliceSize:o,strides:[...Ie(e.slice(0,r)),1],outputSize:W(e)}}const ku=1.7580993408473768,_u=1.0507009873554805,lp=.3275911,up=.254829592,cp=-.284496736,dp=1.421413741,hp=-1.453152027,pp=1.061405429;function Gs(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(2*n.length);for(let s=0;s<e.length;s+=2)e[s]=n[s/2],e[s+1]=t[s/2];return e}function vy(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)t[s/2]=n[s],e[s/2]=n[s+1];return{real:t,imag:e}}function Cy(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function Sy(n){const t=Math.floor(n.length/4),e=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<n.length;r+=4)e[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:e,imag:s}}function fp(n,t){return{real:n[2*t],imag:n[2*t+1]}}function Iy(n,t,e,s){n[2*s]=t,n[2*s+1]=e}function Ty(n,t){const e=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const a=(t?2:-2)*Math.PI*(r/n);e[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:e,imag:s}}function Ny(n,t,e){const s=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(s),imag:Math.sin(s)}}const Xk=/->/g;function gp(n,t){const e=((n=n.replace(/\s/g,"")).length-n.replace(Xk,"").length)/"->".length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error('Equation must contain exactly one arrow ("->").');const[s,r]=n.split("->");I(-1===s.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');const a=s.split(","),o=a.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<r.length;++h){const p=r[h];if(!a.some(f=>-1!==f.indexOf(p)))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);-1===i.indexOf(p)&&i.push(p)}for(let h=0;h<s.length;++h){const p=s[h];-1===i.indexOf(p)&&","!==p&&i.push(p)}const l=new Array(a.length);for(let h=0;h<o;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<a[h].length;++p)l[h].push(i.indexOf(a[h][p]))}const u=i.length,d=[];for(let h=r.length;h<u;++h)d.push(h);return{allDims:i,summedDims:d,idDims:l}}function yp(n,t){let e=new Array(n);e.fill(-1);for(let r=0;r<t.length;++r)e[t[r]]=r;const s=[];for(let r=0;r<n;++r)-1===e[r]&&s.push(r);return e=e.filter(r=>-1!==r),{permutationIndices:e,expandDims:s}}function xp(n,t,e){const s=new Array(n);for(let r=0;r<e.length;++r){const a=e[r].shape;for(let o=0;o<t[r].length;++o)void 0===s[t[r][o]]?s[t[r][o]]=a[o]:I(s[t[r][o]]===a[o],()=>`Expected dimension ${s[t[r][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function bp(n,t){const e=n,s=[];let r=0;0===n.length&&e.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const a=[];for(let o=0;o<e.length;++o){const l=Zk(t,e[o]);for(const u of l)-1===a.indexOf(u)&&(s[o].push(u),a.push(u))}return{path:e,steps:s}}function wp(n){return n.every((t,e)=>t===e)}function Zk(n,t){const e=[];for(let s=0;s<n.length;++s)(0===n[s].length||-1!==n[s].indexOf(t)||-1===t)&&e.push(s);return e}function vp(n,t,e=0){let s=[];if("number"==typeof t)I(n.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),s=new Array(t).fill(n.shape[e]/t);else{I(t.reduce((o,i)=>(-1===i&&(o+=1),o),0)<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(-1!==a){const o=t.reduce((i,l)=>l>0?i+l:i);t[a]=n.shape[e]-o}I(n.shape[e]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),s=t}return s}function $y(n){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${n}`}function Ey(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function Ay(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function Dy(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function Ry(n,t){return`size ${n} must be non-negative, not ${t}`}function Fy(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Oy(n,t){return`Input to reshape is a SparseTensor with ${W(n)}\n  dense values, but the requested shape requires a multiple of ${W(t)}. inputShape=${n} outputShape= ${t}`}function Py(n,t){return`Input to reshape is a tensor with ${W(n)} dense values, but the requested shape has ${W(t)}. inputShape=${n} outputShape=${t}`}function Cp(){return"segment ids must be >= 0"}function Ly(){return"segment ids are not increasing"}function My(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Vy(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function zy(n,t){let s,e=!1;for(n<=sp?(s=n,e=!0):s=Uc(n,Math.floor(Math.sqrt(n)));!e;)s>t||s===n?e=!0:s=Uc(n,s+1);return s}function By(n,t,e){const s=[],r=n.length;for(let a=0;a<r;a++)s.push(a!==t?n[a]:e);return s}function Sp(n,t,e,s){const r=t.shape.length,a=n.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${a}).`);if(e<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${e}).`);for(let d=0;d<s;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],i=[];let l=1,u=1,c=1;for(let d=0;d<s;++d)i.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<e;d++)i.push(n.shape[d]),u*=n.shape[d];for(let d=s;d<r;d++)i.push(t.shape[d]);for(let d=e+1;d<a;d++)i.push(n.shape[d]),c*=n.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:o,outputShape:i}}function Hs(n){try{return n.map(t=>nr(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Wy(n){return n.map(t=>tr(t))}function Uy(n,t){const e=[];for(let a=0;a<t.length;a++)t[a]&&e.push(a);const s=Be(n,"int32"),r=Be([e.length,n.length],"int32");for(let a=0;a<e.length;a++){const o=s.indexToLoc(e[a]);r.values.set(o,a*n.length)}return r.toTensor()}!function AS(){for(const n of ES)ee(n)}();const Gy={kernelName:ji,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,fi(de(e,"float32"),-1))}}},Yk={kernelName:to,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=pt(de(e,"float32")),r=cn(ye(Re(1),s));return xt(Se(n,r))}}}},Jk={kernelName:no,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=cn(ye(pt(de(e,"float32")),1));return Se(n,s)}}}},Qk={kernelName:ma,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{let i=n;const l=zt(e.shape,r);return l.length>0&&(i=ve(i,l)),O(i,e.shape)},b:()=>{let i=n;const l=zt(s.shape,r);return l.length>0&&(i=ve(i,l)),O(i,s.shape)}}}},e_={kernelName:Kc,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}},t_={kernelName:qi,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>je(e)}}},n_={kernelName:Ki,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>je(e)}}},s_={kernelName:so,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,cn(ye(Re(1),pt(de(e,"float32")))))}}},r_={kernelName:ro,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=cn(te(Re(1),pt(de(e,"float32"))));return Se(n,s)}}}},a_={kernelName:lo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{const i=te(pt(e),pt(s));let l=A(n,Se(s,i));const u=zt(e.shape,r);return u.length>0&&(l=ve(l,u)),O(l,e.shape)},b:()=>{const i=te(pt(e),pt(s));let l=xt(A(n,Se(e,i)));const u=zt(s.shape,r);return u.length>0&&(l=ve(l,u)),O(l,s.shape)}}}},o_={kernelName:ao,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,te(pt(de(e,"float32")),1))}}},i_={kernelName:oo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,ye(Re(1),pt(de(e,"float32"))))}}},u_=F({avgPool3dGrad_:function l_(n,t,e,s,r,a){const o=N(n,"dy","avgPool3dGrad"),i=N(t,"input","avgPool3dGrad");let l=o,u=i,c=!1;4===i.rank&&(c=!0,l=O(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),u=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),I(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),yn("avgPool3dGrad",r,a);const p=R.runKernel(Jc,{dy:l,input:u},{filterSize:e,strides:s,pad:r,dimRoundingMode:a});return c?O(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),c_={kernelName:Zi,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:a,pad:o,dimRoundingMode:i}=e;return{x:()=>u_(n,s,r,a,o,i)}}},h_=F({avgPoolGrad_:function d_(n,t,e,s,r){const a=N(n,"dy","avgPoolGrad"),o=N(t,"input","avgPoolGrad");I(o.rank===a.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${a.rank})`);let i=o,l=a,u=!1;3===o.rank&&(u=!0,i=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=O(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),I(4===i.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const h=R.runKernel(Yc,{dy:l,input:i},{filterSize:e,strides:s,pad:r});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),p_={kernelName:Xi,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:a,pad:o}=e;return{x:()=>h_(n,s,r,a,o)}}},f_={kernelName:Yi,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:a,transposeB:o}=e;return a||o?!a&&o?{a:()=>et(n,r,!1,!1),b:()=>et(n,s,!0,!1)}:a&&!o?{a:()=>et(r,n,!1,!0),b:()=>et(s,n,!1,!1)}:{a:()=>et(r,n,!0,!0),b:()=>et(n,s,!0,!0)}:{a:()=>et(n,r,!1,!0),b:()=>et(s,n,!0,!1)}}},Ip=F({spaceToBatchND_:function m_(n,t,e){const s=N(n,"x","spaceToBatchND");return I(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`),I(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),I(s.shape.reduce((o,i,l)=>l>0&&l<=t.length?o&&(i+e[l-1][0]+e[l-1][1])%t[l-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`),R.runKernel(zl,{x:s},{blockShape:t,paddings:e})}}),g_={kernelName:Ji,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>Ip(n,s,r)}}},y_={kernelName:"BroadcastTo",gradFunc:(n,t,e)=>{const r=e.inputShape,a=e.shape,o=Array.from(a);for(let l=r.length-1;l>=0;l--)if(r[l]===a[l])o[l]=1;else if(1!==r[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const i=[];for(let l=0;l<o.length;l++)o[l]>1&&i.push(l);return{x:()=>ve(n,i,!0)}}},x_={kernelName:uo,gradFunc:n=>({x:()=>n.clone()})},b_={kernelName:co,gradFunc:n=>({x:()=>je(n)})},w_={kernelName:ho,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:a}=e;return{x:()=>bn(Ms(Wr(s,r),Ea(s,a)),n,je(n))}}},v_={kernelName:Qi,inputsToSave:["x"],gradFunc:Gy.gradFunc},C_={kernelName:el,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(l=>l.shape),{axis:r}=e,a=ze(r,t[0].shape)[0],o=s.map(l=>l[a]);return Vn(n,o,a).map(l=>()=>l)}},S_={kernelName:tl,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:a,strides:o,pad:i,dataFormat:l}=e;return I(lr(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>$h(s.shape,n,r,o,i,l),filter:()=>Kh(s,n,r.shape,o,i,l)}}},I_={kernelName:nl,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:a,pad:o,dataFormat:i,dimRoundingMode:l}=e;return{dy:()=>Br(n,r,a,o,i,1,l),filter:()=>Kh(n,s,r.shape,a,o,i,l)}}},N_=F({conv3DBackpropFilter_:function T_(n,t,e,s,r){let a=n;4===n.rank&&(a=O(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;return 4===o.rank&&(o=O(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),I(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),I(5===o.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),I(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),I(a.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${e[3]}.`),I(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`),R.runKernel(sd,{x:a,dy:o},{strides:s,pad:r,filterShape:e})}}),k_={kernelName:sl,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:a}=e;I(lr(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[o,i]=t;return{x:()=>Ug(o.shape,n,i,r,a),filter:()=>N_(o,n,i.shape,r,a)}}},Hy=F({sin_:function __(n){const e={x:N(n,"x","sin","float32")};return R.runKernel(zo,e)}}),$_={kernelName:po,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(xt(Hy(de(e,"float32"))),n)}}},jy=F({sinh_:function E_(n){const e={x:N(n,"x","sinh")};return R.runKernel(Bo,e)}}),A_={kernelName:fo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(jy(de(e,"float32")),n)}}},qy=F({cumsum_:function D_(n,t=0,e=!1,s=!1){const a={x:N(n,"x","cumsum")};return R.runKernel(rl,a,{axis:t,exclusive:e,reverse:s})}}),R_={kernelName:rl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:a,reverse:o}=e;return{x:()=>{const i=St([r],s.rank);let l=qy(n,r,a,!o);return null!=i&&(l=qe(l,i)),l}}}},F_={kernelName:al,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:o}=e,i=null==s?[1,1]:s;I(lr(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[l,u]=t;return I(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),I(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),I(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),I(nn(r,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${i}'.`),yn("depthwiseConv2d",a,o),{x:()=>sy(l.shape,n,u,r,a,i,o),filter:()=>ny(l,n,u.shape,r,a,i,o)}}},O_={kernelName:ol,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,a={x:s,filter:r,dy:n},o={x:s,filter:r,dy:n};return{x:()=>R.runKernel(dd,a,e),filter:()=>R.runKernel(hd,o,e)}}},P_={kernelName:go,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>R.runKernel(fd,s)}}},L_={kernelName:yo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=A(Ln(xt(pt(e))),2/Math.sqrt(Math.PI));return{x:()=>A(n,s)}}},M_={kernelName:xo,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,e)}}},V_={kernelName:ll,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>O(n,e.shape)}}},z_={kernelName:bo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,Ln(e))}}},B_={kernelName:wo,gradFunc:n=>({x:()=>je(n)})},W_={kernelName:vo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{const i=Se(n,de(s,"float32")),l=zt(e.shape,r);return l.length>0?O(ve(i,l),e.shape):i},b:()=>{let i=A(n,de(e,"float32"));const l=zt(s.shape,r);l.length>0&&(i=O(ve(i,l),s.shape));const u=pt(s);return xt(Se(i,de(u,"float32")))}}}},Ky=F({rsqrt_:function U_(n){const e={x:N(n,"x","rsqrt","float32")};return R.runKernel(Mo,e)}}),G_={kernelName:ul,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,a,o,i]=t,l=null==i?Re(1):i,u=zt(a.shape,r.shape),c=[];if(1===a.rank){for(let w=0;w<r.shape.length-1;++w)c.push(r.shape[w]);c.push(1)}const d=ye(r,a),h=A(n,l),p=Ky(te(o,Re(s))),f=A(A(A(p,p),p),Re(-.5));return{x:()=>O(A(A(n,1===a.rank?as(O(p,[1,1,1,a.shape[0]]),c):p),l),r.shape),mean:()=>{let w=A(A(p,Re(-1)),h);return 1===a.rank&&(w=ve(w,u)),O(w,a.shape)},variance:()=>{let w=A(A(f,d),h);return 1===a.rank&&(w=ve(w,u)),O(w,a.shape)},scale:()=>{const w=A(d,p);let C=A(n,w);return 1===a.rank&&(C=ve(C,u)),O(C,a.shape)},offset:()=>{let w=n;return 1===a.rank&&(w=ve(w,u)),O(w,a.shape)}}}},Xy=F({unsortedSegmentSum_:function H_(n,t,e){const s=N(n,"x","unsortedSegmentSum"),r=N(t,"segmentIds","unsortedSegmentSum","int32");return I(da(e),()=>"numSegments must be of dtype int"),R.runKernel(Hl,{x:s,segmentIds:r},{numSegments:e})}}),j_={kernelName:cl,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:a,batchDims:o}=e,i=ze(a,s.shape)[0],l=(u,c,d)=>()=>{const h=u.shape,p=c.size,f=h.slice(0,i),g=f.length,m=h.slice(a,h.length).slice(1),y=m.length,x=Zy(0,g),b=Zy(g+1,g+1+y),w=Yy([f,[p],m]),C=O(d,w),S=O(c,[p]),T=Yy([[g],x,b]),k=qe(C,T);let $=Xy(k,S,u.shape[i]);const E=ur(T);return $=qe($,E),$};if(1===o){const c=s.split(s.shape[0],0);return{x:()=>Bs(c.map((p,f)=>l(p,r.slice(f,1),n.slice(f,1))())).reshape(s.shape),indices:()=>r}}return{x:l(s,r,n),indices:()=>r}}};function Zy(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function Yy(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const q_={kernelName:Co,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>je(e),b:()=>je(s)}}},K_={kernelName:So,gradFunc:n=>({x:()=>de(n,"float32")})},X_={kernelName:Io,gradFunc:n=>({x:()=>je(n)})},Z_={kernelName:To,gradFunc:n=>({x:()=>je(n)})},Y_={kernelName:No,gradFunc:n=>({x:()=>je(n)})},J_={kernelName:hl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,a=Mn(s,0);return{x:()=>bn(a,n,A(n,r))}}},Q_={kernelName:_o,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,te(e,1))}}},e2={kernelName:ko,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,de(e,"float32"))}}},t2={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const o=Ln(s);return ye(n,A(ve(n,r,!0),o))}}}},s2=F({localResponseNormalizationBackprop_:function n2(n,t,e,s=5,r=1,a=1,o=.5){return R.runKernel(wd,{x:n,y:t,dy:e},{depthRadius:s,bias:r,alpha:a,beta:o})}}),r2={kernelName:xl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:a,bias:o,alpha:i,beta:l}=e;return{x:()=>s2(s,r,n,a,o,i,l)}}};function Jy(n,t,e,s){return t.rank<e.rank&&(t=O(t,Et(t.shape,s))),n.rank<e.rank&&(n=O(n,Et(n.shape,s))),{x:()=>A(n,de(vs(e,t),n.dtype))}}const Qy={kernelName:bl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,a=t[0],l=Jy(n,t[1],a,ze(r,a.shape));return{x:()=>l.x()}}},a2={kernelName:$o,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>A(n,de(Wr(e,s),"float32")),b:()=>A(n,de(Iu(e,s),"float32"))}}},i2=F({maxPool3dGrad_:function o2(n,t,e,s,r,a,o){const i=N(n,"dy","maxPool3dGrad"),l=N(t,"input","maxPool3dGrad"),u=N(e,"output","maxPool3dGrad");let c=i,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=O(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=O(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=O(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),I(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),I(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),I(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),yn("maxPool3dGrad",a,o);const m=R.runKernel(Cd,{dy:c,input:d,output:h},{filterSize:s,strides:r,pad:a,dimRoundingMode:o});return p?O(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),l2={kernelName:vl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:l}=e;return{x:()=>i2(n,s,r,a,o,i,l)}}},c2=F({maxPoolGrad_:function u2(n,t,e,s,r,a,o){const i=N(n,"dy","maxPoolGrad"),l=N(t,"input","maxPoolGrad"),u=N(e,"output","maxPoolGrad");return I(l.rank===i.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${i.rank})`),I(4===i.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),I(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),yn("maxPoolGrad",a,o),R.runKernel(vd,{dy:i,input:l,output:u},{filterSize:s,strides:r,pad:a,dimRoundingMode:o})}}),d2={kernelName:wl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:a,strides:o,pad:i}=e;return{x:()=>c2(n,s,r,a,o,i)}}},h2={kernelName:Cl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,a=ze(r,s.shape),l=W(Xt(s.shape,a)[1]);return{x:()=>{const c=s.shape.slice();a.forEach(p=>{c[p]=1});const d=O(n,c);return Se(A(d,Vs(s.shape,"float32")),l)}}}},p2={kernelName:Sl,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[a,o]=t,l=Jy(n,o,a,ze(r,a.shape));return{x:()=>l.x()}}},f2={kernelName:Eo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>A(n,de(Ea(e,s),"float32")),b:()=>A(n,de(Mn(e,s),"float32"))}}},m2={kernelName:Il,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,a=r.map(o=>o[0]);return{x:()=>it(n,a,s.shape)}}},g2={kernelName:Ao,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{const i=zt(e.shape,r);return i.length>0?O(ve(n,i),e.shape):n},b:()=>{const i=A(n,xt(fu(Se(e,s)))),l=zt(s.shape,r);return l.length>0?O(ve(i,l),s.shape):i}}}},y2={kernelName:Do,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{const i=A(n,de(s,"float32")),l=zt(e.shape,r);return l.length>0?O(ve(i,l),e.shape):i},b:()=>{const i=A(n,de(e,"float32")),l=zt(s.shape,r);return l.length>0?O(ve(i,l),s.shape):i}}}},x2={kernelName:Tl,gradFunc:n=>({x:()=>xt(n)})},b2={kernelName:_l,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Zt(e.shape,"float32")}}},w2={kernelName:kl,gradFunc:n=>({x:()=>je(n)})},v2={kernelName:$l,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return Gr(n,s).map(a=>()=>a)}},ex={kernelName:El,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,a=r.map(o=>o[0]);return{x:()=>it(n,a,s.shape)}}},C2={kernelName:Ro,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,a=e,o=s,i=Oe(a.shape,o.shape);return{a:()=>{const c=de(o,"float32");let d=A(n,A(c,Vr(a,ye(c,Re(1)))));const h=zt(a.shape,i);return h.length>0&&(d=ve(d,h)),O(d,a.shape)},b:()=>{const c=Mn(a,0),d=bn(c,Xn(a),je(a));let h=A(n,A(r,d));const p=zt(o.shape,i);return p.length>0&&(h=ve(h,p)),O(h,o.shape)}}}},S2={kernelName:Al,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=Mn(e,0);return{x:()=>bn(r,n,A(n,s)),alpha:()=>{let a=bn(r,je(n),A(n,e));const o=zt(s.shape,n.shape);return o.length>0&&(a=ve(a,o)),O(a,s.shape)}}}},Tp=F({cumprod_:function I2(n,t=0,e=!1,s=!1){const a={x:N(n,"x","cumprod")};return R.runKernel(ad,a,{axis:t,exclusive:e,reverse:s})}});const k2={kernelName:Dl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let a=[];return a=null==r?s.shape.map((o,i)=>i):"number"==typeof r?[r]:r,{x:()=>function N2(n,t,e){const s=n.shape.length,r=s-e.length,a=St(e,s);let o=n;null!=a&&(o=qe(n,a));const i=o.shape.slice(),u=i.splice(s-e.length,e.length).reduce((h,p)=>h*p,1);i.push(u);let d=function T2(n,t,e){const s=n.shape.slice();s[e]=1;const r=O(t,s),a=Tp(n,e,!0,!1),o=Tp(n,e,!0,!0),i=A(a,o);return A(r,i)}(o.reshape(i),t,r);if(d=d.reshape(o.shape),null!=a){const h=ur(a);d=qe(d,h)}return d}(s,n,a)}}},_2={kernelName:mo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{const i=Se(n,de(s,"float32")),l=zt(e.shape,r);return l.length>0?O(ve(i,l),e.shape):i},b:()=>{let i=A(n,de(e,"float32"));const l=zt(s.shape,r);l.length>0&&(i=O(ve(i,l),s.shape));const u=pt(s);return xt(Se(i,de(u,"float32")))}}}},$2={kernelName:Fo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,xt(pt(e)))}}},E2={kernelName:Po,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=A(Ea(e,6),fi(e));return{x:()=>A(n,de(s,"float32"))}}},A2={kernelName:Oo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,de(fi(e),"float32"))}}},D2={kernelName:Rl,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>O(n,e.shape)}}},R2={kernelName:Ol,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>R.runKernel($d,r,e)}}},F2={kernelName:Fl,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>R.runKernel(_d,r,e)}}},O2={kernelName:Pl,gradFunc:(n,t,e)=>{const{dims:s}=e,r=ze(s,n.shape);return{x:()=>Ur(n,r)}}},P2={kernelName:Lo,gradFunc:n=>({x:()=>je(n)})},L2={kernelName:Mo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>xt(Se(n,A(Vr(e,1.5),2)))}}},Np=F({logicalNot_:function M2(n){const e={x:N(n,"x","logicalNot","bool")};return R.runKernel(gl,e)}}),V2={kernelName:Ll,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>de(je(e),"float32"),t:()=>A(n,de(e,n.dtype)),e:()=>A(n,de(Np(e),n.dtype))}}},z2={kernelName:Vo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=Mn(e,Re(0)),r=Re(ku),a=Re(_u),o=A(n,a),i=A(A(n,r),Ln(de(e,"float32")));return bn(s,o,i)}}}},B2={kernelName:Uo,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,A(e,ye(Re(1),e)))}}},W2={kernelName:Wo,gradFunc:n=>({x:()=>je(n)})},kp=F({cos_:function U2(n){const e={x:N(n,"x","cos","float32")};return R.runKernel(po,e)}}),G2={kernelName:zo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(kp(de(e,"float32")),n)}}},tx=F({cosh_:function H2(n){const e={x:N(n,"x","cosh","float32")};return R.runKernel(fo,e)}}),j2={kernelName:Bo,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(tx(de(e,"float32")),n)}}},q2={kernelName:Ml,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:a}=e,o=s.shape,[i,l]=cu(s,r,a),u=[];for(let c=0;c<n.rank;c++)u.push([i[c],o[c]-i[c]-l[c]]);return{x:()=>Lh(n,u)}}},K2={kernelName:Wl,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,o=A(n,s);return{logits:()=>ye(o,A(ve(o,[r],!0),s))}}},X2={kernelName:Go,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,ka(e))}}},_p=F({batchToSpaceND_:function Z2(n,t,e){const s=N(n,"x","batchToSpaceND"),r=t.reduce((i,l)=>i*l);return I(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`),I(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),I(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`),R.runKernel(Ji,{x:s},{blockShape:t,crops:e})}}),nx={kernelName:zl,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>_p(n,s,r)}}},sx={kernelName:Bl,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>dn(n,s)}}},d$=[Gy,Yk,Jk,Qk,e_,t_,n_,s_,r_,a_,o_,i_,c_,p_,f_,g_,y_,x_,b_,w_,v_,C_,I_,S_,k_,$_,A_,R_,F_,O_,_2,P_,L_,M_,V_,z_,W_,B_,G_,j_,q_,K_,X_,Z_,Y_,J_,Q_,e2,t2,r2,Qy,Qy,a2,l2,d2,h2,p2,f2,m2,g2,y2,x2,b2,w2,v2,ex,ex,C2,S2,k2,$2,E2,A2,D2,R2,F2,O2,P2,L2,V2,z2,B2,W2,G2,j2,q2,K2,X2,nx,nx,sx,sx,{kernelName:Ho,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,A(cn(de(e,"float32")),2))}}},{kernelName:jo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Re(2);return{a:()=>A(n,A(r,ye(e,s))),b:()=>A(n,A(r,ye(s,e)))}}},{kernelName:Fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(n,A(de(e,"float32"),2))}}},{kernelName:Yo,gradFunc:n=>({x:()=>je(n)})},{kernelName:qo,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Oe(e.shape,s.shape);return{a:()=>{let i=n;const l=zt(e.shape,r);return l.length>0&&(i=ve(i,l)),O(i,e.shape)},b:()=>{let i=n;const l=zt(s.shape,r);return l.length>0&&(i=ve(i,l)),O(xt(i),s.shape)}}}},{kernelName:Vl,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:a}=e;ze(a,s.shape).forEach(u=>{r[u]=1});const i=O(n,r),l=A(i,Vs(s.shape,"float32"));return{x:()=>l}}},{kernelName:Ko,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Se(n,pt(kp(e)))}}},{kernelName:Xo,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>A(ye(Re(1),pt(e)),n)}}},{kernelName:Zo,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let o=je(s);if(1===s.rank)for(let i=0;i<r[0];++i)o=te(o,it(n,[i*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)o=te(o,it(n,[i*s.shape[0],l*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)o=te(o,it(n,[i*s.shape[0],l*s.shape[1],u*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let i=0;i<r[0];++i)for(let l=0;l<r[1];++l)for(let u=0;u<r[2];++u)for(let c=0;c<r[3];++c)o=te(o,it(n,[i*s.shape[0],l*s.shape[1],u*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return o}}}},{kernelName:ga,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,a=ur(r);return{x:()=>qe(n,a)}}},{kernelName:Gl,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>Bs(n,r)}}},{kernelName:Hl,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function u$(n,t){const e=or(t,je(t)),s=Eh(n,e);let r=Wr(t,Re(0,"int32"));const a=s.rank-r.rank;for(let i=0;i<a;++i)r=Nn(r,i+1);r=Ms(r,Vs(s.shape,"bool"));const o=je(s);return bn(r,s,o)}(n,e)}}},{kernelName:jl,gradFunc:n=>({x:()=>je(n)})}];for(const n of d$)pC(n);j().prototype.abs=function(){return this.throwIfDisposed(),qt(this)};const p$=F({acos_:function h$(n){const e={x:N(n,"x","acos")};return R.runKernel(to,e)}});j().prototype.acos=function(){return this.throwIfDisposed(),p$(this)};const m$=F({acosh_:function f$(n){const e={x:N(n,"x","acosh")};return R.runKernel(no,e)}});j().prototype.acosh=function(){return this.throwIfDisposed(),m$(this)},j().prototype.add=function(n){return this.throwIfDisposed(),te(this,n)},j().prototype.all=function(n,t){return this.throwIfDisposed(),zg(this,n,t)},j().prototype.any=function(n,t){return this.throwIfDisposed(),Th(this,n,t)},j().prototype.argMax=function(n){return this.throwIfDisposed(),ri(this,n)};const y$=F({argMin_:function g$(n,t=0){const s={x:N(n,"x","argMin")};return R.runKernel(Ki,s,{axis:t})}});j().prototype.argMin=function(n){return this.throwIfDisposed(),y$(this,n)},j().prototype.asScalar=function(){return this.throwIfDisposed(),I(1===this.size,()=>"The array must have only 1 element."),O(this,[])},j().prototype.asType=function(n){return this.throwIfDisposed(),de(this,n)},j().prototype.as1D=function(){return this.throwIfDisposed(),O(this,[this.size])},j().prototype.as2D=function(n,t){return this.throwIfDisposed(),O(this,[n,t])},j().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),O(this,[n,t,e])},j().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),O(this,[n,t,e,s])},j().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),O(this,[n,t,e,s,r])};const b$=F({asin_:function x$(n){const e={x:N(n,"x","asin")};return R.runKernel(so,e)}});j().prototype.asin=function(){return this.throwIfDisposed(),b$(this)};const v$=F({asinh_:function w$(n){const e={x:N(n,"x","asinh")};return R.runKernel(ro,e)}});j().prototype.asinh=function(){return this.throwIfDisposed(),v$(this)};const S$=F({atan_:function C$(n){const e={x:N(n,"x","atan")};return R.runKernel(ao,e)}});j().prototype.atan=function(){return this.throwIfDisposed(),S$(this)};const T$=F({atan2_:function I$(n,t){let e=N(n,"a","atan2"),s=N(t,"b","atan2");return[e,s]=Nt(e,s),R.runKernel(lo,{a:e,b:s})}});j().prototype.atan2=function(n){return this.throwIfDisposed(),T$(this,n)};const k$=F({atanh_:function N$(n){const e={x:N(n,"x","atanh")};return R.runKernel(oo,e)}});j().prototype.atanh=function(){return this.throwIfDisposed(),k$(this)},j().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),_h(this,n,t,e,s)},j().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),_p(this,n,t)},j().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),du(this,n,t,e,s,r)},j().prototype.broadcastTo=function(n){return this.throwIfDisposed(),li(this,n)},j().prototype.cast=function(n){return this.throwIfDisposed(),de(this,n)};const $$=F({ceil_:function _$(n){const e={x:N(n,"x","ceil","float32")};return R.runKernel(co,e)}});j().prototype.ceil=function(){return this.throwIfDisposed(),$$(this)},j().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Pn(this,n,t)},j().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Vt&&(n=[n]),dn([this,...n],t)},j().prototype.conv1d=function(n,t,e,s,r,a){return this.throwIfDisposed(),Bg(this,n,t,e,s,r,a)},j().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),Wg(this,n,t,e,s,r)},j().prototype.conv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),Br(this,n,t,e,s,r,a)},j().prototype.cos=function(){return this.throwIfDisposed(),kp(this)},j().prototype.cosh=function(){return this.throwIfDisposed(),tx(this)},j().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),Tp(this,n,t,e)},j().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),qy(this,n,t,e)};const A$=F({depthToSpace_:function E$(n,t,e="NHWC"){const s=N(n,"x","depthToSpace","float32"),r="NHWC"===e?s.shape[1]:s.shape[2],a="NHWC"===e?s.shape[2]:s.shape[3],o="NHWC"===e?s.shape[3]:s.shape[1];return I(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),I(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`),I(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${s.shape}`),I(o%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${s.shape}`),R.runKernel(ld,{x:s},{blockSize:t,dataFormat:e})}});j().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),A$(this,n,t)},j().prototype.depthwiseConv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),hu(this,n,t,e,s,r,a)};const R$=F({dilation2d_:function D$(n,t,e,s,r=[1,1],a="NHWC"){const o=N(n,"x","dilation2d"),i=N(t,"filter","dilation2d");I(3===o.rank||4===o.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),I(3===i.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),I("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=o,u=!1;3===o.rank&&(l=O(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=!0),I(l.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${i.shape[2]}`);const h=R.runKernel(ol,{x:l,filter:i},{strides:e,pad:s,dilations:r});return u?O(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});j().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),R$(this,n,t,e,s,r)};const O$=F({divNoNan_:function F$(n,t){let e=N(n,"a","div"),s=N(t,"b","div");[e,s]=Nt(e,s);const r=Se(e,s),a=je(r),o=vs(s,a);return bn(o,a,r)}});j().prototype.divNoNan=function(n){return this.throwIfDisposed(),O$(this,n)},j().prototype.div=function(n){return this.throwIfDisposed(),Se(this,n)};const L$=F({dot_:function P$(n,t){const e=N(n,"t1","dot"),s=N(t,"t2","dot");I(!(1!==e.rank&&2!==e.rank||1!==s.rank&&2!==s.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${s.rank}.`);const r=1===e.rank?e.size:e.shape[1],a=1===s.rank?s.size:s.shape[0];if(I(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),1===e.rank&&1===s.rank){const o=O(e,[1,-1]),i=O(s,[-1,1]),l=et(o,i);return O(l,[])}if(1===e.rank&&2===s.rank){const o=O(e,[1,-1]),i=O(s,[s.shape[0],s.shape[1]]),l=et(o,i);return O(l,[l.size])}if(2===e.rank&&1===s.rank){const o=O(s,[-1,1]),i=et(e,o);return O(i,[i.size])}{const o=O(s,[s.shape[0],s.shape[1]]);return et(e,o)}}});j().prototype.dot=function(n){return this.throwIfDisposed(),L$(this,n)},j().prototype.elu=function(){return this.throwIfDisposed(),pu(this)},j().prototype.equal=function(n){return this.throwIfDisposed(),vs(this,n)},j().prototype.erf=function(){return this.throwIfDisposed(),Hg(this)};const V$=F({euclideanNorm_:function M$(n,t=null,e=!1){return Tu(n,"euclidean",t,e)}});j().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),V$(this,n,t)},j().prototype.exp=function(){return this.throwIfDisposed(),Ln(this)},j().prototype.expandDims=function(n){return this.throwIfDisposed(),Nn(this,n)};const B$=F({expm1_:function z$(n){const e={x:N(n,"x","expm1")};return R.runKernel(bo,e)}});j().prototype.expm1=function(){return this.throwIfDisposed(),B$(this)},j().prototype.fft=function(){return this.throwIfDisposed(),jh(this)},j().prototype.flatten=function(){return this.throwIfDisposed(),O(this,[this.size])},j().prototype.floor=function(){return this.throwIfDisposed(),fu(this)},j().prototype.floorDiv=function(n){return this.throwIfDisposed(),gg(this,n)},j().prototype.gather=function(n,t,e){return this.throwIfDisposed(),Eh(this,n,t,e)},j().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Wr(this,n)},j().prototype.greater=function(n){return this.throwIfDisposed(),Mn(this,n)},j().prototype.ifft=function(){return this.throwIfDisposed(),bu(this)},j().prototype.irfft=function(){return this.throwIfDisposed(),ey(this)};const U$=F({isFinite_:function W$(n){const e={x:N(n,"x","isFinite")};return R.runKernel(Io,e)}});j().prototype.isFinite=function(){return this.throwIfDisposed(),U$(this)};const H$=F({isInf_:function G$(n){const e={x:N(n,"x","isInf")};return R.runKernel(To,e)}});j().prototype.isInf=function(){return this.throwIfDisposed(),H$(this)};const q$=F({isNaN_:function j$(n){const e={x:N(n,"x","isNaN")};return R.runKernel(No,e)}});j().prototype.isNaN=function(){return this.throwIfDisposed(),q$(this)},j().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Ah(this,n)},j().prototype.lessEqual=function(n){return this.throwIfDisposed(),Ea(this,n)},j().prototype.less=function(n){return this.throwIfDisposed(),Iu(this,n)};const X$=F({localResponseNormalization_:function K$(n,t=5,e=1,s=1,r=.5){const a=N(n,"x","localResponseNormalization");I(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),I(da(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=a,i=!1;3===a.rank&&(i=!0,o=O(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const c=R.runKernel(xl,{x:o},{depthRadius:t,bias:e,alpha:s,beta:r});return i?O(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});j().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),X$(this,n,t,e,s)};const Y$=F({logSigmoid_:function Z$(n){const t=N(n,"x","logSigmoid");return Os(s=>({value:xt(hi(xt(s))),gradFunc:o=>A(o,ka(xt(s)))}))(t)}});j().prototype.logSigmoid=function(){return this.throwIfDisposed(),Y$(this)},j().prototype.logSoftmax=function(n){return this.throwIfDisposed(),qg(this,n)},j().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),Fh(this,n,t)},j().prototype.log=function(){return this.throwIfDisposed(),Xn(this)},j().prototype.log1p=function(){return this.throwIfDisposed(),Dh(this)},j().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ms(this,n)},j().prototype.logicalNot=function(){return this.throwIfDisposed(),Np(this)};const rx=F({logicalOr_:function J$(n,t){const e=N(n,"a","logicalOr","bool"),s=N(t,"b","logicalOr","bool");return Oe(e.shape,s.shape),R.runKernel(yl,{a:e,b:s})}});j().prototype.logicalOr=function(n){return this.throwIfDisposed(),rx(this,n)};const eE=F({logicalXor_:function Q$(n,t){const e=N(n,"a","logicalXor","bool"),s=N(t,"b","logicalXor","bool");return Oe(e.shape,s.shape),Ms(rx(n,t),Np(Ms(n,t)))}});j().prototype.logicalXor=function(n){return this.throwIfDisposed(),eE(this,n)},j().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),et(this,n,t,e)},j().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),Oh(this,n,t,e,s)},j().prototype.max=function(n,t){return this.throwIfDisposed(),os(this,n,t)},j().prototype.maximum=function(n){return this.throwIfDisposed(),or(this,n)},j().prototype.mean=function(n,t){return this.throwIfDisposed(),Dt(this,n,t)},j().prototype.min=function(n,t){return this.throwIfDisposed(),mu(this,n,t)},j().prototype.minimum=function(n){return this.throwIfDisposed(),Na(this,n)};const nE=F({mirrorPad_:function tE(n,t,e){I("reflect"===e||"symmetric"===e,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const s=N(n,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r="reflect"===e?1:0;for(let i=0;i<s.rank;i++)I(2===t[i].length,()=>"Invalid number of paddings. Must be length of 2 each."),I(t[i][0]>=0&&t[i][0]<=s.shape[i]-r&&t[i][1]>=0&&t[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);return R.runKernel(Il,{x:s},{paddings:t,mode:e})}});j().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),nE(this,n,t)};const rE=F({mod_:function sE(n,t){let e=N(n,"a","mod"),s=N(t,"b","mod");return[e,s]=Nt(e,s),R.runKernel(Ao,{a:e,b:s})}});j().prototype.mod=function(n){return this.throwIfDisposed(),rE(this,n)},j().prototype.mul=function(n){return this.throwIfDisposed(),A(this,n)},j().prototype.neg=function(){return this.throwIfDisposed(),xt(this)},j().prototype.norm=function(n,t,e){return this.throwIfDisposed(),Tu(this,n,t,e)},j().prototype.notEqual=function(n){return this.throwIfDisposed(),ui(this,n)},j().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),Xg(this,n,t,e)},j().prototype.onesLike=function(){return this.throwIfDisposed(),Zn(this)},j().prototype.pad=function(n,t){return this.throwIfDisposed(),Lh(this,n,t)};const lE=F({pool_:function aE(n,t,e,s,r,a,o){null==r&&(r=[1,1]),null==a&&(a=1),0===s&&(s="valid");const i=N(n,"x","maxPool");let l=i,u=!1;3===i.rank&&(u=!0,l=O(i,[1,i.shape[0],i.shape[1],i.shape[2]])),I(nn(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const c=Kn(l.shape,t,a,r,s),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===s?function iE(n,t){const s=n.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),a=s.map((o,i)=>o-r[i]);return s.map((o,i)=>[r[i],a[i]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,g]=function oE(n,t,e){const s=e.map(c=>c[0]),r=e.map(c=>c[1]),a=n.concat(s,r),o=t.map((c,d)=>(c-a[d]%c)%c),i=r.map((c,d)=>c+o[d]),l=t.map((c,d)=>[s[d],i[d]]),u=t.map((c,d)=>[0,o[d]]);return[l,u]}([c.inHeight,c.inWidth],d,h),m=p?s:"valid",y=p?l:Ip(l,d,f),b=("avg"===e?()=>_h(y,t,a,m,o):()=>Oh(y,t,a,m,o))(),w=p?b:_p(b,d,g);return u?O(w,[w.shape[1],w.shape[2],w.shape[3]]):w}});j().prototype.pool=function(n,t,e,s,r,a){return this.throwIfDisposed(),lE(this,n,t,e,s,r,a)},j().prototype.pow=function(n){return this.throwIfDisposed(),Vr(this,n)},j().prototype.prelu=function(n){return this.throwIfDisposed(),Mh(this,n)};const cE=F({prod_:function uE(n,t=null,e=!1){let s=N(n,"x","prod");return"bool"===s.dtype&&(s=de(s,"int32")),R.runKernel(Dl,{x:s},{axis:t,keepDims:e})}});j().prototype.prod=function(n,t){return this.throwIfDisposed(),cE(this,n,t)};const hE=F({reciprocal_:function dE(n){const e={x:N(n,"x","reciprocal")};return R.runKernel(Fo,e)}});j().prototype.reciprocal=function(){return this.throwIfDisposed(),hE(this)},j().prototype.relu=function(){return this.throwIfDisposed(),zs(this)},j().prototype.relu6=function(){return this.throwIfDisposed(),ty(this)},j().prototype.reshapeAs=function(n){return this.throwIfDisposed(),O(this,n.shape)},j().prototype.reshape=function(n){return this.throwIfDisposed(),O(this,n)},j().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),uy(this,n,t,e)},j().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),cy(this,n,t,e)},j().prototype.reverse=function(n){return this.throwIfDisposed(),Ur(this,n)},j().prototype.rfft=function(){return this.throwIfDisposed(),qh(this)},j().prototype.round=function(){return this.throwIfDisposed(),dy(this)},j().prototype.rsqrt=function(){return this.throwIfDisposed(),Ky(this)},j().prototype.selu=function(){return this.throwIfDisposed(),Zg(this)},j().prototype.separableConv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),Yg(this,n,t,e,s,r,a)},j().prototype.sigmoid=function(){return this.throwIfDisposed(),ka(this)};const fE=F({sign_:function pE(n){const e={x:N(n,"x","sign")};return R.runKernel(Wo,e)}});j().prototype.sign=function(){return this.throwIfDisposed(),fE(this)},j().prototype.sin=function(){return this.throwIfDisposed(),Hy(this)},j().prototype.sinh=function(){return this.throwIfDisposed(),jy(this)},j().prototype.slice=function(n,t){return this.throwIfDisposed(),it(this,n,t)},j().prototype.softmax=function(n){return this.throwIfDisposed(),Gh(this,n)},j().prototype.softplus=function(){return this.throwIfDisposed(),hi(this)},j().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Ip(this,n,t)},j().prototype.split=function(n,t){return this.throwIfDisposed(),Vn(this,n,t)},j().prototype.sqrt=function(){return this.throwIfDisposed(),cn(this)},j().prototype.square=function(){return this.throwIfDisposed(),pt(this)},j().prototype.squaredDifference=function(n){return this.throwIfDisposed(),fy(this,n)},j().prototype.squeeze=function(n){return this.throwIfDisposed(),pi(this,n)},j().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Vt?[this,n]:[this,...n];return Bs(e,t)},j().prototype.step=function(n){return this.throwIfDisposed(),fi(this,n)};const gE=F({stridedSlice_:function mE(n,t,e,s,r=0,a=0,o=0,i=0,l=0){const c={x:N(n,"x","stridedSlice","string_or_numeric")};return R.runKernel(Od,c,{begin:t,end:e,strides:s,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:l})}});j().prototype.stridedSlice=function(n,t,e,s,r,a,o,i){return this.throwIfDisposed(),gE(this,n,t,e,s,r,a,o,i)},j().prototype.sub=function(n){return this.throwIfDisposed(),ye(this,n)},j().prototype.sum=function(n,t){return this.throwIfDisposed(),ve(this,n,t)};const xE=F({tan_:function yE(n){const e={x:N(n,"x","tan","float32")};return R.runKernel(Ko,e)}});j().prototype.tan=function(){return this.throwIfDisposed(),xE(this)},j().prototype.tanh=function(){return this.throwIfDisposed(),yu(this)},j().prototype.tile=function(n){return this.throwIfDisposed(),as(this,n)},j().prototype.toBool=function(){return this.throwIfDisposed(),de(this,"bool")},j().prototype.toFloat=function(){return this.throwIfDisposed(),de(this,"float32")},j().prototype.toInt=function(){return this.throwIfDisposed(),de(this,"int32")};const wE=F({topk_:function bE(n,t=1,e=!0){const s=N(n,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const a={x:s},o={k:t,sorted:e},[i,l]=R.runKernel(Vd,a,o);return{values:i,indices:l}}});j().prototype.topk=function(n,t){return this.throwIfDisposed(),wE(this,n,t)},j().prototype.transpose=function(n){return this.throwIfDisposed(),qe(this,n)};const CE=F({unique_:function vE(n,t=0){const e=N(n,"x","unique","string_or_numeric");I(e.rank>0,()=>"The input tensor must be at least 1D");const s={x:e},r={axis:t},[a,o]=R.runKernel(Bd,s,r);return{values:a,indices:o}}});j().prototype.unique=function(n){return this.throwIfDisposed(),CE(this,n)},j().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),Xy(this,n,t)},j().prototype.unstack=function(n){return this.throwIfDisposed(),Gr(this,n)},j().prototype.where=function(n,t){return this.throwIfDisposed(),bn(n,this,t)},j().prototype.zerosLike=function(){return this.throwIfDisposed(),je(this)};class Ss extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ss.prototype)}}class Jn extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Jn.prototype)}}class D extends Error{constructor(t){super(t),Object.setPrototypeOf(this,D.prototype)}}class Pe extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Pe.prototype)}}class $p extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$p.prototype)}}Error;class ox{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function qr(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function zn(n,t){if(!n)throw new $p(t)}function ix(n,t){let e=0;for(const s of n)s===t&&e++;return e}function kn(n){return 1===n.length?n[0]:n}function nt(n){return Array.isArray(n)?n:[n]}function js(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Kr(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Qn={};function Ep(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Ap(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>Ap(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];null!=s&&"object"==typeof s&&(Array.isArray(s)||"ndarray"!==s.type||"number"!=typeof s.value?Ap(s):n[e]=s.value)}}}function bi(n,t={},e={},s="object",r=!1){if("string"==typeof n){const a=n;let o;if(a in e)o=e[a];else if(a in Qn)o=Qn[a];else if(o=t[a],null==o)throw new D(`Unknown ${s}: ${n}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}{const a=n;if(null==a.className||null==a.config)throw new D(`${s}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const o=a.className;let i,l;if(o in e?[i,l]=e[o]:o in Qn?[i,l]=Qn.className:o in t&&([i,l]=t[o]),null==i)throw new D(`Unknown ${s}: ${o}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const u={};for(const p of Object.keys(Qn))u[p]=Qn[p];for(const p of Object.keys(e))u[p]=e[p];a.config.customObjects=u;const d=Object.assign({},Qn);for(const p of Object.keys(e))Qn[p]=e[p];Ap(a.config);const h=l(i,a.config,e,r);return Qn=Object.assign({},d),h}{const u=Object.assign({},Qn);for(const d of Object.keys(e))Qn[d]=e[d];const c=new i(a.config);return Qn=Object.assign({},u),c}}}function $u(n,t){return-1*function SE(n,t){return n<t?-1:n>t?1:0}(n,t)}function cr(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function IE(n){if(null==n)throw new D(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Xr(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new D(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function Dp(n,t,e=0,s=1/0){return zn(e>=0),zn(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function Yt(n,t){Array.isArray(n)?(I(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Yt(e,`element ${s+1} of ${t}`))):I(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${lx(n)}.`)}function lx(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>lx(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function ux(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let NE=0;function cx(){return NE++}const Eu={};function Au(n=""){return n in Eu||(Eu[n]=0),Eu[n]+=1,n+Eu[n].toString()}const kE=["channelsFirst","channelsLast"],_E=["nearest","bilinear"],$E=["valid","same","causal"],EE=["max","avg"],AE=["sum","mul","concat","ave"],Aa=new Map;function Rt(n){Xr(kE,"DataFormat",n)}function Bn(n){Xr($E,"PaddingMode",n)}function dx(n){Xr(EE,"PoolMode",n)}const wi=[];function Zr(n,t){wi.push(n);try{const e=t();return wi.pop(),e}catch(e){throw wi.pop(),e}}function px(n){if(!mx(n))throw new Error("Not a valid tensor name: '"+n+"'");return function RE(){return 0===wi.length?"":wi.join("/")+"/"}()+n}function fx(n){if(!mx(n))throw new Error("Not a valid tensor name: '"+n+"'");Aa.has(n)||Aa.set(n,0);const t=Aa.get(n);if(Aa.set(n,Aa.get(n)+1),t>0){const e=`${n}_${t}`;return Aa.set(e,1),e}return n}const FE=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mx(n){return!!n.match(FE)}function OE(n){return n===parseInt(n.toString(),10)}function dr(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function Da(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function hr(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function is(n,t){if(t<n)throw new D(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Du;function Bt(){return null==Du&&(Du=function eg(){return R.backend}().epsilon()),Du}function Is(n,t){return de(n,t)}function vi(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),O(n,e)}function Yr(n,t,e){return L(()=>{switch(n.rank){case 1:return Wh(n,t,e);case 2:return Jg(n,[t,0],[e,n.shape[1]]);case 3:return Uh(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return gu(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return it(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return it(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new D(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Rp(n,t,e){return L(()=>{switch(n.rank){case 1:return Wh(n,t,e);case 2:return Jg(n,[0,t],[n.shape[0],e]);case 3:return Uh(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return gu(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new D(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ru(n,t,e,s){return L(()=>{switch(n.rank){case 1:return Wh(n,t,e);case 2:switch(s){case 1:return Yr(n,t,e);case 2:return Rp(n,t,e);default:throw new D(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Yr(n,t,e);case 2:return Uh(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return Rp(n,t,e);default:throw new D(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Yr(n,t,e);case 2:return gu(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return gu(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return Rp(n,t,e);default:throw new D(`The axis is not within the rank of the tensor ${s}`)}default:throw new D(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Fp(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),dn(n,t)}function yx(n,t){switch(n.rank){case 1:return bI([n,t]);case 2:return vI([n,t],0);case 3:return SI([n,t],0);case 4:return TI([n,t],0);default:throw new D(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Op(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new D(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return as(n,t)}function Fu(n,t=0,e=1,s,r){return vT(n,t,e,s,r)}function Ts(n,t,e,s){if(n.rank<2||t.rank<2)throw new Pe(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Pe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return ry({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Pp(n.rank,s,"channelsLast"):null,activation:e});{const r=n.shape.slice(),a=r.pop();n=O(n,[-1,a]);const o=t.shape.slice(),i=o.pop(),l=o.pop(),u=[...o,i],c=Array.from({length:t.rank},(f,g)=>0===g?t.rank-2:g<=t.rank-2?g-1:g);t=O(qe(t,c),[l,-1]);const d=[...r,...u];return O(ry({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?Pp(n.rank,s,"channelsLast"):null,activation:e}),d)}}function xx(n,t,e){return L(()=>(t=Array.isArray(t)?xn(t,"int32"):de(t,"int32"),Eh(n,t,e)))}function Ci(n){return A(n,n)}function Pp(n,t,e){const s=t.shape;if(1!==t.rank&&t.rank!==n)throw new D(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===n){if("channelsFirst"===e)return O(t,1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===e)return O(t,1===s.length?[1,1,s[0]]:[1].concat(s))}else if(n<3)return t;throw new D(`Unsupported input rank by biasAdd: ${t.rank}`)}function us(n,t,e){return L(()=>(null==e&&(e="channelsLast"),Rt(e),te(n,Pp(n.rank,t,e))))}function bx(n,t,e,s){return L(()=>KT(n,t,e,s))}function Si(n,t,e=!1){return e?n():t()}const GE=["fanIn","fanOut","fanAvg"],HE=["normal","uniform","truncatedNormal"];class es extends Sa{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}ee((()=>{class n extends es{apply(e,s){return Zt(e,s)}}return n.className="Zeros",n})());let wx=(()=>{class n extends es{apply(e,s){return Vs(e,s)}}return n.className="Ones",n})();ee(wx),ee((()=>{class n extends es{constructor(e){if(super(),"object"!=typeof e)throw new D(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new D(`config must have value set but got ${e}`);this.value=e.value}apply(e,s){return L(()=>A(Re(this.value),Vs(e,s)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),ee((()=>{class n extends es{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,s){return ci(e,this.minval,this.maxval,s,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),ee((()=>{class n extends es{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new Pe(`randomNormal does not support dType ${s}.`);return Fu(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),ee((()=>{class n extends es{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new Pe(`truncatedNormal does not support dType ${s}.`);return Qg(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),ee((()=>{class n extends es{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,s){return L(()=>{if(2!==e.length||e[0]!==e[1])throw new D("Identity matrix initializer can only be used for 2D square matrices.");return A(this.gain,jg(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let Wn=(()=>{class n extends es{constructor(e){if(super(),e.scale<0)throw new D(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function jE(n){Xr(GE,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function qE(n){Xr(HE,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,s){const r=function KE(n,t="channelsLast"){let e,s;if(Rt(t),2===n.length)e=n[0],s=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const r=dr(n,2);e=n[1]*r,s=n[0]*r}else if("channelsLast"===t){const r=dr(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=dr(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}(e),a=r[0],o=r[1];let i=this.scale;if(i/="fanIn"===this.mode?Math.max(1,a):"fanOut"===this.mode?Math.max(1,o):Math.max(1,(a+o)/2),"normal"===this.distribution){const l=Math.sqrt(i);if("float32"!==(s=s||"float32")&&"int32"!==s)throw new Pe(`${this.getClassName()} does not support dType ${s}.`);return Qg(e,0,l,s,this.seed)}{const l=Math.sqrt(3*i);return ci(e,-l,l,s,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();ee(Wn);let vx=(()=>{class n extends Wn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="GlorotUniform",n})();ee(vx);let Cx=(()=>{class n extends Wn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="GlorotNormal",n})();ee(Cx);let Sx=(()=>{class n extends Wn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="HeNormal",n})();ee(Sx);let Ix=(()=>{class n extends Wn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="HeUniform",n})();ee(Ix);let Tx=(()=>{class n extends Wn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="LeCunNormal",n})();ee(Tx);let Nx=(()=>{class n extends Wn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return Wn.className}}return n.className="LeCunUniform",n})();ee(Nx),ee((()=>{class n extends es{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,s){return L(()=>{if(e.length<2)throw new Pe("Shape must be at least 2D.");if("int32"!==s&&"float32"!==s&&void 0!==s)throw new TypeError(`Unsupported data type ${s}.`);s=s;const r=W(e.slice(0,-1)),a=e[e.length-1],o=r*a;o>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${o}) elements: Slowness may result.`);const l=Fu([Math.max(a,r),Math.min(a,r)],0,1,s,this.seed),u=Hk.qr(l,!1);let c=u[0];const h=u[1].flatten().stridedSlice([0],[Math.min(a,r)*Math.min(a,r)],[Math.min(a,r)+1]);return c=A(c,h.sign()),r<a&&(c=c.transpose()),A(Re(this.gain),c.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})());const kx={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function _x(n,t={}){return bi(n,qn.getMap().classNameMap,t,"initializer")}function It(n){return Ep(n)}function bt(n){if("string"==typeof n){const t=n in kx?kx[n]:n;if("GlorotNormal"===t)return new Cx;if("GlorotUniform"===t)return new vx;if("HeNormal"===t)return new Sx;if("HeUniform"===t)return new Ix;if("LeCunNormal"===t)return new Tx;if("LeCunUniform"===t)return new Nx;{const e={};return e.className=t,e.config={},_x(e)}}return n instanceof es?n:_x(n)}function Lp(n){return Array.isArray(n)&&Array.isArray(n[0])}function Ou(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function $e(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new D(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function Xe(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return(n=n)[0];throw new D(`Expected exactly 1 Shape; got ${n.length}`)}return n}function Pu(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((s,r)=>s*r);return t}const $x="Variable";class Ns{constructor(t,e="float32",s=$x,r=!0,a=null){this.dtype=null==e?"float32":e,this.shape=t.shape,this.id=cx(),this.originalName=px(s=null==s?$x:s),this.name=fx(this.originalName),this.trainable_=r,this.constraint=a,this.val=function BT(n,t=!0,e,s){return R.makeVariable(n,t,e,s)}(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function XE(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Mp(n){return n.map(t=>t.read())}function Vp(n){n.forEach(t=>{t[0].write(t[1])})}class Wt{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class ks{constructor(t,e,s,r,a,o,i){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=a,this.outputTensorIndex=i,this.id=cx(),null!=o&&(this.originalName=px(o),this.name=fx(this.originalName)),this.rank=e.length}}let ZE=0;class Lu{constructor(t,e){this.callArgs=e,this.id=ZE++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)null!=s&&s.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let YE=0;class We extends Sa{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=YE++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=js(s)+"_"+Au(s)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let s;if(null!=t.batchInputShape)s=t.batchInputShape;else if(null!=t.inputShape){let a=null;null!=t.batchSize&&(a=t.batchSize),s=[a].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;null==r&&(r=t.inputDType),null==r&&(r="float32"),this.dtype=r}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new Jn(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new D(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return kn(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return kn(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ss(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Ss(`Layer ${this.name} is not connected, no input to return.`);return kn(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Ss(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ss(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return kn(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=nt(t);if(null==this.inputSpec||0===this.inputSpec.length)return;const s=nt(this.inputSpec);if(e.length!==s.length)throw new D(`Layer ${this.name} expects ${s.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let r=0;r<e.length;r++){const a=e[r],o=s[r];if(null==o)continue;const i=a.rank;if(null!=o.ndim&&i!==o.ndim)throw new D(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(null!=o.maxNDim&&i>o.maxNDim)throw new D(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(null!=o.minNDim&&i<o.minNDim)throw new D(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(null!=o.dtype&&a.dtype!==o.dtype)throw new D(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${a.dtype}.`);if(o.axes){const l=a.shape;for(const u in o.axes){const c=Number(u),d=o.axes[u],h=c>=0?l[c]:l[l.length+c];if(null!=d&&-1===[d,null].indexOf(h))throw new D(`Input ${r} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(null!=o.shape)for(let l=0;l<o.shape.length;++l){const u=o.shape[l],c=a.shape[l];if(null!=u&&null!=c&&u!==c)throw new D(`Input ${r} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${a.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=nt(t),r=function eA(n){let t=!0;for(const e of nt(n))if(!(e instanceof ks)){t=!1;break}return t}(t),a=function tA(n){let t=!0;for(const e of nt(n))if(e instanceof ks){t=!1;break}return t}(t);if(r===a)throw new D("Arguments to apply() must be all SymbolicTensors or all Tensors");return Zr(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const i of nt(t))o.push(i.shape);this.build(kn(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const i=nt(o),l=[];for(let u of i)-1!==s.indexOf(u)&&(u=u.clone()),l.push(u);if(o=kn(l),null!=this.activityRegularizer)throw new Pe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}{const o=function JE(n){n=nt(n);const t=[];for(const e of n)t.push(e.shape);return kn(t)}(t),i=this.computeOutputShape(o);let l;const u="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),l=null!=i&&i.length>0&&Array.isArray(i[0])?i.map((c,d)=>new ks(u,c,this,nt(t),e,this.name,d)):new ks(u,i,this,nt(t),e,this.name),this.addInboundNode(t,l,null,null,o,i,e),this._refCount++,null!=this.activityRegularizer)throw new Pe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{null!=s&&null!=t[r]&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Ss(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);-1===t.indexOf(s)&&t.push(s)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Ss(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Jn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Pu(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Mp(t?this.trainableWeights:this.weights)}setWeights(t){L(()=>{const e=this.weights;if(e.length!==t.length)throw new D(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const s=[],r=Mp(e);for(let a=0;a<r.length;++a){const o=r[a],i=e[a],l=t[a];if(!Qe(o.shape,l.shape))throw new D(`Layer weight shape ${o.shape} not compatible with provided weight shape ${l.shape}`);s.push([i,l])}Vp(s)})}addWeight(t,e,s,r,a,o,i,l){if(-1!==this._addedWeightNames.indexOf(t))throw new D(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==s&&(s="float32"),this.fastWeightInitDuringBuild&&(r=null!=l?l():bt("zeros"));const u=r.apply(e,s),c=new Ns(u,s,t,o,i);return u.dispose(),null!=a&&this.addLoss(()=>a.apply(c.read())),null==o&&(o=!0),o?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=nt(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(s=>{if(null!=s)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}setMaskMetadata(t,e,s){if(!this.supportsMasking)return;const r=this.computeMask(t,s),a=nt(e),o=nt(r);if(a.length!==o.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let i=0;i<a.length;i++)a[i].kerasMask=o[i]}addInboundNode(t,e,s,r,a,o,i=null){const l=nt(t);e=nt(e),s=nt(s),r=nt(r),a=Ou(a),o=Ou(o);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new Lu({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:a,outputShapes:o},i);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Ex(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const s=t.inboundNodes[e];if(0===s.inboundLayers.length)return s.inputTensors;{const r=[];for(let a=0;a<s.inboundLayers.length;a++){const u=Ex(s.inputTensors[a],s.inboundLayers[a],s.nodeIndices[a]);for(const c of u)-1===r.indexOf(c)&&r.push(c)}return r}}}let Ii=(()=>{class n extends We{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Au("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new D("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let s=e.batchInputShape;if(null==s){if(null==e.inputShape)throw new D("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");s=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new D("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=s,this.dtype=r,this.inputSpec=[{shape:s}];const a=new ks(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Lu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[s],outputShapes:[s]})}apply(e,s){throw new D(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();ee(Ii);class pr{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof pr)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(null!=this.id2Value[t.id])throw new D(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function nA(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return de(t,n.dtype)}catch(e){throw new D(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=s&&(this.id2Mask[t.id]=s),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof ks){if(null==this.id2Value[t.id])throw new D(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new D(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof ks){if(null==this.id2Value[t.id])throw new D(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new D(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&Ue(this.id2Mask)}}const Mu=new ox,Vu=new ox;function Ti(n,t,e,s){const r=null!=e&&e.training,a=Array.isArray(n),o=a?n:[n],i=o.map(f=>f.name),l=[],u=t.names();for(const f of i)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=i.join(",")+"|"+t.names().sort().join(",");let h,d=Mu.get(c);if(null==d){const f=function rA(n,t){I(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(1===n.length){const r=Dx(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of n){const{sorted:o,recipientMap:i}=Dx(a,t);for(const l of o)r.has(l.name)||(e.push(l),r.add(l.name));for(const l in i)null==s[l]&&(s[l]=new Set),i[l].forEach(u=>s[l].add(u))}}return{sorted:e,recipientCounts:aA(s)}}(o,t);d=f.sorted,h=f.recipientCounts,Mu.put(c,d),Vu.put(c,h)}h={},r||Object.assign(h,Vu.get(c));const p=new pr(t);for(let f=0;f<d.length;++f){if(null!=s){const $=Yd().numTensors;$>s.maxNumTensors&&(s.maxNumTensors=$),$<s.minNumTensors&&(s.minNumTensors=$)}const g=d[f],m=g.sourceLayer;if(m instanceof Ii)continue;const y=[],x=[],b=[];let w=!1;for(const $ of g.inputs){const E=p.getValue($),P=p.getMask($);y.push(E),x.push(P),null!=P&&(w=!0),r||(h[$.name]--,0===h[$.name]&&!t.hasKey($)&&-1===i.indexOf($.name)&&!E.isDisposed&&!0!==$.sourceLayer.stateful&&b.push(E))}w&&((e=e||{}).mask=x[0]);const C=nt(m.apply(y,e));let S=null;m.supportsMasking&&(S=m.computeMask(y,x));const T=oA(g),k=Array.isArray(T)?T:[T];for(let $=0;$<k.length;++$){p.hasKey(k[$])||p.add(k[$],C[$],Array.isArray(S)?S[0]:S);const E=i.indexOf(k[$].name);-1!==E&&(l[E]=C[$])}r||Ue(b)}return p.disposeMasks(),a?l:l[0]}function aA(n){const t={};for(const e in n)t[e]=n[e].size;return t}function Dx(n,t){const e=new Set,s=[],r={};for(const i of t.names())e.add(i);const a=[],o=[];for(a.push(n);a.length>0;){const i=a[a.length-1];if(e.has(i.name)){a.pop();continue}const l=o[o.length-1]===a.length-1;if(0===i.inputs.length||l)a.pop(),s.push(i),e.add(i.name),l&&o.pop();else{o.push(a.length-1);for(const u of i.inputs)null==r[u.name]&&(r[u.name]=new Set),r[u.name].add(i.name),!e.has(u.name)&&a.push(u)}}return{sorted:s,recipientMap:r}}function oA(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}function zp(n,t){return L(()=>cn(ve(A(n,n),t,!0)))}V().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function sA(n){null!=Mu&&Mu.setMaxEntries(n),null!=Vu&&Vu.setMaxEntries(n)});class Ni extends Sa{getConfig(){return{}}}ee((()=>{class n extends Ni{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return L(()=>{const s=zp(e,this.axis),r=Pn(s,0,this.maxValue);return A(e,Se(r,te(Bt(),s)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})()),ee((()=>{class n extends Ni{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return L(()=>Se(e,te(Bt(),zp(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})()),ee((()=>{class n extends Ni{apply(e){return zs(e)}}return n.className="NonNeg",n})()),ee((()=>{class n extends Ni{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return L(()=>{const s=zp(e,this.axis),r=te(A(this.rate,Pn(s,this.minValue,this.maxValue)),A(1-this.rate,s));return A(e,Se(r,te(Bt(),s)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})());const Rx={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ut(n){return Ep(n)}function Fx(n,t={}){return bi(n,qn.getMap().classNameMap,t,"constraint")}function Gt(n){return null==n?null:"string"==typeof n?Fx({className:n in Rx?Rx[n]:n,config:{}}):n instanceof Ni?n:Fx(n)}function fr(n){return Bp.apply(this,arguments)}function Bp(){return(Bp=Z(function*(n){if(null==n)return;const t=[],e=[],s=[];for(const r in n){const a=n[r];if("number"!=typeof a){const o=a;t.push(o.data()),e.push(r),s.push(o)}}if(t.length>0){const r=yield Promise.all(t);for(let a=0;a<r.length;++a)n[e[a]]=r[a][0];Ue(s)}})).apply(this,arguments)}function Ox(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Ra{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return Z(function*(){})()}onEpochEnd(t,e){return Z(function*(){})()}onBatchBegin(t,e){return Z(function*(){})()}onBatchEnd(t,e){return Z(function*(){})()}onTrainBegin(t){return Z(function*(){})()}onTrainEnd(t){return Z(function*(){})()}setModel(t){}}class lA{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var s=this;return Z(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochBegin(t,e)})()}onEpochEnd(t,e){var s=this;return Z(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochEnd(t,e)})()}onBatchBegin(t,e){var s=this;return Z(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchBegin(t,e)})()}onBatchEnd(t,e){var s=this;return Z(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return Z(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return Z(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainEnd(t)})()}}class uA extends Ra{constructor(){super()}onEpochBegin(t){var e=this;return Z(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var s=this;return Z(function*(){null==e&&(e={});const r=null==e.size?0:e.size;s.seen+=r;for(const a in e){const o=e[a];if("number"==typeof o)s.totals.hasOwnProperty(a)||(s.totals[a]=0),s.totals[a]=s.totals[a]+o*r;else{let i;a in s.totals?i=s.totals[a]:s.totals[a]=0;const l=L(()=>te(s.totals[a],A(o,r)));s.totals[a]=l,null!=i&&i.dispose()}}})()}onEpochEnd(t,e){var s=this;return Z(function*(){if(null!=e)for(const r of s.params.metrics)null!=s.totals[r]&&("number"==typeof s.totals[r]?e[r]=s.totals[r]/s.seen:L(()=>{const a=A(Se(1,s.seen),s.totals[r]);e[r]=a,s.totals[r].dispose(),bs(e[r])}))})()}}class cA extends Ra{onTrainBegin(t){var e=this;return Z(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var s=this;return Z(function*(){null==e&&(e={}),s.epoch.push(t);for(const r in e)null==s.history[r]&&(s.history[r]=[]),s.history[r].push(e[r])})()}syncData(){var t=this;return Z(function*(){const e=[],s=[],r=[];for(const o in t.history){const i=t.history[o];for(let l=0;l<i.length;++l)"number"!=typeof i[l]&&(e.push(i[l].data()),s.push(o),r.push(l))}const a=yield Promise.all(e);for(let o=0;o<a.length;++o)t.history[s[o]][r[o]].dispose(),t.history[s[o]][r[o]]=a[o][0]})()}}class dA extends Ra{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||my,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Bc(this.yieldEvery)&&(this.maybeWait=function TE(n,t,e){let r,s=null!=e?e():In();return(...o)=>{const i=null!=e?e():In();return i-s<t||(s=i,r=n(...o)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,s){var r=this;return Z(function*(){const a=[];null!=r.yield&&(yield fr(s),a.push(r.yield(t,e,s))),a.push(r.nextFrameFunc()),yield Promise.all(a)})()}onEpochBegin(t,e){var s=this;return Z(function*(){s.currentEpoch=t,null!=s.epochBegin&&(yield fr(e),yield s.epochBegin(t,e))})()}onEpochEnd(t,e){var s=this;return Z(function*(){const r=[];null!=s.epochEnd&&(yield fr(e),r.push(s.epochEnd(t,e))),"epoch"===s.yieldEvery&&r.push(s.nextFrameFunc()),yield Promise.all(r)})()}onBatchBegin(t,e){var s=this;return Z(function*(){null!=s.batchBegin&&(yield fr(e),yield s.batchBegin(t,e))})()}onBatchEnd(t,e){var s=this;return Z(function*(){const r=[];null!=s.batchEnd&&(yield fr(e),r.push(s.batchEnd(t,e))),"batch"===s.yieldEvery?r.push(s.nextFrameFunc()):Bc(s.yieldEvery)&&r.push(s.maybeWait(s.currentEpoch,t,e)),yield Promise.all(r)})()}onTrainBegin(t){var e=this;return Z(function*(){null!=e.trainBegin&&(yield fr(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return Z(function*(){null!=e.trainEnd&&(yield fr(t),yield e.trainEnd(t))})()}}function Px(n,t){return null==n&&(n={}),n instanceof Ra?[n]:Array.isArray(n)&&n[0]instanceof Ra?n:nt(n).map(s=>new dA(s,t))}let hA=(()=>{class n{constructor(){}static registerCallbackConstructor(e,s){I(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(s),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(s)}static checkForDuplicate(e){for(const s in n.constructors)n.constructors[+s].forEach(a=>{if(a===e)throw new D("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const s=[];for(const r in n.constructors){const a=+r;e>=a&&s.push(...n.constructors[a])}return s.map(r=>new r)}}return n.constructors={},n})();function Lx(n,t,e,s,r,a,o,i,l){const u=new cA,c=[new uA,...hA.createCallbacks(t)];null!=n&&c.push(...n),c.push(u);const d=new lA(c);return d.setParams({epochs:e,initialEpoch:s,samples:r,steps:a,batchSize:o,verbose:t,doValidation:i,metrics:l}),{callbackList:d,history:u}}function qs(n,t={},e=!1){return bi(n,qn.getMap().classNameMap,t,"layer",e)}function zu(n,t){return L(()=>{"float32"!==n.dtype&&(n=de(n,"float32"));const e=ve(Ci(n),t,!0),s=si(e.shape,Bt()),r=cn(or(e,s));return Se(n,r)})}function Bu(n,t){return L(()=>Dt(Ci(ye(t,n)),-1))}function Wp(n,t){return L(()=>Dt(qt(ye(t,n)),-1))}function Up(n,t){return L(()=>{const e=ye(n,t),s=Pn(qt(n),Bt(),Number.MAX_VALUE),r=qt(Se(e,s));return A(100,Dt(r,-1))})}function ki(n,t,e=!1){return L(()=>{if(e)t=Gh(t);else{const s=ve(t,t.shape.length-1,!0);t=Se(t,s)}return t=Pn(t,Bt(),1-Bt()),xt(ve(A(de(n,"float32"),Xn(t)),t.shape.length-1))})}function Wu(n,t,e=!1){return L(()=>{const s=de(fu(function VE(n){const t=[dr(n.shape)];return O(n,t)}(n)),"int32"),r=(t=Pn(t,Bt(),1-Bt())).shape;return ki(O(Xg(s,r[r.length-1]),r),t,e)})}function Uu(n,t){return L(()=>{let e;return e=Pn(t,Bt(),1-Bt()),e=Xn(Se(e,ye(1,e))),Dt(function xA(n,t){if(!Qe(n.shape,t.shape))throw new D(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return L(()=>{const e=zs(t),s=xt(qt(t));return te(ye(e,A(t,n)),Dh(Ln(s)))})}(n,e),-1)})}function Mx(n,t){return L(()=>{const e=zu(n,-1),s=zu(t,-1),r=A(e,s);return xt(ve(r,-1))})}const Gu={meanSquaredError:Bu,meanAbsoluteError:Wp,meanAbsolutePercentageError:Up,meanSquaredLogarithmicError:function pA(n,t){return L(()=>{const e=Pn(t,Bt(),Number.MAX_VALUE),s=Xn(te(1,e)),r=Pn(n,Bt(),Number.MAX_VALUE),a=Xn(te(1,r));return Dt(Ci(ye(s,a)),-1)})},squaredHinge:function fA(n,t){return L(()=>{const e=or(0,ye(1,A(n,t)));return Dt(Ci(e),-1)})},hinge:function mA(n,t){return L(()=>{const e=or(0,ye(1,A(n,t)));return Dt(e,-1)})},categoricalHinge:function gA(n,t){return L(()=>{const e=ve(A(n,t),-1),s=os(A(ye(1,n),t),-1);return or(0,te(1,ye(s,e)))})},logcosh:function yA(n,t){return L(()=>{const e=Math.log(2),s=ye(t,n),r=ye(te(s,hi(A(-2,s))),e);return Dt(r,-1)})},categoricalCrossentropy:ki,sparseCategoricalCrossentropy:Wu,binaryCrossentropy:Uu,kullbackLeiblerDivergence:function bA(n,t){return L(()=>{const e=Pn(n,Bt(),1),s=Pn(t,Bt(),1);return ve(A(n,Xn(Se(e,s))),-1)})},poisson:function wA(n,t){return L(()=>{const e=Xn(te(Bt(),t));return Dt(ye(t,A(n,e)),-1)})},cosineProximity:Mx};function Gp(n){if("string"==typeof n){if(n in Gu)return Gu[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new D(t)}return n}function Vx(n,t){return L(()=>{const e=A(.5,Zn(t)),s=Is(Mn(t,e),n.dtype);return Dt(vs(n,s),-1)})}function zx(n,t){return L(()=>Is(vs(ri(n,-1),ri(t,-1)),"float32"))}function IA(n,t){return Uu(n,t)}function TA(n,t){return n.rank===t.rank&&(n=pi(n,[n.rank-1])),(t=ri(t,-1)).dtype!==n.dtype&&(t=de(t,n.dtype)),de(vs(n,t),"float32")}const Wx=ki,Ux=Wu,Hu={binaryAccuracy:Vx,categoricalAccuracy:zx,precision:function SA(n,t){return L(()=>{const e=function Bx(n,t){return L(()=>de(ve(Ms(vs(n,1),vs(t,1))),"float32"))}(n,t),s=function CA(n,t){return L(()=>de(ve(Ms(vs(n,0),vs(t,1))),"float32"))}(n,t),r=te(e,s);return de(bn(Mn(r,0),Se(e,r),0),"float32")})},categoricalCrossentropy:Wx,sparseCategoricalCrossentropy:Ux,mse:Bu,MSE:Bu,mae:Wp,MAE:Wp,mape:Up,MAPE:Up,cosine:Mx};function RA(n){if("string"==typeof n&&n in Hu)return Hu[n];if("string"!=typeof n&&null!=n)return n;throw new D(`Unknown metric ${n}`)}function ju(n){if(zn(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(Gu))if(Gu[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(Hu))if(Hu[e]===n){t=e;break}return void 0!==t?t:n.name}}function Hx(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!Hp(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function Hp(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!Hp(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!Hp(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function qu(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function MA(n,t,e){let s,r;try{r=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch(l){r="multiple"}try{s=JSON.stringify(n.outputShape)}catch(l){s="multiple"}qu([`${n.name} (${n.getClassName()})`,r,s,n.countParams().toString()],t,e)}function VA(n,t,e,s){let r,a;try{a=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch(d){a="multiple"}try{r=JSON.stringify(n.outputShape)}catch(d){r="multiple"}const o=[];for(const d of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(d)))for(let h=0;h<d.inboundLayers.length;++h)o.push(`${d.inboundLayers[h].name}[${d.nodeIndices[h]}][${d.tensorIndices[h]}]`);const i=n.name,l=n.getClassName(),u=0===o.length?"":o[0];qu([`${i} (${l})`,a,r,n.countParams().toString(),u],t,s);for(let d=1;d<o.length;++d)qu(["","","","",o[d]],t,s)}function jx(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function jp(n,t){if(null===n)return null;if("string"==typeof n)return Kr(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];jx(t,r,a)?e.push(a):e.push(jp(a,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];if("name"===s&&"string"==typeof r)e[s]=r;else{const a=Kr(s);e[a]=jp(r,a)}}return e}}function qp(n,t){if(null==n)return null;if("string"==typeof n)return js(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];jx(t,r,a)?e.push(a):e.push(qp(a,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];e[js(s)]="name"!==s&&"className"!==s||"string"!=typeof r?qp(r,s):r}return e}}class cs extends We{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const x=this.getClassName().toLowerCase();this.name=Au(x)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],cr(this.inputs).length!==this.inputs.length)throw new D(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);cr(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const x of this.outputs){const w=x.nodeIndex,C=x.tensorIndex;this.outputLayers.push(x.sourceLayer),this.outputLayersNodeIndices.push(w),this.outputLayersTensorIndices.push(C)}for(const x of this.inputs){const b=x.sourceLayer,w=x.nodeIndex,C=x.tensorIndex;zn(0===w,"input layer has >1 nodes"),zn(0===C,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(w),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){const b=this.inputLayers[x];if(!(b instanceof Ii))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${x} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);const e={},s={},r={},a={},o={},i=[],l=(x,b,w,C,S,T)=>{(null==C||null==S||null==T)&&(C=x.sourceLayer,S=x.nodeIndex,T=x.tensorIndex);const k=C.inboundNodes[S];if(-1!==w.indexOf(k))throw new Jn(`The tensor ${x.name} at layer "${C.name}" is part of a cycle.`);if(-1!==b.indexOf(k))return;this.containerNodes.add(cs.nodeKey(C,S)),C.id in o||(o[C.id]=Object.keys(o).length),-1===w.indexOf(k)&&w.push(k);const $=k.inboundLayers.length;for(let E=0;E<$;E++)l(k.inputTensors[E],b,w,k.inboundLayers[E],k.nodeIndices[E],k.tensorIndices[E]);for(b.push(k);w.indexOf(k)>=0;)w.splice(w.indexOf(k),1);i.push(k)},u=[],c=[];for(const x of this.outputs)l(x,u,c);const d=i.slice().reverse();for(const x of d){s[x.id]=x,x.id in e||(e[x.id]=0);let b=e[x.id];b=Math.max(b,null==r[x.outboundLayer.id]?0:r[x.outboundLayer.id]),r[x.outboundLayer.id]=b,a[x.outboundLayer.id]=x.outboundLayer,e[x.id]=b;for(let C=0;C<x.inboundLayers.length;C++){const k=x.inboundLayers[C].inboundNodes[x.nodeIndices[C]];e[k.id]=Math.max(b+1,null==e[k.id]?0:e[k.id]),s[k.id]=k}}const h={};for(const x in e){const b=e[x];b in h||(h[b]=[]),h[b].push(s[x])}const p={};for(const x in r){const b=r[x];b in p||(p[b]=[]),p[b].push(a[x])}let f=Object.keys(p).map(x=>parseInt(x,10)).sort($u);this.layers=[];for(const x of f){const b=p[x];b.sort((w,C)=>{const S=o[w.id],T=o[C.id];return S<T?-1:S>T?1:0});for(const w of b)w instanceof cs&&this.internalContainerRefs.push(w),this.layers.push(w)}this.layersByDepth=p,f=Object.keys(h).map(x=>parseInt(x,10)).sort($u);const g=this.inputs.slice(),m=[];for(const x of f)for(const b of h[x]){const w=b.outboundLayer;if(null!=w){for(const C of b.inputTensors)if(-1===g.indexOf(C))throw new Jn(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${w.name}". The following previous layers were accessed without issue: ${m}`);for(const C of b.outputTensors)g.push(C);m.push(w.name)}}this.nodesByDepth=h;const y=this.layers.map(x=>x.name);for(const x of y){const b=y.filter(w=>w===x).length;if(1!==b)throw new Jn(`The name "${x}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Lu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new D("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;const a=(n=>{const t=Object.keys(n);if(0===t.length)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))})(t);a&&this.parseWeights(t);for(const i of this.layers)for(const[l,u]of i.weights.entries()){const c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(null!=s[c])throw new D(`Duplicate weight name: ${c}`);s[c]=u,r++}const o=[];for(const i in t){let l=i;if(null==s[i]){const u=i.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=s[l])o.push([s[l],t[i]]);else if(e)throw new D(`Provided weight data has no target variable: ${i}`);delete s[l]}if(e){const i=[];for(const l in s)i.push(l);if(i.length>0)throw new D(`${i.length} of ${r} weights are not set: ${i}`)}Vp(o)}parseWeights(t){for(const e in Object.keys(t)){const s=e.split("/"),r=["vars","layer_checkpoint_dependencies"],a=s.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!r.includes(o)).join("/");a!==e&&(t[a]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.19.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=qp(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return L(()=>{t=nt(t);const s=new pr;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return Ti(this.outputs,s,e)})}computeMask(t,e){return L(()=>{let s;return t=nt(t),s=null==e?qr(null,t.length):nt(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=Ou(t);if(e.length!==this.inputLayers.length)throw new D(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let i=0;i<e.length;i++)s[this.inputLayers[i].name+"_0_0"]=e[i];const r=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort($u);if(r.length>1)for(const i of r){const l=this.nodesByDepth[i];for(const u of l){const c=u.outboundLayer;if(-1!==this.inputLayers.map(g=>g.id).indexOf(c.id))continue;const d=[];for(let g=0;g<u.inboundLayers.length;g++)d.push(s[`${u.inboundLayers[g].name}_${u.nodeIndices[g]}_${u.tensorIndices[g]}`]);const p=Ou(c.computeOutputShape(kn(d))),f=c.inboundNodes.indexOf(u);for(let g=0;g<p.length;g++)s[`${c.name}_${f}_${g}`]=p[g]}}const a=[],o=[];for(let i=0;i<this.outputLayers.length;i++)o.push(`${this.outputLayers[i].name}_${this.outputLayersNodeIndices[i]}_${this.outputLayersTensorIndices[i]}`);for(let i=0;i<o.length;i++){const l=o[i];zn(l in s),a.push(s[l])}return kn(a)}runInternalGraph(t,e){null==e&&(e=qr(null,t.length));const s={};for(let l=0;l<this.inputs.length;++l)s[this.inputs[l].id]=[t[l],e[l]];const r=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort($u);for(const l of r){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const g of h)g.id in s&&f.push(s[g.id]);if(f.length===h.length){let m,y,x,b,g={};if(null!=c.callArgs&&(g=c.callArgs),1===f.length){const[w,C]=f[0];null==g.mask&&(g.mask=C),x=nt(d.call(w,g)),b=nt(d.computeMask(w,C)),m=[w],y=[C]}else m=f.map(w=>w[0]),y=f.map(w=>w[1]),null==g.mask&&(g.mask=y),x=nt(d.call(m,g)),b=nt(d.computeMask(m,y));if(d.activityRegularizer)throw new Pe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let w=0;w<p.length;++w)s[p[w].id]=[x[w],b[w]]}}}const a=[],o=[],i=[];for(const l of this.outputs){zn(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=s[l.id];i.push(u.shape),a.push(u),o.push(c)}return[a,o,i]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof cs?1:0;for(let a=0;a<r.inboundNodes.length;a++){const o=cs.nodeKey(r,a);this.containerNodes.has(o)&&(e[o]=s,s+=1)}}return e}getLayer(t,e){if(null!=e)return this.findLayer(e);if(null==t)throw new D("Provide either a layer name or layer index");if("number"==typeof t)return this.findLayer(t);for(const s of this.layers)if(s.name===t)return s;throw new D(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new D(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return L(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=cs.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const o of this.layers){const i=o.getClassName(),l=o.getConfig(),u=[];for(let d=0;d<o.inboundNodes.length;d++){const h=o.inboundNodes[d],p=cs.nodeKey(o,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch(g){console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const g=[];for(let m=0;m<h.inboundLayers.length;m++){const y=h.inboundLayers[m],b=h.tensorIndices[m];let C=e[cs.nodeKey(y,h.nodeIndices[m])];null==C&&(C=0),g.push([y.name,C,b,f])}u.push(g)}}}const c={};c.name=o.name,c.className=i,c.config=l,c.inboundNodes=u,s.push(c)}t.layers=s;const r=[];for(let o=0;o<this.inputLayers.length;o++){const i=this.inputLayers[o],u=cs.nodeKey(i,this.inputLayersNodeIndices[o]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),r.push([i.name,c,this.inputLayersTensorIndices[o]])}t.inputLayers=r;const a=[];for(let o=0;o<this.outputLayers.length;o++){const i=this.outputLayers[o],u=cs.nodeKey(i,this.outputLayersNodeIndices[o]);if(!this.containerNodes.has(u))continue;let c=e[u];null==c&&(c=0),a.push([i.name,c,this.outputLayersTensorIndices[o]])}return t.outputLayers=a,t}static fromConfig(t,e,s={},r=!1){const a={},o={};function i(m,y){m.name in o?o[m.name].push(y):o[m.name]=[y]}function l(m,y){const x=[];let b;for(const w of y){const C=w[0],S=w[1],T=w[2];if(b=null==w[3]?{}:w[3],!(C in a))return void i(m,y);const k=a[C];if(k.inboundNodes.length<=S)return void i(m,y);x.push(k.inboundNodes[S].outputTensors[T])}x.length>0&&m.apply(kn(x),b)}function u(m){const y=m.name,x=qs(m,null!=e.customObjects?e.customObjects:{});x.setFastWeightInitDuringBuild(r),a[y]=x,m.inboundNodes.forEach(w=>{if(!(w instanceof Array))throw new D(`Corrupted configuration, expected array for nodeData: ${w}`);i(x,w)})}const c=e.name,d=e.layers;for(const m of d)u(m);for(;!IE(o);)for(const m of d){const y=a[m.name];if(y.name in o){const x=o[y.name];delete o[y.name];for(const b of x)l(y,b)}}const h=[],p=[],f=e.inputLayers;for(const m of f){const y=m[0],x=m[1],b=m[2];zn(y in a),h.push(a[y].inboundNodes[x].outputTensors[b])}const g=e.outputLayers;for(const m of g){const y=m[0],x=m[1],b=m[2];zn(y in a),p.push(a[y].inboundNodes[x].outputTensors[b])}return new t({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new D("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){L(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Kx(n,t){return function qx(n,t,e){const s=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>null);if(1===s)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const r=[];return t.forEach(a=>{r.push(a in n?n[a]:null)}),r}throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function Xx(n,t,e,s){return Xp.apply(this,arguments)}function Xp(){return(Xp=Z(function*(n,t,e,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const r=L(()=>{if(1===n.shape.length)return Mr(n);if(2===n.shape.length){if(n.shape[1]>1)return ri(n,1);if(1===n.shape[1])return O(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(yield r.data());Ue(r);const o=[];return a.forEach(i=>{if(null==e[i])throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);o.push(e[i])}),xn(o,"float32")}return null})).apply(this,arguments)}function BA(n,t){return A(n,t)}function Zx(n,t){let e,s;e=t.xs,s=t.ys,I(null!=e&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=Yx("input",n.inputNames,e),o=Yx("output",n.outputNames,s),i=a[0].shape[0];I(a.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),I(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<a.length;l++)I(a[l].shape[0]===i,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${a[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);for(let l=0;l<o.length;l++)I(o[l].shape[0]===i,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${o[l].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);return{xs:a,ys:o}}function Yx(n,t,e){if(e instanceof Vt)return[e];if(Array.isArray(e))return I(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(null==e[r])throw new D(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function UA(n){if(3===n.length)throw new Pe("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}function Zp(){return(Zp=Z(function*(n,t,e){const s=null!=e.batchesPerEpoch;if(I(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),I(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),I(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),I(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),I(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=null!=e.validationData;let a,o;if(r)if(Jx(e.validationData))I(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const m=UA(e.validationData);a=m.xs,o=m.ys}const i=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map(m=>"val_"+m)):l.slice();const c=Px(e.callbacks,e.yieldEvery),d=null==e.verbose?1:e.verbose,{callbackList:h,history:p}=Lx(c,d,e.epochs,null,null,HA(t,e),null,r,u);h.setModel(n),n.history=p,yield h.onTrainBegin(),n.stopTraining_=!1;let f=null==e.initialEpoch?0:e.initialEpoch,g=yield t.iterator();for(;f<e.epochs;){const m={};yield h.onEpochBegin(f);let y=0,x=0;for(s||(g=yield t.iterator());!s||y<e.batchesPerEpoch;){const b=yield g.next();if(s&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=b.value){const{xs:w,ys:C}=Zx(n,b.value),S={};S.batch=x,S.size=w[0].shape[0],yield h.onBatchBegin(x,S);const T=[];if(null!=e.classWeight){const E=Kx(e.classWeight,n.outputNames);for(let P=0;P<E.length;++P)T.push(yield Xx(C[P],null,E[P]))}const k=w.concat(C).concat(T),$=i(k);Ue(k);for(let E=0;E<l.length;++E){const z=$[E];S[l[E]]=z,bs(z)}yield h.onBatchEnd(x,S),Ox(S),x++,y++}if(s?y>=e.batchesPerEpoch:b.done){if(r){let w;w=Jx(e.validationData)?nt(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):nt(n.evaluate(a,o,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let C=0;C<n.metricsNames.length;++C)m[`val_${n.metricsNames[C]}`]=w[C]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(f,m),f++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function HA(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function Jx(n){return"function"==typeof n.iterator}function jA(n){return"function"==typeof n.next}function Yp(){return(Yp=Z(function*(n,t,e){const s=null!=(e=e||{}).batches,r=n.testFunction;let a=[];if(e.verbose>0)throw new Pe("Verbose mode is not implemented yet.");I(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=jA(t)?t:yield t.iterator();let i=0,l=0;for(;!s||l<e.batches;){const u=yield o.next();if(a=L(()=>{if(u.value){const{xs:c,ys:d}=Zx(n,u.value),h=c.concat(d),p=L(()=>r(h));if(Ue(h),0===l)for(let g=0;g<p.length;++g)a.push(Re(0));const f=h[0].shape[0];for(let g=0;g<p.length;++g){const m=p[g],y=a[g];a[g]=L(()=>te(a[g],A(f,m))),l>0&&Ue(y)}Ue(p),i+=f,++l}return a}),u.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const c=a[u];a[u]=Se(a[u],i),Ue(c)}return kn(a)})).apply(this,arguments)}function Jp(n){I(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function _i(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(s=>Yr(s,t,e-t)):Yr(n,t,e-t)}function Qp(n,t){return L(()=>null==n?null:Array.isArray(n)?n.map(e=>Qp(e,t)):xx(n,"int32"===t.dtype?t:de(t,"int32")))}function ef(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function Qx(n){const t=[];n instanceof Vt&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(1===s.rank)t.push(vi(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function ds(n,t){if(null==n)return;const e=[];if(t instanceof Vt)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(null!=t)for(const r in t)e.push(t[r].id);const s=[];if(n instanceof Vt)-1===e.indexOf(n.id)&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{-1===e.indexOf(r.id)&&s.push(r)});else if(null!=n)for(const r in n){const a=n[r];-1===e.indexOf(a.id)&&s.push(a)}s.forEach(r=>{r.isDisposed||r.dispose()})}function nf(n){return Array.isArray(n)}function eb(n){return!function KA(n){return n instanceof Vt}(n)&&!nf(n)}function tb(n,t,e,s=!0,r=""){if(null==t||0===t.length){if(null!=n){let o=!1;if(nf(n)&&n.length>0)o=!0;else if(eb(n)){for(const i in n)if(n.hasOwnProperty(i)){o=!0;break}}else o=!0;if(o)throw new D(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(o=>null);let a;if(eb(n)){n=n,a=[];for(const o of t){if(null==n[o])throw new D(`No data provided for "${o}". Need data for each key in: ${t}`);a.push(n[o])}}else if(nf(n)){if((n=n).length!==t.length)throw new D(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);a=n}else{if(n=n,t.length>1)throw new D(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);a=[n]}if(a=Qx(a),null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const i=a[o];if(i.shape.length!==e[o].length)throw new D(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${i.shape}`);for(let l=0;l<e[o].length;++l){if(0===l&&!s)continue;const u=i.shape[l],c=e[o][l];if(null!=c&&c>=0&&u!==c)throw new D(`${r} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${r} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function nb(n,t,e,s=!0,r=""){let a;if(Array.isArray(n)){if(n.length!==t.length)throw new D(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);a=n}else{if(t.length>1)throw new D(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);a=[n]}if(null!=e)for(let o=0;o<t.length;++o){if(null==e[o])continue;const i=a[o];if(i.shape.length!==e[o].length)throw new D(`Error when checking ${r}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let l=0;l<e[o].length;++l){if(0===l&&!s)continue;const u=i.shape[l],c=e[o][l];if(null!=c&&c!==u)throw new D(`Error when checking ${r}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}let Fa=(()=>{class n extends cs{constructor(e){super(e),this.isTraining=!1}summary(e,s,r=console.log){if(!this.built)throw new D("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function OA(n,t,e,s=console.log){const r=function LA(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let a=!1;for(const o of r.inboundNodes)if(-1!==s.indexOf(o)){if(a){t=!1;break}a=!0}if(!t)break}return t}(n),a=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(c=>Math.floor(t*c))),!r){a.push("Receives inputs"),o=[];for(const c in n.nodesByDepth)o.push(...n.nodesByDepth[c])}s("_".repeat(t)),qu(a,e,s),s("=".repeat(t));const i=n.layers;for(let c=0;c<i.length;++c)r?MA(i[c],e,s):VA(i[c],e,o,s),s((c===i.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const l=function PA(n){let t;return t=Pu(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),u=Pu(n.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(t))}(this,e,s,r)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function FA(n){const t={Adagrad:()=>Hr.adagrad(.01),Adadelta:()=>Hr.adadelta(1,.95,Bt()),Adam:()=>Hr.adam(.001,.9,.999,Bt()),Adamax:()=>Hr.adamax(.002,.9,.999,Bt(),0),RMSProp:()=>Hr.rmsprop(.001,.9,0,Bt()),SGD:()=>Hr.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new D(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ar))throw new D("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let s=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new D(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);s=e.loss.map(l=>Gp(l))}else{const i=Gp(e.loss);this.outputs.forEach(l=>{s.push(i)})}else{e.loss=e.loss;for(const i in e.loss)if(-1===this.outputNames.indexOf(i))throw new D(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)null==e.loss[i]&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),s.push(Gp(e.loss[i]))}this.lossFunctions=s,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const l=this.internalOutputShapes[i];this.feedOutputNames.push(this.outputNames[i]),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Zr("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(-1!==r.indexOf(i))continue;const l=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([l,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const a=function YA(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let a=e.hasOwnProperty(r)?e[r]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}(e.metrics,this.outputNames),o=(i,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[i]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,i])};Zr("metric",()=>{for(let i=0;i<this.outputs.length;++i)-1===r.indexOf(i)&&(c=>{let h,p,f;for(const g of c){if("string"==typeof g&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(g)){const y=this.internalOutputShapes[i];let x;1===y[y.length-1]||this.lossFunctions[i]===Uu?-1!==["accuracy","acc"].indexOf(g)?p=Vx:-1!==["crossentropy","ce"].indexOf(g)&&(p=IA):this.lossFunctions[i]===Wu?-1!==["accuracy","acc"].indexOf(g)?p=TA:-1!==["crossentropy","ce"].indexOf(g)&&(p=Ux):-1!==["accuracy","acc"].indexOf(g)?p=zx:-1!==["crossentropy","ce"].indexOf(g)&&(p=Wx),-1!==["accuracy","acc"].indexOf(g)?x="acc":-1!==["crossentropy","ce"].indexOf(g)&&(x="ce"),f=p,h=""+x}else f=RA(g),h=""+ju(g);let m;Zr(h,()=>{m=f}),o(i,h,m)}})(a[i])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,s,r={}){const a=null==r.batchSize?32:r.batchSize;Jp(a);const i=this.standardizeUserDataXY(e,s,!0,a);try{const l=i[0].concat(i[1]);return this.makeTestFunction(),kn(this.testLoop(this.testFunction,l,a,r.verbose,r.steps))}finally{ds(i[0],e),ds(i[1],s)}}evaluateDataset(e,s){var r=this;return Z(function*(){return r.makeTestFunction(),function qA(n,t,e){return Yp.apply(this,arguments)}(r,e,s)})()}checkNumSamples(e,s,r,a="steps"){let o;if(null!=r){if(o=null,null!=s)throw new D(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${s}`)}else{if(null==e)throw new D(`Either the input data should have a defined shape, or ${a} shoud be specified.`);o=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return o}execute(e,s){if(Array.isArray(s)&&0===s.length)throw new D("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(s),o=this.retrieveSymbolicTensors(r?s:[s]),i=new pr;if(e instanceof Vt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new D(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],e[u])}else for(const u of this.inputs){const c=e[u.name];if(null==c)throw new D(`No value is provided for the model's input ${u.name}`);i.add(u,c)}const l=Ti(o,i);return r?l:l[0]}retrieveSymbolicTensors(e){const s=qr(null,e.length);let r=e.length;for(const a of this.layers){const o=Array.isArray(a.output)?a.output:[a.output],i=o.map(l=>l.name);for(let l=0;l<e.length;++l){const u=i.indexOf(e[l]);if(-1!==u&&(s[l]=o[u],r--),0===r)break}if(0===r)break}if(r>0){const a=[];throw s.forEach((o,i)=>{null==o&&a.push(e[i])}),new D(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return s}predictLoop(e,s=32,r=!1){return L(()=>{const a=this.checkNumSamples(e);if(r)throw new Pe("Verbose predictLoop() is not implemented yet.");const o=ef(a,s),i=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)L(()=>{const h=_i(e,o[l][0],o[l][1]),p=[];if(Array.isArray(h))for(let g=0;g<h.length;++g)p.push({key:this.inputs[g],value:h[g]});else p.push({key:this.inputs[0],value:h});const f=new pr(p);return Ti(this.outputs,f)}).forEach((c,d)=>i[d].push(c));return kn(i.map(l=>dn(l,0)))})}predict(e,s={}){const r=Qx(e);nb(r,this.inputNames,this.feedInputShapes,!1);try{const a=null==s.batchSize?32:s.batchSize;return Jp(a),this.predictLoop(r,a)}finally{ds(r,e)}}predictOnBatch(e){nb(e,this.inputNames,this.feedInputShapes,!0);const s=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,s)}standardizeUserDataXY(e,s,r=!0,a){if(null==this.optimizer_)throw new Jn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const o=[];for(let i=0;i<this.feedOutputShapes.length;++i){const l=this.feedOutputShapes[i];o.push(this.feedLossFns[i]===Wu?l.slice(0,l.length-1).concat([1]):l)}if(function XA(n,t,e){const s=cr(n.map(a=>a.shape[0]));s.sort();const r=cr(t.map(a=>a.shape[0]));if(r.sort(),s.length>1)throw new D(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(a=>a.shape))}`);if(r.length>1)throw new D(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(s.length>0&&r.length>0&&!Qe(s,r))throw new D(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=tb(e,this.feedInputNames,this.feedInputShapes,!1,"input"),s=tb(s,this.feedOutputNames,o,!1,"target")),function ZA(n,t,e){const s=[Bu,Uu,ki];for(let r=0;r<n.length;++r){const a=n[r],o=t[r],i=e[r];if(null!=o){if(o===ki&&1===a.shape[a.shape.length-1])throw new D(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(o)){const l=a.shape.slice(1),u=i.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(null!=h&&d!==h)throw new D(`A target Tensor with shape ${a.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(s,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=a&&a>0&&e[0].shape[0]%a!=0)throw new D(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,s]}standardizeUserData(e,s,r,a,o=!0,i){var l=this;return Z(function*(){const[u,c]=l.standardizeUserDataXY(e,s,o,i);if(null!=r)throw new Error("sample weight is not supported yet.");let d=null;if(null!=a){const h=Kx(a,l.outputNames);d=[];for(let p=0;p<h.length;++p)d.push(yield Xx(c[p],null,h[p]))}return[u,c,d]})()}testLoop(e,s,r,a=0,o){return L(()=>{const i=this.checkNumSamples(s,r,o,"steps"),l=[];if(a>0)throw new Pe("Verbose mode is not implemented yet.");if(null!=o)throw new Pe("steps mode in testLoop() is not implemented yet");{const u=ef(i,r),c=xn(is(0,i));for(let d=0;d<u.length;++d){const h=u[d][0],p=u[d][1],f=Yr(c,h,p-h),g=Qp(s,f),m=e(g);if(0===d)for(let y=0;y<m.length;++y)l.push(Re(0));for(let y=0;y<m.length;++y)l[y]=te(l[y],A(p-h,m[y]))}for(let d=0;d<l.length;++d)l[d]=Se(l[d],i)}return l})}getDedupedMetricsNames(){const e=this.metricsNames,s=[];for(let r=0;r<e.length;++r){const a=e[r];let o=a;ix(e,a)>1&&(o+=`_${ix(e.slice(0,r),a)}`),s.push(o)}return s}makeTrainFunction(){return e=>{const s=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],u=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let m=0;m<this.inputs.length;++m)h.push({key:this.inputs[m],value:r[m]});const p=new pr(h),f=Ti(this.outputs,p,{training:!0});let g;for(let m=0;m<this.lossFunctions.length;++m){let x=this.lossFunctions[m](a[m],f[m]);null!=o[m]&&(x=BA(x,o[m]));const b=Dt(x);s.push(b),g=0===m?x:te(g,x)}for(let m=0;m<this.metricsTensors.length;++m){let y;if(this.outputs.length>1&&m<this.outputs.length)y=s[m];else{const b=this.metricsTensors[m][1];y=Dt((0,this.metricsTensors[m][0])(a[b],f[b]))}bs(y),i.push(y)}return g=Dt(g),this.calculateLosses().forEach(m=>{g=te(g,m)}),g},!0,u)].concat(i)}}makeTestFunction(){this.testFunction=e=>L(()=>{const s=[];let r;const a=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let c=0;c<this.inputs.length;++c)i.push({key:this.inputs[c],value:a[c]});const l=new pr(i),u=Ti(this.outputs,l);for(let c=0;c<this.lossFunctions.length;++c){const h=Dt((0,this.lossFunctions[c])(o[c],u[c]));r=0===c?h:te(r,h),s.push(r)}for(let c=0;c<this.metricsTensors.length;++c){const h=this.metricsTensors[c][1],p=Dt((0,this.metricsTensors[c][0])(o[h],u[h]));s.push(p)}return s})}fit(e,s,r={}){var a=this;return Z(function*(){if(a.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let o,i,l,u,c,d,h,p,f;a.isTraining=!0;try{const g=null==r.batchSize?32:r.batchSize;Jp(g);const m=!1,y=yield a.standardizeUserData(e,s,r.sampleWeight,r.classWeight,m,g);o=y[0],i=y[1],f=y[2];let b,x=!1;if(null!=r.validationData&&r.validationData.length>0){if(x=!0,2!==r.validationData.length)throw 3===r.validationData.length?new Pe("validationData including sample weights is not supported yet."):new D(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);c=r.validationData[0],d=r.validationData[1];const P=!0,z=yield a.standardizeUserData(c,d,null,null,P,g);h=z[0],p=z[1],b=h.concat(p)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){x=!0;const P=Math.floor(o[0].shape[0]*(1-r.validationSplit)),z=o[0].shape[0];h=_i(o,P,z),l=o,o=_i(o,0,P),p=_i(i,P,z),u=i,i=_i(i,0,P),b=h.concat(p)}else null!=r.validationSteps&&(x=!0);const w=o.concat(i).concat(f);a.checkTrainableWeightsConsistency();const C=a.makeTrainFunction(),S=a.getDedupedMetricsNames();let T,k;x?(a.makeTestFunction(),T=a.testFunction,k=S.slice().concat(S.map(P=>"val_"+P))):(T=null,b=[],k=S.slice());const $=Px(r.callbacks,r.yieldEvery);return yield a.fitLoop(C,w,S,g,r.epochs,r.verbose,$,T,b,r.shuffle,k,r.initialEpoch,null,null)}finally{a.isTraining=!1,ds(o,e),ds(i,s),ds(l,e),ds(u,s),ds(h,c),ds(p,d),null!=f&&Ue(f)}})()}fitLoop(e,s,r,a,o,i,l,u,c,d,h,p,f,g){var m=this;return Z(function*(){null==a&&(a=32),null==o&&(o=1),null==d&&(d=!0),null==p&&(p=0);let y=!1;if(null!=u&&null!=c&&(y=!0),null!=g&&(y=!0,null==f))throw new D("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const x=m.checkNumSamples(s,a,f,"steps_per_epoch");let b;null!=x&&(b=is(0,x)),null==i&&(i=1);const{callbackList:w,history:C}=Lx(l,i,o,p,x,f,a,y,h);w.setModel(m),m.history=C,yield w.onTrainBegin(),m.stopTraining_=!1;for(let S=p;S<o;++S){yield w.onEpochBegin(S);const T={};if(null!=f)throw new Pe("stepsPerEpoch mode is not implemented yet.");{if("batch"===d)throw new Pe("batch shuffling is not implemneted yet");d&&um(b);const k=xn(b),$=ef(x,a);for(let E=0;E<$.length;++E){const P={};if(yield w.onBatchBegin(E,P),L(()=>{const z=$[E][0],B=$[E][1],U=Yr(k,z,B-z);P.batch=E,P.size=B-z;const G=Qp(s,U),q=e(G);for(let K=0;K<r.length;++K){const X=q[K];P[r[K]]=X,bs(X)}if(E===$.length-1&&y){const K=m.testLoop(u,c,a);for(let H=0;H<r.length;++H){const X=r[H],ne=K[H];bs(ne),T["val_"+X]=ne}}}),yield w.onBatchEnd(E,P),Ox(P),m.stopTraining_)break}k.dispose()}if(yield w.onEpochEnd(S,T),m.stopTraining_)break}return yield w.onTrainEnd(),yield m.history.syncData(),m.history})()}fitDataset(e,s){var r=this;return Z(function*(){return function GA(n,t,e){return Zp.apply(this,arguments)}(r,e,s)})()}trainOnBatch(e,s){var r=this;return Z(function*(){const a=yield r.standardizeUserData(e,s),o=a[0],i=a[1],u=r.makeTrainFunction()(o.concat(i)),c=[];for(const d of u){const h=yield d.data();c.push(h[0])}return Ue(u),ds(a[0],e),ds(a[1],s),kn(c)})()}getNamedWeights(e){const s=[],r=null!=e&&e.trainableOnly,a=r?this.trainableWeights:this.weights,o=this.getWeights(r);for(let i=0;i<a.length;++i)r&&!a[i].trainable||s.push({name:a[i].originalName,tensor:o[i]});return s}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const s=Yd().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=s-Yd().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=js(this.loss);else if(Array.isArray(this.loss)){for(const s of this.loss)if("string"!=typeof s)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(s=>js(s))}else{const s=Object.keys(this.loss);e={};const r=this.loss;for(const a of s){if("string"!=typeof r[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=js(r[a])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[js(ju(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>js(ju(e)));{const e={};for(const s in this.metrics)e[s]=js(ju(this.metrics[s]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const r=qs(jp(e.optimizer_config));let a,o;if("string"==typeof e.loss)a=Kr(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(i=>Kr(i));else if(null!=e.loss){a={};for(const i in e.loss)a[i]=Kr(e.loss[i])}if(Array.isArray(e.metrics))o=e.metrics.map(i=>Kr(i));else if(null!=e.metrics){o={};for(const i in e.metrics)o[i]=Kr(e.metrics[i])}this.compile({loss:a,metrics:o,optimizer:r})}save(e,s){var r=this;return Z(function*(){if("string"==typeof e){const d=(n=>Ct.getSaveHandlers(n))(e);if(0===d.length)throw new D(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new D(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(null==e.save)throw new D("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=yield tg(r.getNamedWeights(s)),u={modelTopology:r.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.19.0",convertedBy:null};if(null!=s&&s.includeOptimizer&&null!=r.optimizer){u.trainingConfig=r.getTrainingConfig();const d="optimizer",{data:h,specs:p}=yield tg(yield r.optimizer.getWeights(),d);a.specs.push(...p),a.data=function KC(n){return ys.join(n)}([a.data,h])}return null!=r.userDefinedMetadata&&(Hx(r.userDefinedMetadata,r.name,!0),u.userDefinedMetadata=r.userDefinedMetadata),u.weightData=a.data,u.weightSpecs=a.specs,e.save(u)})()}setUserDefinedMetadata(e){Hx(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();ee(Fa),ee((()=>{class n extends Fa{}return n.className="Functional",n})());let sb=(()=>{class n extends Fa{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Au("sequential_"),null!=e.layers)for(const s of e.layers)this.add(s)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new D(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const s=e instanceof n||e instanceof Fa;let r;if(s){if(r=e,1!==r.outputs.length)throw new D("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new D("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new D("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const a=function Ax(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new D("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new Ii({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(a)}if(s)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new D(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new D("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Ex(this.outputs[0])}this.inboundNodes=[],new Lu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:qr(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{const a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,s){return null==this.model&&this.build(),this.model.call(e,s)}build(e){if(Xe(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Fa({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,s,r=console.log){this.built||this.build(),super.summary(e,s,r)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,s,r={}){if(!this.built)throw new Jn("The model needs to be compiled before being used.");return this.model.evaluate(e,s,r)}evaluateDataset(e,s){var r=this;return Z(function*(){if(!r.built)throw new Jn("The model needs to be compiled before being used.");return r.model.evaluateDataset(e,s)})()}predict(e,s={}){return null==this.model&&this.build(),this.model.predict(e,s)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,s,r={}){var a=this;return Z(function*(){if(!a.built)throw new Jn("The model needs to be compiled before being used.");return a.model.fit(e,s,r)})()}fitDataset(e,s){var r=this;return Z(function*(){if(!r.built)throw new Jn("The model needs to be compiled before being used.");return r.model.fitDataset(e,s)})()}trainOnBatch(e,s){var r=this;return Z(function*(){return r.model.trainOnBatch(e,s)})()}static fromConfig(e,s,r={},a=!1){let o,i={};if(s instanceof Array){if(null==s[0].className||"Merge"===s[0].className)throw new D("Legacy serialization format not supported yet.");o=s}else I(null!=s.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=s.layers,delete s.layers,i=s;const l=new e(i);if(!(l instanceof n))throw new Pe(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(const u of o){const d=qs(u,void 0,a);a&&d.setFastWeightInitDuringBuild(!0),l.add(d)}return l}set stopTraining(e){if(null==this.model)throw new D("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new D("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const s of this.layers){const r={};r.className=s.getClassName(),r.config=s.getConfig(),e.push(r)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();ee(sb);class hn extends Sa{getConfig(){return{}}}ee((()=>{class n extends hn{apply(e,s=1){return function BE(n,t=1){if(1!==t)throw new Pe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return pu(n)}(e,s)}}return n.className="elu",n})()),ee((()=>{class n extends hn{apply(e){return Zg(e)}}return n.className="selu",n})()),ee((()=>{class n extends hn{apply(e){return zs(e)}}return n.className="relu",n})()),ee((()=>{class n extends hn{apply(e){return L(()=>Na(6,zs(e)))}}return n.className="relu6",n})()),ee((()=>{class n extends hn{apply(e){return e}}return n.className="linear",n})()),ee((()=>{class n extends hn{apply(e){return ka(e)}}return n.className="sigmoid",n})()),ee((()=>{class n extends hn{apply(e){return function UE(n){return L(()=>{const t=te(.5,A(.2,n));return Pn(t,0,1)})}(e)}}return n.className="hardSigmoid",n})()),ee((()=>{class n extends hn{apply(e){return hi(e)}}return n.className="softplus",n})()),ee((()=>{class n extends hn{apply(e){return function WE(n){return L(()=>Se(n,te(qt(n),1)))}(e)}}return n.className="softsign",n})()),ee((()=>{class n extends hn{apply(e){return yu(e)}}return n.className="tanh",n})());let rb=(()=>{class n extends hn{apply(e,s=-1){return Gh(e,s)}}return n.className="softmax",n})();function mr(n){return n.getClassName()}function of(n,t={}){return bi(n,qn.getMap().classNameMap,t,"activation")}function gr(n){if(null==n){return of({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},of(t)}return n instanceof hn?n:of(n)}ee(rb),ee((()=>{class n extends hn{apply(e,s=-1){return qg(e,s)}}return n.className="logSoftmax",n})()),ee((()=>{class n extends hn{apply(e){return L(()=>L(()=>{const s=Math.sqrt(2),r=A(.5,te(1,Hg(Se(e,s))));return A(e,r)}))}}return n.className="gelu",n})()),ee((()=>{class n extends hn{apply(e){return L(()=>A(.5,A(e,te(1,yu(A(cn(Se(2,Math.PI)),te(e,A(.044715,Vr(e,3)))))))))}}return n.className="gelu_new",n})()),ee((()=>{class n extends hn{apply(e){return L(()=>A(e,yu(hi(e))))}}return n.className="mish",n})()),ee((()=>{class n extends hn{apply(e,s=1){return L(()=>A(ka(A(e,s)),e))}}return n.className="swish",n})());class ab extends Sa{}ee((()=>{class n extends ab{constructor(e){super(),function lf(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return L(()=>{let s=Zt([1]);return this.hasL1&&(s=te(s,ve(A(this.l1,qt(e))))),this.hasL2&&(s=te(s,ve(A(this.l2,Ci(e))))),O(s,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,s){return new e({l1:s.l1,l2:s.l2})}}return n.className="L1L2",n})());const ob={l1l2:"L1L2"};function dt(n){return Ep(n)}function ib(n,t={}){return bi(n,qn.getMap().classNameMap,t,"regularizer")}function wt(n){return null==n?null:"string"==typeof n?ib({className:n in ob?ob[n]:n,config:{}}):n instanceof ab?n:ib(n)}function Oa(n,t,e){if("number"==typeof n)return qr(n,t);if(n.length!==t)throw new D(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!OE(r))throw new D(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function hs(n,t,e,s,r=1){if(null==n)return n;let o;return o="same"===e?n:n-(t+(t-1)*(r-1))+1,Math.floor((o+s-1)/s)}function _s(n,t,e,s){if(null==n)return null;if("valid"===s)n=n*t+hr([e-t,0]);else{if("same"!==s)throw new D(`Unsupport padding mode: ${s}.`);n*=t}return n}function cf(n,t){return L(()=>(Rt(t),"channelsFirst"===t?qe(n,[0,2,3,1]):n))}function fb(n,t){return L(()=>(Rt(t),"channelsFirst"===t?qe(n,[0,2,3,4,1]):n))}function df(n,t,e,s=[1,1],r="valid",a,o,i=null){return L(()=>{if(null==a&&(a="channelsLast"),Rt(a),3!==n.rank&&4!==n.rank)throw new D(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new D(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=cf(n,a);if("causal"===r)throw new Pe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=sN({x:l,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:i}),"channelsFirst"===a&&(l=qe(l,[0,3,1,2])),l})}ee((()=>{class n extends We{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,s){e=$e(e);let r=zs(e);return null!=this.maxValue&&(r=Pn(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ReLU",n})()),ee((()=>{class n extends We{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=$e(e);return Ah(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LeakyReLU",n})()),ee((()=>{class n extends We{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=bt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wt(e.alphaRegularizer),this.alphaConstraint=Gt(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new D(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const s=(e=Xe(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)s[a-1]=1;this.alpha=this.addWeight("alpha",s,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)r[a]=e[a];this.inputSpec=[new Wt({ndim:e.length,axes:r})],this.built=!0}call(e,s){return e=$e(e),Mh(e,this.alpha.read())}getConfig(){const e={alphaInitializer:It(this.alphaInitializer),alphaRegularizer:dt(this.alphaRegularizer),alphaConstraint:Ut(this.alphaConstraint),sharedAxes:this.sharedAxes},s=super.getConfig();return Object.assign(e,s),e}}return n.className="PReLU",n})()),ee((()=>{class n extends We{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Pe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=$e(e);return pu(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ELU",n})()),ee((()=>{class n extends We{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,s){const r=$e(e);return A(r,de(Mn(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ThresholdedReLU",n})()),ee((()=>{class n extends We{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new rb).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,s){return L(()=>{let r=$e(e);const a=s.mask;if(null!=a){const o=A(ye(Vs(r.shape),de(a,r.dtype)),Re(-1e9));r=te(r,o)}return this.axis instanceof Array?this.axis.length>1?Ln(ye(r,Fh(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Softmax",n})());class Ku extends We{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Ku.verifyArgs(e),this.rank=t,Yt(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Pe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Oa(e.kernelSize,t,"kernelSize"),this.strides=Oa(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,Bn(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Rt(this.dataFormat),this.activation=gr(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Gt(e.biasConstraint),this.biasRegularizer=wt(e.biasRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.dilationRate=Oa(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new D(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new D(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new D(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(zn("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!Dp(t.kernelSize,"number",1,3))throw new D(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mr(this.activation),useBias:this.useBias,biasInitializer:It(this.biasInitializer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),biasConstraint:Ut(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Pa extends Ku{constructor(t,e){super(t,e),this.kernel=null,Pa.verifyArgs(e),this.filters=e.filters,Yt(this.filters,"filters"),this.kernelInitializer=bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Gt(e.kernelConstraint),this.kernelRegularizer=wt(e.kernelRegularizer)}build(t){t=Xe(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new D(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return L(()=>{let s;t=$e(t);const r=null==this.bias?null:this.bias.read(),a=ux(this.activation.getClassName());if(null!=a&&2===this.rank)s=df(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)s=function mb(n,t,e,s=1,r="valid",a,o=1){return L(()=>{if(null==a&&(a="channelsLast"),Rt(a),3!==n.shape.length)throw new D(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new D(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new D(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if("channelsFirst"===a&&(n=qe(n,[0,2,1])),"causal"===r)throw new Pe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Bg(n,t,s,"same"===r?"same":"valid","NWC",o);return null!=e&&(i=us(i,e)),i})}(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)s=df(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Pe("convolutions greater than 3D are not implemented yet.");s=function gb(n,t,e,s=[1,1,1],r="valid",a,o){return L(()=>{if(null==a&&(a="channelsLast"),Rt(a),4!==n.rank&&5!==n.rank)throw new D(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new D(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let i=fb(n,a);if("causal"===r)throw new Pe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=AI(i,t,s,"same"===r?"same":"valid","NDHWC",o),null!=e&&(i=us(i,e)),"channelsFirst"===a&&(i=qe(i,[0,4,1,2,3])),i})}(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=Xe(t);const e=[],s="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<s.length;++a){const o=hs(s[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(o)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:It(this.kernelInitializer),kernelRegularizer:dt(this.kernelRegularizer),kernelConstraint:Ut(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new D(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let hf=(()=>{class n extends Pa{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Dp(e.kernelSize,"number",1,2))throw new D(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();ee(hf);let pf=(()=>{class n extends Pa{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new D(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();ee(pf),ee((()=>{class n extends hf{constructor(e){if(super(e),this.inputSpec=[new Wt({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new D(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=Xe(e)).length)throw new D("Input should have rank 4; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new D("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wt({ndim:4,axes:{[s]:r}})],this.built=!0}call(e,s){return L(()=>{let r=$e(e);if(4!==r.shape.length)throw new D(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape;let i,l;"channelsFirst"===this.dataFormat?(i=2,l=3):(i=1,l=2);const c=a[l],h=this.kernelSize[1],f=this.strides[1],y=[a[0],_s(a[i],this.strides[0],this.kernelSize[0],this.padding),_s(c,f,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=qe(r,[0,2,3,1]));let x=Wg(r,this.kernel.read(),y,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(x=qe(x,[0,3,1,2])),null!=this.bias&&(x=us(x,this.bias.read(),this.dataFormat)),null!=this.activation&&(x=this.activation.apply(x)),x})}computeOutputShape(e){const s=(e=Xe(e)).slice();let r,a,o;"channelsFirst"===this.dataFormat?(r=1,a=2,o=3):(r=3,a=1,o=2);const i=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],c=this.strides[1];return s[r]=this.filters,s[a]=_s(s[a],u,i,this.padding),s[o]=_s(s[o],c,l,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})()),ee((()=>{class n extends pf{constructor(e){if(super(e),this.inputSpec=[new Wt({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new D(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=Xe(e)).length)throw new D("Input should have rank 5; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new D("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wt({ndim:5,axes:{[s]:r}})],this.built=!0}call(e,s){return L(()=>{let r=$e(e);if(5!==r.shape.length)throw new D(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape;let i,l,u;"channelsFirst"===this.dataFormat?(u=2,i=3,l=4):(u=1,i=2,l=3);const d=a[i],h=a[l],f=this.kernelSize[1],g=this.kernelSize[2],y=this.strides[1],x=this.strides[2],S=[a[0],_s(a[u],this.strides[0],this.kernelSize[0],this.padding),_s(d,y,f,this.padding),_s(h,x,g,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=qe(r,[0,2,3,4,1]));let T=FI(r,this.kernel.read(),S,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(T=qe(T,[0,4,1,2,3])),null!==this.bias&&(T=us(T,this.bias.read(),this.dataFormat)),null!==this.activation&&(T=this.activation.apply(T)),T})}computeOutputShape(e){const s=(e=Xe(e)).slice();let r,a,o,i;"channelsFirst"===this.dataFormat?(r=1,a=2,o=3,i=4):(r=4,a=1,o=2,i=3);const l=this.kernelSize[0],u=this.kernelSize[1],c=this.kernelSize[2],d=this.strides[0],h=this.strides[1],p=this.strides[2];return s[r]=this.filters,s[a]=_s(s[a],d,l,this.padding),s[o]=_s(s[o],h,u,this.padding),s[i]=_s(s[i],p,c,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})());let nD=(()=>{class n extends Pa{constructor(e,s){if(super(e,s),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==s.filters)throw new D("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=s.kernelInitializer||null!=s.kernelRegularizer||null!=s.kernelConstraint)throw new D("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=s.padding&&"same"!==s.padding&&"valid"!==s.padding)throw new D(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(s.padding)}`);this.depthMultiplier=null==s.depthMultiplier?1:s.depthMultiplier,this.depthwiseInitializer=bt(s.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wt(s.depthwiseRegularizer),this.depthwiseConstraint=Gt(s.depthwiseConstraint),this.pointwiseInitializer=bt(s.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wt(s.pointwiseRegularizer),this.pointwiseConstraint=Gt(s.pointwiseConstraint)}build(e){if((e=Xe(e)).length<this.rank+2)throw new D(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s]||e[s]<0)throw new D(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[s])}`);const r=e[s],a=this.kernelSize.concat([r,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):null,this.inputSpec=[new Wt({ndim:this.rank+2,axes:{[s]:r}})],this.built=!0}call(e,s){return L(()=>{let r;if(e=$e(e),1===this.rank)throw new Pe("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=qe(e,[0,2,3,1])),r=Yg(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=us(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),"channelsFirst"===this.dataFormat&&(r=qe(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=It(this.depthwiseInitializer),e.pointwiseInitializer=It(this.pointwiseInitializer),e.depthwiseRegularizer=dt(this.depthwiseRegularizer),e.pointwiseRegularizer=dt(this.pointwiseRegularizer),e.depthwiseConstraint=Ut(this.depthwiseConstraint),e.pointwiseConstraint=Ut(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})();function Ib(n,t,e,s){if(Array.isArray(n)){if(null!=t||null!=e)throw new D("When inputs is an array, neither initialState or constants should be provided");null!=s&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(a){return null==a||Array.isArray(a)?a:[a]}return{inputs:n,initialState:t=r(t),constants:e=r(e)}}function Tb(n,t,e,s=!1,r,a,o=!1,i=!1){return L(()=>{const l=t.shape.length;if(l<3)throw new D(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(is(2,l));if(t=qe(t,u),null!=a)throw new Pe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=de(de(r,"bool"),"float32")).rank===l-1&&(r=Nn(r,-1)),r=qe(r,u)),s&&(t=Ur(t,0),null!=r&&(r=Ur(r,0)));const c=[];let d,h=e;const p=t.shape[0],f=Gr(t);let g,m;null!=r&&(g=Gr(r));for(let y=0;y<p;++y){const x=f[y],b=L(()=>n(x,h));if(null==r)d=b[0],h=b[1];else{const w=L(()=>{const C=g[y],S=ye(Zn(C),C);return{output:te(A(b[0],C),A(h[0],S)),newStates:h.map(($,E)=>te(A(b[1][E],C),A($,S)))}});d=w.output,h=w.newStates}i&&c.push(d)}return i&&(m=Bs(c,1)),[d,m,h]})}ee((()=>{class n extends nD{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})()),ee((()=>{class n extends Pa{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Dp(e.kernelSize,"number",1,1))throw new D(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,s){return L(()=>{if(e=$e(e),"channelsLast"===this.dataFormat){const r=Ru(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Ru(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const r=Ru(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Ru(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Cropping2D",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Rt(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function DE(n){Xr(_E,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,s){return L(()=>{let r=$e(e);const a=r.shape;if("channelsFirst"===this.dataFormat){r=qe(r,[0,2,3,1]);const o=this.size[0]*a[2],i=this.size[1]*a[3],l="nearest"===this.interpolation?Us.resizeNearestNeighbor(r,[o,i]):Us.resizeBilinear(r,[o,i]);return qe(l,[0,3,1,2])}{const o=this.size[0]*a[1],i=this.size[1]*a[2];return"nearest"===this.interpolation?Us.resizeNearestNeighbor(r,[o,i]):Us.resizeBilinear(r,[o,i])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}}return n.className="UpSampling2D",n})()),ee((()=>{class n extends Ku{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=bt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Gt(e.depthwiseConstraint),this.depthwiseRegularizer=wt(e.depthwiseRegularizer)}build(e){if((e=Xe(e)).length<4)throw new D(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const s="channelsFirst"===this.dataFormat?1:3;if(null==e[s]||e[s]<0)throw new D(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[s]}).`);const r=e[s];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return L(()=>{let r=function sD(n,t,e=[1,1],s="valid",r,a){return L(()=>{null==r&&(r="channelsLast"),Rt(r);let o=cf(n,r);if(4!==n.rank)throw new D(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new D(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=hu(o,t,e,"same"===s?"same":"valid","NHWC",a),"channelsFirst"===r&&(o=qe(o,[0,3,1,2])),o})}(e=$e(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=us(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=Xe(e);const r="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,o=hs("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),i=hs(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,o,i]:[e[0],o,i,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=It(this.depthwiseInitializer),e.depthwiseRegularizer=dt(this.depthwiseRegularizer),e.depthwiseConstraint=Ut(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})());let La=(()=>{class n extends We{constructor(e){let s;if(super(e),null==e.cell)throw new D("cell property is missing for the constructor of RNN.");if(s=Array.isArray(e.cell)?new gf({cells:e.cell}):e.cell,null==s.stateSize)throw new D("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=s,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Wt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?is(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(s=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Lp(e)&&(e=e[0]),e=e;let s=this.cell.stateSize;Array.isArray(s)||(s=[s]);const r=s[0];let a;if(a=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){const o=[];for(const i of s)o.push([e[0],i]);return[a].concat(o)}return a}computeMask(e,s){return L(()=>{Array.isArray(s)&&(s=s[0]);const r=this.returnSequences?s:null;if(this.returnState){const a=this.states.map(o=>null);return[r].concat(a)}return r})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,s=[];for(let r=0;r<e;++r)s.push(null);return s}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Pe("Constants support is not implemented in RNN yet.");Lp(e)&&(e=e[0]),e=e;const r=this.stateful?e[0]:null,a=e.slice(2);this.inputSpec[0]=new Wt({shape:[r,null,...a]});const o=[e[0]].concat(e.slice(2));let i;if(this.cell.build(o),i=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!Qe(this.stateSpec.map(l=>l.shape[l.shape.length-1]),i))throw new D(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(l=>new Wt({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(e,s=!1){L(()=>{if(!this.stateful)throw new Ss("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(null==r)throw new D("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>Zt([r,a])):[Zt([r,this.cell.stateSize])];else if(null==e)Ue(this.states_),null!=this.keptStates&&(Ue(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Zt([r,a])):this.states_[0]=Zt([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new D(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===s?this.keptStates.push(this.states_.slice()):Ue(this.states_);for(let a=0;a<this.states_.length;++a){const o=e[a],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,l=[r,i];if(!Qe(o.shape,l))throw new D(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[a]=o}}this.states_=this.states_.map(a=>bs(a.clone()))})}apply(e,s){let r=null==s?null:s.initialState,a=null==s?null:s.constants;null==s&&(s={});const o=Ib(e,r,a,this.numConstants);e=o.inputs,r=o.initialState,a=o.constants;let i=[],l=[];if(null!=r){s.initialState=r,i=i.concat(r),this.stateSpec=[];for(const c of r)this.stateSpec.push(new Wt({shape:c.shape}));l=l.concat(this.stateSpec)}if(null!=a&&(s.constants=a,i=i.concat(a),this.numConstants=a.length),i[0]instanceof ks){const c=[e].concat(i),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,s);return this.inputSpec=h,p}return super.apply(e,s)}call(e,s){return L(()=>{const r=null==s?null:s.mask,a=null==s?null:s.training;let o=null==s?null:s.initialState;e=$e(e),null==o&&(o=this.stateful?this.states_:this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==i)throw new D(`RNN Layer has ${i} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const l={training:a},c=Tb((g,m)=>{const y=this.cell.call([g].concat(m),l);return[y[0],y.slice(1)]},e,o,this.goBackwards,r,null,this.unroll,this.returnSequences),d=c[0],h=c[1],p=c[2];this.stateful&&this.resetStates(p,a);const f=this.returnSequences?h:d;return this.returnState?[f].concat(p):f})}getInitialState(e){return L(()=>{let s=Zt(e.shape);return s=ve(s,[1,2]),s=vi(s),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Op(s,[1,r]):s):this.cell.stateSize>1?[Op(s,[1,this.cell.stateSize])]:[s]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),s={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(s.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===n.className&&(s.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),s)}static fromConfig(e,s,r={}){const o=qs(s.cell,r);return new e(Object.assign(s,{cell:o}))}}return n.className="RNN",n})();ee(La);class Xu extends We{}let ff=(()=>{class n extends Xu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Yt(this.units,"units"),this.activation=gr(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=Da([1,hr([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Da([1,hr([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return L(()=>{if(2!==(e=e).length)throw new D(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const a=null!=s.training&&s.training;let o;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yr({ones:()=>Zn(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yr({ones:()=>Zn(r),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,l=this.recurrentDropoutMask;o=Ts(null!=i?A(e,i):e,this.kernel.read()),null!=this.bias&&(o=us(o,this.bias.read())),null!=l&&(r=A(r,l));let u=te(o,Ts(r,this.recurrentKernel.read()));return null!=this.activation&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:mr(this.activation),useBias:this.useBias,kernelInitializer:It(this.kernelInitializer),recurrentInitializer:It(this.recurrentInitializer),biasInitializer:It(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),s)}}return n.className="SimpleRNNCell",n})();ee(ff),ee((()=>{class n extends La{constructor(e){e.cell=new ff(e),super(e)}call(e,s){return L(()=>(null!=this.cell.dropoutMask&&(Ue(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ue(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return new e(s)}}return n.className="SimpleRNN",n})());let mf=(()=>{class n extends Xu{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new D("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Yt(this.units,"units"),this.activation=gr(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gr(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=Da([1,hr([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Da([1,hr([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return L(()=>{if(2!==(e=e).length)throw new D(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=null!=s.training&&s.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yr({ones:()=>Zn(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yr({ones:()=>Zn(a),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const i=this.recurrentDropoutMask;let l,u,c;0<this.dropout&&this.dropout<1&&(e=A(e,this.dropoutMask[0]));let d=Ts(e,this.kernel.read());this.useBias&&(d=us(d,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=A(a,i[0]));const h=this.recurrentKernel.read(),[p,f]=Vn(h,[2*this.units,this.units],h.rank-1),g=Ts(a,p),[m,y,x]=Vn(d,3,d.rank-1),[b,w]=Vn(g,2,g.rank-1);l=this.recurrentActivation.apply(te(m,b)),u=this.recurrentActivation.apply(te(y,w));const C=Ts(A(u,a),f);c=this.activation.apply(te(x,C));const S=te(A(l,a),A(te(1,xt(l)),c));return[S,S]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:mr(this.activation),recurrentActivation:mr(this.recurrentActivation),useBias:this.useBias,kernelInitializer:It(this.kernelInitializer),recurrentInitializer:It(this.recurrentInitializer),biasInitializer:It(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),s)}}return n.className="GRUCell",n})();ee(mf),ee((()=>{class n extends La{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mf(e),super(e)}call(e,s){return L(()=>(null!=this.cell.dropoutMask&&(Ue(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ue(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="GRU",n})());let Zu=(()=>{class n extends Xu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Yt(this.units,"units"),this.activation=gr(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=gr(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=bt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Gt(e.kernelConstraint),this.recurrentConstraint=Gt(e.recurrentConstraint),this.biasConstraint=Gt(e.biasConstraint),this.dropout=Da([1,hr([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Da([1,hr([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var s;let a;if(e=Xe(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const o=this.biasInitializer,i=this.units;a=new((s=class extends es{apply(u,c){const d=o.apply([i]),h=(new wx).apply([i]),p=o.apply([2*i]);return yx(yx(d,h),p)}}).className="CustomInit",s)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,s){return L(()=>{const r=null!=s.training&&s.training;if(3!==(e=e).length)throw new D(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1];const o=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yr({ones:()=>Zn(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yr({ones:()=>Zn(a),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const l=this.recurrentDropoutMask;let u,c,d,h;0<this.dropout&&this.dropout<1&&(e=A(e,this.dropoutMask[0]));let p=Ts(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=A(a,l[0])),p=te(p,Ts(a,this.recurrentKernel.read())),this.useBias&&(p=us(p,this.bias.read()));const[f,g,m,y]=Vn(p,4,p.rank-1);u=this.recurrentActivation.apply(f),c=this.recurrentActivation.apply(g),d=te(A(c,o),A(u,this.activation.apply(m))),h=this.recurrentActivation.apply(y);const x=A(h,this.activation.apply(d));return[x,x,d]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:mr(this.activation),recurrentActivation:mr(this.recurrentActivation),useBias:this.useBias,kernelInitializer:It(this.kernelInitializer),recurrentInitializer:It(this.recurrentInitializer),biasInitializer:It(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:dt(this.kernelRegularizer),recurrentRegularizer:dt(this.recurrentRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),recurrentConstraint:Ut(this.recurrentConstraint),biasConstraint:Ut(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),s)}}return n.className="LSTMCell",n})();ee(Zu),ee((()=>{class n extends La{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Zu(e),super(e)}call(e,s){return L(()=>(null!=this.cell.dropoutMask&&(Ue(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ue(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="LSTM",n})());let gf=(()=>{class n extends Xu{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const s of this.cells.slice().reverse())Array.isArray(s.stateSize)?e.push(...s.stateSize):e.push(s.stateSize);return e}call(e,s){return L(()=>{let r=(e=e).slice(1);const a=[];for(const l of this.cells.slice().reverse())Array.isArray(l.stateSize)?a.push(r.splice(0,l.stateSize.length)):a.push(r.splice(0,1));a.reverse();const o=[];let i;for(let l=0;l<this.cells.length;++l){const u=this.cells[l];r=a[l],i=0===l?[e[0]].concat(r):[i[0]].concat(r),i=u.call(i,s),o.push(i.slice(1))}r=[];for(const l of o.slice().reverse())r.push(...l);return[i[0]].concat(r)})}build(e){let s;Lp(e)&&(e=e[0]),e=e,this.cells.forEach((r,a)=>{Zr(`RNNCell_${a}`,()=>{r.build(e),s=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],s]})}),this.built=!0}getConfig(){const e=super.getConfig(),a={cells:this.cells.map(o=>({className:o.getClassName(),config:o.getConfig()}))};return Object.assign(Object.assign({},e),a)}static fromConfig(e,s,r={}){const a=[];for(const o of s.cells)a.push(qs(o,r));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const s of this.cells)e.push(...s.nonTrainableWeights);if(!this.trainable){const s=[];for(const r of this.cells)s.push(...r.trainableWeights);return s.concat(e)}return e}getWeights(){const e=[];for(const s of this.cells)e.push(...s.weights);return Mp(e)}setWeights(e){const s=[];for(const r of this.cells){const o=e.splice(r.weights.length);for(let i=0;i<r.weights.length;++i)s.push([r.weights[i],o[i]])}Vp(s)}}return n.className="StackedRNNCells",n})();function yr(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:a}=n,o=()=>null!=a?a(t(),e):bx(t(),e),i=()=>Si(o,t,s);return!r||r<=1?bs(i().clone()):Array(r).fill(void 0).map(i).map(u=>bs(u.clone()))}ee(gf);let aD=(()=>{class n extends La{constructor(e){if(e.unroll)throw new Pe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Pe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Wt({ndim:5})]}call(e,s){return L(()=>{if(null!=this.cell.dropoutMask&&(Ue(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Ue(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),s&&s.constants)throw new D("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})})}computeOutputShape(e){let s=this.computeSingleOutputShape(e);return this.returnSequences||(s=[s[0],...s.slice(2)]),this.returnState&&(s=[s,...Array(2).fill([e[0],...s.slice(-3)])]),s}getInitialState(e){return L(()=>{const{stateSize:s}=this.cell,a=this.computeSingleOutputShape(e.shape),i=Zt([a[0],...a.slice(2)]);return Array.isArray(s)?Array(s.length).fill(i):[i]})}resetStates(e,s=!1){L(()=>{if(!this.stateful)throw new Ss("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,a=this.computeSingleOutputShape(r),o=[a[0],...a.slice(2)];if(null==r[0])throw new D("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>Zt(o)):[Zt(o)];else if(null==e)Ue(this.states_),null!=this.keptStates&&(Ue(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Zt(o)):this.states_[0]=Zt(o);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new D(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);s?this.keptStates.push(this.states_.slice()):Ue(this.states_);for(let l=0;l<this.states_.length;++l){const u=e[l],c=o;if(!Qe(u.shape,c))throw new D(`State ${l} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>bs(l.clone()))})}computeSingleOutputShape(e){const{dataFormat:s,filters:r,kernelSize:a,padding:o,strides:i,dilationRate:l}=this.cell,u="channelsFirst"===s,d=e[u?4:3],h=hs(e[u?3:2],a[0],o,i[0],l[0]),p=hs(d,a[1],o,i[1],l[1]);return[...e.slice(0,2),...u?[r,h,p]:[h,p,r]]}}return n.className="ConvRNN2D",n})(),yf=(()=>{class n extends Zu{constructor(e){const{filters:s,kernelSize:r,strides:a,padding:o,dataFormat:i,dilationRate:l}=e;super(Object.assign(Object.assign({},e),{units:s})),this.filters=s,Yt(this.filters,"filters"),this.kernelSize=Oa(r,2,"kernelSize"),this.kernelSize.forEach(u=>Yt(u,"kernelSize")),this.strides=Oa(a||1,2,"strides"),this.strides.forEach(u=>Yt(u,"strides")),this.padding=o||"valid",Bn(this.padding),this.dataFormat=i||"channelsLast",Rt(this.dataFormat),this.dilationRate=Oa(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>Yt(u,"dilationRate"))}build(e){var s;e=Xe(e);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new D(`The channel dimension of the input should be defined. Found ${e[r]}`);const i=this.kernelSize.concat([e[r],4*this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const l=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const c=this.biasInitializer,d=this.filters;u=new((s=class extends es{apply(p,f){return Fp([c.apply([d]),Vs([d]),c.apply([2*d])])}}).className="CustomInit",s)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,s){return L(()=>{if(3!==e.length)throw new D(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=s.training||!1,a=e[0],o=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yr({ones:()=>Zn(a),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=(re,ie,oe)=>ie&&ie[oe]?A(ie[oe],re):re;let d=c(a,u,0),h=c(a,u,1),p=c(a,u,2),f=c(a,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yr({ones:()=>Zn(o),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const g=this.recurrentDropoutMask;let m=c(o,g,0),y=c(o,g,1),x=c(o,g,2),b=c(o,g,3);const[C,S,T,k]=Vn(this.kernel.read(),4,3),[$,E,P,z]=this.useBias?Vn(this.bias.read(),4):[null,null,null,null];d=this.inputConv(d,C,$,this.padding),h=this.inputConv(h,S,E,this.padding),p=this.inputConv(p,T,P,this.padding),f=this.inputConv(f,k,z,this.padding);const[B,U,G,q]=Vn(this.recurrentKernel.read(),4,3);m=this.recurrentConv(m,B),y=this.recurrentConv(y,U),x=this.recurrentConv(x,G),b=this.recurrentConv(b,q);const K=this.recurrentActivation.apply(te(d,m)),H=this.recurrentActivation.apply(te(h,y)),X=te(A(H,i),A(K,this.activation.apply(te(p,x)))),ne=A(this.recurrentActivation.apply(te(f,b)),this.activation.apply(X));return[ne,ne,X]})}getConfig(){const r=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]])}return e}(super.getConfig(),["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),a)}inputConv(e,s,r,a){const o=Br(e,s,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?us(o,r,this.dataFormat):o}recurrentConv(e,s){return Br(e,s,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();ee(yf),ee((()=>{class n extends aD{constructor(e){const s=new yf(e);super(Object.assign(Object.assign({},e),{cell:s}))}static fromConfig(e,s){return new e(s)}}return n.className="ConvLSTM2D",n})());let xf=(()=>{class n extends We{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const s=e.shape,r=[];for(let a=0;a<this.noiseShape.length;++a)r.push(null==this.noiseShape[a]?s[a]:this.noiseShape[a]);return r}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e);if(0<this.rate&&this.rate<1){const a=null!=s.training&&s.training,o=this.getNoiseShape(r);return Si(()=>bx(r,this.rate,o,this.seed),()=>r,a)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},s=super.getConfig();return Object.assign(e,s),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();ee(xf),ee((()=>{class n extends xf{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const s=e.shape;return[s[0],1,s[2]]}}return n.className="SpatialDropout1D",n})());let Ab=(()=>{class n extends We{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=[s,e.inputDim]}this.units=e.units,Yt(this.units,"units"),this.activation=gr(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=bt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=bt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Gt(e.kernelConstraint),this.biasConstraint=Gt(e.biasConstraint),this.kernelRegularizer=wt(e.kernelRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const s=(e=Xe(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[s,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:s}}],this.built=!0}computeOutputShape(e){const s=(e=Xe(e)).slice();return s[s.length-1]=this.units,s}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e),a=ux(this.activation.getClassName());let o;return null!=a?o=Ts(r,this.kernel.read(),a,this.bias?this.bias.read():null):(o=Ts(r,this.kernel.read()),null!=this.bias&&(o=us(o,this.bias.read())),null!=this.activation&&(o=this.activation.apply(o))),o})}getConfig(){const e={units:this.units,activation:mr(this.activation),useBias:this.useBias,kernelInitializer:It(this.kernelInitializer),biasInitializer:It(this.biasInitializer),kernelRegularizer:dt(this.kernelRegularizer),biasRegularizer:dt(this.biasRegularizer),activityRegularizer:dt(this.activityRegularizer),kernelConstraint:Ut(this.kernelConstraint),biasConstraint:Ut(this.biasConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dense",n})();ee(Ab),ee((()=>{class n extends We{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Xe(e);for(const s of e.slice(1))if(null==s)throw new D(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],dr(e,1)]}call(e,s){return L(()=>{this.invokeCallHook(e,s);let r=$e(e);if("channelsFirst"===this.dataFormat&&r.rank>1){const a=[0];for(let o=2;o<r.rank;++o)a.push(o);a.push(1),r=qe(r,a)}return function zE(n){if(n.rank<=1)throw new D(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],dr(n.shape,1)];return O(n,t)}(r)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const s=super.getConfig();return Object.assign(e,s),e}}return n.className="Flatten",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.supportsMasking=!0,this.activation=gr(e.activation)}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e);return this.activation.apply(r)})}getConfig(){const e={activation:mr(this.activation)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Activation",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,s){return L(()=>function ME(n,t){return L(()=>{if(2!==n.shape.length)throw new D(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return Op(vi(n,1),[1,t,1])})}(e=$e(e),this.n))}getConfig(){const e={n:this.n},s=super.getConfig();return Object.assign(e,s),e}}return n.className="RepeatVector",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.targetShape=e.targetShape;for(let s=0;s<this.targetShape.length;++s)this.isUnknown(this.targetShape[s])&&(this.targetShape[s]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,s){const r="Total size of new array must be unchanged.",a=s.slice();let o=1,i=null;for(let u=0;u<a.length;++u){const c=a[u];if(this.isUnknown(c)){if(null!==i)throw new D("Can only specifiy one unknown dimension.");i=u}else o*=c}const l=dr(e);if(null!==i){if(0===o||l%o!=0)throw new D(r);a[i]=l/o}else if(l!==o)throw new D(r);return a}computeOutputShape(e){let s=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){s=!0;break}return s?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e),a=r.shape,o=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return O(r,o)})}getConfig(){const e={targetShape:this.targetShape},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Reshape",n})()),ee((()=>{class n extends We{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const s=is(1,e.dims.length+1);if(!Qe(e.dims.slice().sort(),s))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Wt({ndim:this.dims.length+1})]}computeOutputShape(e){const s=(e=Xe(e)).slice();return this.dims.forEach((r,a)=>{s[a+1]=e[r]}),s}call(e,s){return qe($e(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Permute",n})()),ee((()=>{class n extends We{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={maskValue:this.maskValue};return Object.assign(s,e),s}computeMask(e,s){const r=$e(e);return Th(ui(r,this.maskValue),-1)}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e),i=Th(ui(r,this.maskValue),-1,!0);return A(r,de(i,r.dtype))})}}return n.className="Masking",n})()),ee((()=>{class n extends We{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=null==e.inputLength?[s,null]:[s].concat(nt(e.inputLength))}this.inputDim=e.inputDim,Yt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Yt(this.outputDim,"outputDim"),this.embeddingsInitializer=bt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wt(e.embeddingsRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.embeddingsConstraint=Gt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,s){return L(()=>this.maskZero?(e=$e(e),ui(e,je(e))):null)}computeOutputShape(e){if(e=Xe(e),null==this.inputLength)return[...e,this.outputDim];const s=nt(this.inputLength);if(s.length!==e.length-1)throw new D(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let a=0;a<s.length;++a){const o=s[a],i=e[a+1];if(null!=o&&null!=i&&o!==i)throw new D(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==o&&(s[r]=i),r++}}return[e[0],...s,this.outputDim]}call(e,s){return L(()=>{this.invokeCallHook(e,s);let r=$e(e);"int32"!==r.dtype&&(r=Is(r,"int32"));const a=xx(this.embeddings.read(),O(r,[r.size]));return O(a,Xe(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:It(this.embeddingsInitializer),embeddingsRegularizer:dt(this.embeddingsRegularizer),activityRegularizer:dt(this.activityRegularizer),embeddingsConstraint:Ut(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Embedding",n})());class Jr extends We{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Pe}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],o=e[r];if(null==a||null==o||a<0||o<0)s.push(null);else if(1===a)s.push(o);else if(1===o)s.push(a);else{if(a!==o)throw new D("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(a)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[Xe(t)]),(t=t).length<2)throw new D(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=cr(e),e.length>1)throw new D(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const o=null==t[a]?null:t[a].slice(1);s=this.computeElementwiseOpOutputShape(s,o)}const r=t.map(a=>a.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==cr(r).length}call(t,e){return L(()=>{if(t=t,this.reshapeRequired){const s=[],r=t.map(a=>a.rank);if(-1===r.indexOf(null)){const a=hr(r);for(let o of t){const i=o.rank;for(let l=0;l<a-i;++l)o=vi(o,1);s.push(o)}return this.mergeFunction(s)}{let a=!1;for(const l of t){const u=l.rank;if(null==u){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=O(l,[d].concat(dr(c.slice(1))));p=qe(p,[1,0]),p=O(p,h),s.push(p),a=!0}else if(u>1){const c=is(1,u).concat([0]);s.push(qe(l,c)),a=!0}else s.push(l)}let o=this.mergeFunction(s);const i=o.rank;if(a)if(null==i){const l=o.shape,c=l[l.length-1],d=[c].concat(l.slice(0,l.length-1));o=O(qe(O(o,[-1,c]),[1,0]),d)}else if(i>1){const l=[i-1].concat(is(0,i-1));o=qe(o,l)}return o}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==(t=t)[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const a=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,a)}let s=[];for(const r of t)null!=r&&null!==r[0]&&s.push(r[0]);return s=cr(s),e=1===s.length?s.concat(e):[null].concat(e),e}computeMask(t,e){return L(()=>{if(null==e)return null;if(!Array.isArray(e))throw new D("`mask` should be an Array");if(!Array.isArray(t))throw new D("`inputs` should be an Array");if(e.length!==t.length)throw new D(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>null==r))return null;let s=(e=e.map(r=>null==r?r:Nn(r,0)))[0];for(let r=1;r<e.length-1;++r)s=Ms(s,e[r]);return s})}}function $i(n,t){for(;n<0;)n+=t;return n}function Ei(n,t,e,s,r,a=.001){let o;if(2===n.rank)o=cI(n,t,e,s,r,a);else if(3===n.rank)o=hI(n,t,e,s,r,a);else{if(4!==n.rank)throw new Pe(`batchNormalization is not implemented for array of rank ${n.rank} yet`);o=fI(n,t,e,s,r,a)}return o}function sc(n,t,e,s,r,a){return L(()=>{let o;Rt(r),dx(a),Bn(s),null==e&&(e=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),n=cf(n,r);const i="same"===s?"same":"valid";return o="max"===a?Oh(n,t,e,i):_h(n,t,e,i),"channelsFirst"===r&&(o=qe(o,[0,3,1,2])),o})}function jb(n,t,e,s,r,a){return L(()=>{let o;Rt(r),dx(a),Bn(s),null==e&&(e=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),n=fb(n,r);const i="same"===s?"same":"valid";return o="max"===a?aT(n,t,e,i):oI(n,t,e,i),"channelsFirst"===r&&(o=qe(o,[0,4,1,2,3])),o})}ee((()=>{class n extends Jr{constructor(e){super(e)}mergeFunction(e){return L(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=te(s,e[r]);return s})}}return n.className="Add",n})()),ee((()=>{class n extends Jr{constructor(e){super(e)}mergeFunction(e){return L(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=A(s,e[r]);return s})}}return n.className="Multiply",n})()),ee((()=>{class n extends Jr{constructor(e){super(e)}mergeFunction(e){return L(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=te(s,e[r]);return A(1/e.length,s)})}}return n.className="Average",n})()),ee((()=>{class n extends Jr{constructor(e){super(e)}mergeFunction(e){return L(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=or(s,e[r]);return s})}}return n.className="Maximum",n})()),ee((()=>{class n extends Jr{constructor(e){super(e)}mergeFunction(e){return L(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=Na(s,e[r]);return s})}}return n.className="Minimum",n})()),ee((()=>{class n extends Jr{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new D("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let s=!0;for(const a of e)if(null!=a){s=!1;break}if(s)return;const r=[];for(let a=0;a<e.length;++a){const o=e[a].slice();o.splice(this.axis,1);let i=!1;for(const l of r)if(Qe(l,o)){i=!0;break}i||r.push(o)}if(r.length>1)throw new D("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return L(()=>Fp(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new D("A `Concatenate` layer should be called on a list of inputs.");const s=e,r=s[0].slice(),a=this.axis<0?r.length+this.axis:this.axis;for(const o of s.slice(1)){if(null==r[a]||null==o[a]){r[a]=null;break}r[a]+=o[a]}return r}computeMask(e,s){if(null==s)return null;if(!Array.isArray(s))throw new D("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new D("`inputs` should be an array for Concatenate");if(s.length!==e.length)throw new D(`Mismatch in the length of mask (${s.length}) and the legnth of inputs (${e.length})`);return L(()=>{let r=!0;if(s.forEach(i=>{null==i||(r=!1)}),r)return null;const a=[];for(let i=0;i<e.length;++i)a.push(null==s[i]?de(Zn(e[i]),"bool"):s[i].rank<e[i].rank?Nn(s[i],-1):s[i]);const o=dn(a,this.axis);return zg(o,-1,!1)})}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Concatenate",n})()),ee((()=>{class n extends Jr{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){I(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0],r=e[1];if(s.length>3||r.length>3)throw new Pe("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(s,r);if(s[a[0]]!==r[a[1]])throw new D(`Dimension incompatibility: ${s[a[0]]} !== ${r[a[1]]}`)}mergeFunction(e){if(2!==e.length)throw new D(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let a,s=e[0],r=e[1];return a=Array.isArray(this.axes)?this.axes.map((o,i)=>$i(o,e[i].shape.length)):[$i(this.axes,s.shape.length),$i(this.axes,r.shape.length)],this.normalize&&(s=zu(s,a[0]),r=zu(r,a[1])),function oD(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new Pe("batchDot is not implemented for tensors of 4D or higher rank yet");if(I(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),I(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new Pe("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;null==e&&(e=[s-1,r-2]);const a=e;return L(()=>{let o,i;if(s>r){o=s-r;const l=[];for(let u=0;u<o;++u)l.push(1);t=O(t,t.shape.concat(l))}else if(r>s){o=r-s;const l=[];for(let u=0;u<o;++u)l.push(1);n=O(n,n.shape.concat(l))}else o=0;if(i=2===n.shape.length&&2===t.shape.length?a[0]===a[1]?ve(A(n,t),a[0]):ve(A(qe(n,[1,0]),t),a[1]):et(n,t,a[0]!==n.shape.length-1,a[1]===t.shape.length-1),o>0){let l;l=s>r?s+r-3:s-1;const u=[];for(let c=l;c<l+o;++c)u.push(c);i=pi(i,u)}return 1===i.shape.length&&(i=Nn(i,1)),i})}(s,r,a)}interpretAxes(e,s){let r;return r=Array.isArray(this.axes)?this.axes:[$i(this.axes,e.length),$i(this.axes,s.length)],r}computeOutputShape(e){I(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0].slice(),r=e[1].slice();if(s.length>3||r.length>3)throw new Pe("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(s,r);s.splice(a[0],1),r.splice(a[1],1),r.splice(0,1);const o=s.concat(r);return 1===o.length&&o.push(1),o}computeMask(e,s){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dot",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={stddev:this.stddev};return Object.assign(s,e),s}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e);return Si(()=>te(Fu(r.shape,0,this.stddev),r),()=>r,s.training||!1)})}}return n.className="GaussianNoise",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return L(()=>{this.invokeCallHook(e,s);const r=$e(e);return this.rate>0&&this.rate<1?Si(()=>{const o=Math.sqrt(this.rate/(1-this.rate));return A(r,Fu(r.shape,1,o))},()=>r,s.training||!1):r})}}return n.className="GaussianDropout",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||$e(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return L(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return Si(()=>{const o=$e(e),u=-1.7580993408473766;let c=Wr(ci(r),this.rate);c=Is(c,"float32");const d=((1-this.rate)*(1+this.rate*u**2))**-.5,h=-d*u*this.rate,p=te(A(o,c),A(te(c,-1),u));return te(A(p,d),h)},()=>$e(e),s.training||!1)}return e})}}return n.className="AlphaDropout",n})()),ee((()=>{class n extends We{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=bt(e.betaInitializer||"zeros"),this.gammaInitializer=bt(e.gammaInitializer||"ones"),this.movingMeanInitializer=bt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=bt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Gt(e.betaConstraint),this.gammaConstraint=Gt(e.gammaConstraint),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer)}build(e){e=Xe(e);const s=this.axis>=0?this.axis:this.axis+e.length,r=e[s];if(null==r)throw new D(`Axis ${s} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Wt({ndim:e.length,axes:{[s]:r}})];const a=[r];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,s){return L(()=>{const r=null!=s.training&&s.training,a=$e(e),o=a.shape,i=o.length,l=is(0,i),u=this.axis>=0?this.axis:this.axis+i;l.splice(u,1);const c=qr(1,i);c[u]=o[u];const d=l.slice();d.sort();const h=!Qe(d,is(0,i).slice(0,i-1));if(!r)return(()=>{if(h){const b=O(this.movingMean.read(),c),w=O(this.movingVariance.read(),c),C=this.center?O(this.beta.read(),c):null,S=this.scale?O(this.gamma.read(),c):null;return Ei(a,b,w,C,S,this.epsilon)}return Ei(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[f,g,m]=function uD(n,t,e,s,r=.001){return Qe(s.slice().sort(),is(0,n.rank-1))?function iD(n,t,e,s,r=.001){return L(()=>{const a=Ph(n,s),o=a.mean,i=a.variance;return[Ei(n,o,i,e,t,r),o,i]})}(n,t,e,s,r):function lD(n,t,e,s,r=.001){return L(()=>{const a=Ph(n,s),o=a.mean,i=a.variance,l=[];for(const f of is(0,n.rank))-1!==s.indexOf(f)?l.push(1):l.push(n.shape[f]);const u=O(o,l),c=O(i,l),d=null==t?null:O(t,l),h=null==e?null:O(e,l);return[Ei(n,u,c,h,d,r),o,i]})}(n,t,e,s,r)}(a,this.gamma.read(),this.beta.read(),l,this.epsilon),y=(b,w,C)=>{L(()=>{const S=1-C,T=b.read(),k=A(ye(T,w),S);b.write(ye(T,k))})};return(()=>{y(this.movingMean,g,this.momentum),y(this.movingVariance,m,this.momentum)})(),f})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:It(this.betaInitializer),gammaInitializer:It(this.gammaInitializer),movingMeanInitializer:It(this.movingMeanInitializer),movingVarianceInitializer:It(this.movingVarianceInitializer),betaRegularizer:dt(this.betaRegularizer),gammaRegularizer:dt(this.gammaRegularizer),betaConstraint:Ut(this.betaConstraint),gammaConstraint:Ut(this.gammaConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BatchNormalization",n})()),ee((()=>{class n extends We{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const s of this.axis)if(!Number.isInteger(s))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=bt(e.betaInitializer||"zeros"),this.gammaInitializer=bt(e.gammaInitializer||"ones"),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer),this.supportsMasking=!0}build(e){const s=(e=Xe(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=s);for(const o of this.axis)if(o<0||o>=s)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==cr(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(o=>e[o]);this.gamma=this.scale?this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,s){const r=$e(e),a=r.shape,o=a.length;return L(()=>{let{mean:l,variance:u}=Ph(r,this.axis,!0);const c=qr(1,o);for(const m of this.axis)c[m]=a[m];const d=m=>null!=m&&m.shape.length!==o?O(m,c):m;let h=this.scale?d(this.gamma.read()):null,p=this.center?d(this.beta.read()):null;const f=[],g=[];for(let m=0;m<o;++m)-1!==this.axis.indexOf(m)?(f.push(a[m]),g.push(1)):(f.push(1),g.push(a[m]));return l=as(l,f),u=as(u,f),null!=h&&(h=as(h,g)),null!=p&&(p=as(p,g)),Ei(r,l,u,p,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:It(this.betaInitializer),gammaInitializer:It(this.gammaInitializer),betaRegularizer:dt(this.betaRegularizer),gammaRegularizer:dt(this.gammaRegularizer)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LayerNormalization",n})()),ee((()=>{class n extends We{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new D(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let s,r;if("number"==typeof e.padding[0])s=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new D(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(s=e.padding[0],2!==e.padding[1].length)throw new D(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[s,r]}this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(e){let s,r;return e=Xe(e),"channelsFirst"===this.dataFormat?(s=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],s,r]):(s=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],s,r,e[3]])}call(e,s){return L(()=>function cD(n,t,e){return L(()=>{if(4!==n.rank)throw new D(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new D("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new D(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return s="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],Lh(n,s)})}($e(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ZeroPadding2D",n})());class qb extends We{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new D(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Yt(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new D(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Yt(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,Bn(this.padding),this.inputSpec=[new Wt({ndim:3})]}computeOutputShape(t){const e=hs((t=Xe(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return L(()=>{this.invokeCallHook(t,e),t=vi($e(t),2);const s=this.poolingFunction($e(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return pi(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}ee((()=>{class n extends qb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),sc(e,s,r,a,o,"max")}}return n.className="MaxPooling1D",n})()),ee((()=>{class n extends qb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),sc(e,s,r,a,o,"avg")}}return n.className="AveragePooling1D",n})());class Zb extends We{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new D(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Yt(this.poolSize,"poolSize"),Yt(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Rt(this.dataFormat),Bn(this.padding),this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(t){t=Xe(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2];return e=hs(e,this.poolSize[0],this.padding,this.strides[0]),s=hs(s,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return L(()=>(this.invokeCallHook(t,e),this.poolingFunction($e(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ee((()=>{class n extends Zb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),sc(e,s,r,a,o,"max")}}return n.className="MaxPooling2D",n})()),ee((()=>{class n extends Zb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),sc(e,s,r,a,o,"avg")}}return n.className="AveragePooling2D",n})());class Qb extends We{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new D(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Yt(this.poolSize,"poolSize"),Yt(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Rt(this.dataFormat),Bn(this.padding),this.inputSpec=[new Wt({ndim:5})]}computeOutputShape(t){t=Xe(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=hs(e,this.poolSize[0],this.padding,this.strides[0]),s=hs(s,this.poolSize[1],this.padding,this.strides[1]),r=hs(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return L(()=>(this.invokeCallHook(t,e),this.poolingFunction($e(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ee((()=>{class n extends Qb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),jb(e,s,r,a,o,"max")}}return n.className="MaxPooling3D",n})()),ee((()=>{class n extends Qb{constructor(e){super(e)}poolingFunction(e,s,r,a,o){return Rt(o),Bn(a),jb(e,s,r,a,o,"avg")}}return n.className="AveragePooling3D",n})());class n0 extends We{constructor(t){super(t),this.inputSpec=[new Wt({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Pe}}ee((()=>{class n extends n0{constructor(e){super(e||{})}call(e,s){return L(()=>{const r=$e(e);return Dt(r,1)})}}return n.className="GlobalAveragePooling1D",n})()),ee((()=>{class n extends n0{constructor(e){super(e||{})}call(e,s){return L(()=>{const r=$e(e);return os(r,1)})}}return n.className="GlobalMaxPooling1D",n})());class a0 extends We{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Rt(this.dataFormat),this.inputSpec=[new Wt({ndim:4})]}computeOutputShape(t){return t=t,"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new Pe}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}ee((()=>{class n extends a0{call(e,s){return L(()=>{const r=$e(e);return Dt(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})()),ee((()=>{class n extends a0{call(e,s){return L(()=>{const r=$e(e);return os(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})());class u0 extends We{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const a=qs(e.layer,s);delete e.layer;const o={layer:a};return Object.assign(o,e),new t(o)}}ee((()=>{class n extends u0{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=Xe(e)).length<3)throw new D(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const s=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(s),this.layer.built=!0),super.build(e)}computeOutputShape(e){const s=[(e=Xe(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(s);return[r[0],e[1]].concat(r.slice(1))}call(e,s){return L(()=>Tb((i,l)=>[$e(this.layer.call(i,s)),[]],e=$e(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})()),ee((()=>{class n extends u0{constructor(e){super(e);const s=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=s,this.forwardLayer=qs(r),s.goBackwards=!0!==s.goBackwards;const a={};if(a.className=e.layer.getClassName(),a.config=s,this.backwardLayer=qs(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function dD(n){Xr(AE,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new Pe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const r=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let r,a,o,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),s=s,this.returnState&&(o=s.slice(1)),r=s[0],r=r,"concat"===this.mergeMode?(r[r.length-1]*=2,a=[r]):a=null==this.mergeMode?[r,r.slice()]:[r],this.returnState?null==this.mergeMode?a.concat(o).concat(o.slice()):[r].concat(o).concat(o.slice()):kn(a)}apply(e,s){let r=null==s?null:s.initialState,a=null==s?null:s.constants;null==s&&(s={});const o=Ib(e,r,a,this.numConstants);if(e=o.inputs,r=o.initialState,a=o.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==a)return super.apply(e,s);const i=[],l=[];if(null!=r){const c=r.length;if(c%2>0)throw new D("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");s.initialState=r,i.push(...r);const d=r.map(h=>new Wt({shape:h.shape}));this.forwardLayer.stateSpec=d.slice(0,c/2),this.backwardLayer.stateSpec=d.slice(c/2),l.push(...d)}if(null!=a)throw new Pe("Support for constants in Bidirectional layers is not implemented yet.");const u=i[0]instanceof ks;for(const c of i)if(c instanceof ks!==u)throw new D("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const c=[e].concat(i),d=this.inputSpec.concat(l),h=this.inputSpec;this.inputSpec=d;const p=super.apply(c,s);return this.inputSpec=h,p}return super.apply(e,s)}call(e,s){return L(()=>{const r=s.initialState;let a,o,i,l;if(null==r)a=this.forwardLayer.call(e,s),o=this.backwardLayer.call(e,s);else{const u=r.slice(0,r.length/2),c=r.slice(r.length/2);a=this.forwardLayer.call(e,Object.assign(s,{initialState:u})),o=this.backwardLayer.call(e,Object.assign(s,{initialState:c}))}return this.returnState&&(Array.isArray(a)&&(i=a.slice(1).concat(o.slice(1))),a=a[0],o=o[0]),this.returnSequences&&(o=Ur(o,1)),"concat"===this.mergeMode?l=Fp([a,o]):"sum"===this.mergeMode?l=te(a,o):"ave"===this.mergeMode?l=A(.5,te(a,o)):"mul"===this.mergeMode?l=A(a,o):null==this.mergeMode&&(l=[a,o]),this.returnState?null==this.mergeMode?l.concat(i):[l].concat(i):l})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Zr(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Zr(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,s){let r;if(Array.isArray(s)&&(s=s[0]),r=this.returnSequences?null==this.mergeMode?[s,s]:s:null==this.mergeMode?[null,null]:null,this.returnState){const o=this.forwardLayer.states.map(i=>null);return Array.isArray(r)?r.concat(o).concat(o):[r].concat(o).concat(o)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},s=super.getConfig();return Object.assign(e,s),e}static fromConfig(e,s){const r=qs(s.layer);if(delete s.layer,null!=s.numConstants)throw new Pe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=s;return a.layer=r,new e(a)}}return n.className="Bidirectional",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return L(()=>("float32"!==(e=$e(e)).dtype&&(e=Is(e,"float32")),te(A(e,this.scale),this.offset)))}}return n.className="Rescaling",n})());const{resizeBilinear:pD,cropAndResize:fD}=Us;ee((()=>{class n extends We{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,s,r,a,o,i,l,u){return L(()=>{let c,d=!1;const m=[s/i,r/l,(a+s)/i,(o+r)/l],y=[];3===e.rank?(d=!0,c=Bs([e])):c=e;for(let S=0;S<c.shape[0];S++)y.push(m);const x=ni(y,[y.length,4]),b=di(0,y.length,1,"int32"),C=fD(c,x,b,[a,o],"nearest");return Is(d?$e(Gr(C)):C,u)})}upsize(e,s,r,a){return L(()=>Is(pD(e,[s,r]),a))}call(e,s){return L(()=>{const r=$e(e),a=r.dtype,o=r.shape,i=o[o.length-3],l=o[o.length-2];let u=0;i!==this.height&&(u=Math.floor((i-this.height)/2));let c=0;return l!==this.width&&(c=Math.floor((l-this.width)/2),0===c&&(c=1)),u>=0&&c>=0?this.centerCrop(r,u,c,this.height,this.width,i,l,a):this.upsize(e,this.height,this.width,a)})}getConfig(){const e={height:this.height,width:this.width},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){const r=(e=Xe(e)).length-2;return e[e.length-3]=this.height,e[r]=this.width,e}}return n.className="CenterCrop",n})()),ee((()=>{class n extends We{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return null==(e=Xe(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,s){return L(()=>{let r;if("int32"!==(e=$e(e)).dtype&&(e=Is(e,"int32")),void 0!==s.countWeights){if("count"!==this.outputMode)throw new D(`countWeights is not used when outputMode !== count.\n              Received countWeights=${s.countWeights}`);r=$e(s.countWeights)}const a=os(e),o=mu(e),i=Mn(this.numTokens,a).bufferSync().get(0),l=Wr(o,0).bufferSync().get(0);if(!i||!l)throw new D(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function mD(n,t,e,s){let r=$e(n);if("int32"!==r.dtype&&(r=Is(r,"int32")),"int"===t)return r;const a=r.shape;if(0===r.rank&&(r=Nn(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=Nn(r,-1)),r.rank>2)throw new D(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${r.rank}.`);const o=["multiHot","oneHot"].includes(t);let l;if(l=Gg(r,void 0!==s&&"count"===t?s:[],e,o),"tfIdf"!==t)return l;if(s)return A(l,s);throw new D("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,r)})}}return n.className="CategoryEncoding",n})());const m0=new Set(["bilinear","nearest"]);ee((()=>{class n extends We{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!m0.has(e.interpolation))throw new D(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){return e=Xe(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return L(()=>{const r=[this.height,this.width];if("bilinear"===this.interpolation)return Us.resizeBilinear(e,r,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Us.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...m0]} are supported`)})}}return n.className="Resizing",n})());let yD=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),xD=(()=>{class n extends We{constructor(e){super(e),this.randomGenerator=new yD(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BaseRandomLayer",n})();const y0=new Set(["bilinear","nearest"]);function bf(n){return new Ab(n)}var S0;function xe(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&I("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}ee((()=>{class n extends xD{constructor(e){super(e);const{factor:s,interpolation:r="bilinear"}=e;if(this.factor=s,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new D(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new D(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new D(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(r){if(!y0.has(r))throw new D(`Invalid interpolation parameter: ${r} is not implemented`);this.interpolation=r}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return e=Xe(e),[this.imgHeight,-1,e[2]]}call(e,s){return L(()=>{const r=$e(e);this.imgHeight=r.shape[r.shape.length-3];const a=r.shape[r.shape.length-2];this.widthFactor=ci([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let o=this.widthFactor.dataSync()[0]*a;o=Math.round(o);const i=[this.imgHeight,o];switch(this.interpolation){case"bilinear":return Us.resizeBilinear(e,i);case"nearest":return Us.resizeNearestNeighbor(e,i);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...y0]} are supported`)}})}}return n.className="RandomWidth",n})()),V().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(S0||(S0={})),Error,Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const dR=Uy;let hR=(()=>{class n extends Mc{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new lm(this,xs())}write(e,s,r){this.firstUse&&(this.firstUse=!1,V().get("IS_NODE")&&On("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:r,refCount:1}),a}makeTensorInfo(e,s,r){let a;if("string"===s&&null!=r&&r.length>0&&eo(r[0])){const o=r.map(i=>tr(i));a=this.write(o,e,s)}else a=this.write(r,e,s);return{dataId:a,shape:e,dtype:s}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,s,r,a,o){this.data.set(e,{values:s,dtype:a,refCount:o})}numDataIds(){return this.data.numDataIds()}read(e){var s=this;return Z(function*(){return s.readSync(e)})()}readSync(e){const{dtype:s,complexTensorInfos:r}=this.data.get(e);return"complex64"===s?Gs(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)):function tC(n,t){if(Array.isArray(n))return n;if("float32"===t)return n instanceof Float32Array?n:new Float32Array(n);if("int32"===t)return n instanceof Int32Array?n:new Int32Array(n);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,s)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(a=>nr(a));return Be(e.shape,e.dtype,r)}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Be(e.shape,e.dtype,s)}makeOutput(e,s,r){return xs().makeTensorFromTensorInfo(this.makeTensorInfo(s,r,e),this)}disposeData(e,s=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!s&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return Z(function*(){const s=In();return e(),{kernelMs:In()-s}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){xe([e],"where");const s=this.readSync(e.dataId);return dR(e.shape,s)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function $s(n){return(t,e,s)=>{const r=$t(e,t.length);for(let a=0;a<t.length;++a)r[a]=n(t[a],s);return r}}function rt(n,t,e){return xr(n,$s(t),e)}function xr(n,t,e){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;xe(o,n);const i=a,l=i.data.get(o.dataId).values;let u;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Hs(l)}else u=l;const c=e||o.dtype,d=t(u,c,r);return i.makeTensorInfo(o.shape,c,d)}}Qm("cpu",()=>new hR,1);const tw=rt(go,n=>n>=0?n:Math.exp(n)-1),fR={kernelName:go,backendName:"cpu",kernelFunc:tw};function Es(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const mR={kernelName:So,backendName:"cpu",kernelFunc:Es};function nw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:a}=s;xe([r],"leakyRelu");const o=W(r.shape),i=e.data.get(r.dataId).values,l=ln("float32",o);for(let u=0;u<i.length;u++)l[u]=i[u]<0?a*i[u]:i[u];return e.makeTensorInfo(r.shape,"float32",l)}const gR={kernelName:hl,backendName:"cpu",kernelFunc:nw};function Ft(n){return(t,e,s,r,a)=>{const o=Oe(t,e),i=o.length,l=Ie(o),c=ln(a,W(o)),d=t.length,h=e.length,p=Ie(t),f=Ie(e),g=Ia(t,o),m=Ia(e,o);if(g.length+m.length===0)for(let y=0;y<c.length;++y)c[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<c.length;++y){const x=fa(y,i,l),b=x.slice(-d);g.forEach(T=>b[T]=0);const w=gs(b,d,p),C=x.slice(-h);m.forEach(T=>C[T]=0);const S=gs(C,h,f);c[y]=n(s[w],r[S])}return[c,o]}}const yR=Ft((n,t)=>n<0?t*n:n);function sw(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;xe([s,r],"prelu");const a=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,[i,l]=yR(s.shape,r.shape,a,o,"float32");return e.makeTensorInfo(l,"float32",i)}const xR={kernelName:Al,backendName:"cpu",kernelFunc:sw},rw=rt(Oo,n=>Math.max(0,n)),bR={kernelName:Oo,backendName:"cpu",kernelFunc:rw},aw=rt(Po,n=>Math.min(Math.max(0,n),6)),wR={kernelName:Po,backendName:"cpu",kernelFunc:aw},vR=$s(n=>1/(1+Math.exp(-n))),ow=rt(Uo,n=>1/(1+Math.exp(-n))),CR={kernelName:Uo,backendName:"cpu",kernelFunc:ow};function cc(n,t,e,s,r){if("linear"===e)return Es({inputs:{x:t},backend:n});if("relu"===e)return rw({inputs:{x:t},backend:n});if("elu"===e)return tw({inputs:{x:t},backend:n});if("relu6"===e)return aw({inputs:{x:t},backend:n});if("prelu"===e)return sw({inputs:{x:t,alpha:s},backend:n});if("leakyrelu"===e)return nw({inputs:{x:t},backend:n,attrs:{alpha:r}});if("sigmoid"===e)return ow({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Dn(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,a=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,i=e.makeTensorInfo(s.shape,"complex64");return e.data.get(i.dataId).complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",a),imag:e.makeTensorInfo(r.shape,"float32",o)},i}const SR={kernelName:td,backendName:"cpu",kernelFunc:Dn};function dc(n,t,e="float32"){if("complex64"===e)return Dn({inputs:{real:dc(n,t,"float32"),imag:dc(n,t,"float32")},backend:n});const s=un(W(t),e);return n.makeTensorInfo(t,e,s)}function ea(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,a=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,a)}const IR={kernelName:kd,backendName:"cpu",kernelFunc:ea};function iw(n,t,e,s){if("int32"===s)return[t,"int32",Int32Array.from(n)];if("bool"===s){const r=Dr([0],e),[a,o]=Ft((i,l)=>i!==l?1:0)(t,[],n,r,"bool");return[o,"bool",a]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function br(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return Es({inputs:{x:r},backend:e});const c=dc(e,r.shape,r.dtype),d=br({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),h=Dn({inputs:{real:d,imag:c},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),h}if("complex64"===r.dtype){const c=ea({inputs:{input:r},backend:e}),d=br({inputs:{x:c},backend:e,attrs:{dtype:a}});return e.disposeIntermediateTensorInfo(c),d}if(!pm(r.dtype,a)){const c=Es({inputs:{x:r},backend:e});return{dataId:c.dataId,shape:c.shape,dtype:a}}const o=e.data.get(r.dataId).values,[i,l,u]=iw(o,r.shape,r.dtype,a);return e.makeTensorInfo(i,l,u)}const TR={kernelName:uo,backendName:"cpu",kernelFunc:br};function Ht(n,t,e,s){return null==e?({inputs:r,backend:a})=>{const{a:o,b:i}=r,l=a;xe([o,i],n);const u=l.data.get(o.dataId).values,c=l.data.get(i.dataId).values,d="string"===o.dtype?Hs(u):u,h="string"===o.dtype?Hs(c):c,p=s||o.dtype,[f,g]=t(o.shape,i.shape,d,h,p);return l.makeTensorInfo(g,p,f)}:({inputs:r,backend:a})=>{const{a:o,b:i}=r,l=a;if("complex64"===o.dtype||"complex64"===i.dtype){const u=br({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),h=c.complexTensorInfos.imag,p=l.data.get(c.complexTensorInfos.real.dataId).values,f=l.data.get(h.dataId).values,g=br({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(g.dataId),x=m.complexTensorInfos.imag,b=l.data.get(m.complexTensorInfos.real.dataId).values,w=l.data.get(x.dataId).values,[C,S,T]=e(o.shape,i.shape,p,f,b,w),k=l.makeTensorInfo(T,"float32",C),$=l.makeTensorInfo(T,"float32",S),E=Dn({inputs:{real:k,imag:$},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(k),l.disposeIntermediateTensorInfo($),E}{const u=l.data.get(o.dataId).values,c=l.data.get(i.dataId).values,d=s||o.dtype,[h,p]=t(o.shape,i.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function Ef(n){return(t,e,s,r,a,o)=>{const i=Oe(t,e),l=W(i),u=i.length,c=Ie(i),d=ln("float32",l),h=ln("float32",l),p=Ia(t,i),f=Ia(e,i),g=Gs(s,r),m=Gs(a,o),y=t.length,x=Ie(t),b=e.length,w=Ie(e);if(p.length+f.length===0)for(let C=0;C<d.length;C++){const S=C%g.length,T=C%m.length,k=n(g[2*S],g[2*S+1],m[2*T],m[2*T+1]);d[C]=k.real,h[C]=k.imag}else for(let C=0;C<d.length;C++){const S=fa(C,u,c),T=S.slice(-y);p.forEach(z=>T[z]=0);const k=gs(T,y,x),$=S.slice(-b);f.forEach(z=>$[z]=0);const E=gs($,b,w),P=n(g[2*k],g[2*k+1],m[2*E],m[2*E+1]);d[C]=P.real,h[C]=P.imag}return[d,h,i]}}const lw=Ft((n,t)=>n+t),NR=Ef((n,t,e,s)=>({real:n+e,imag:t+s})),Ma=Ht(ma,lw,NR),kR={kernelName:ma,backendName:"cpu",kernelFunc:Ma};function ft(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:a}=s,o=W(r.shape),i=hm(a,o),l=W(i);I(o===l,()=>`The new shape (${i}) has ${l} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const u=e.data.get(r.dataId);if(null!=u.complexTensorInfos){const d=u.complexTensorInfos.imag;u.complexTensorInfos.real.shape=i,d.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const _R={kernelName:Rl,backendName:"cpu",kernelFunc:ft};function uw(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a}=t,{transposeA:o,transposeB:i}=s;xe([r,a],"matMul");const l=r.shape.length,u=a.shape.length,c=o?r.shape[l-2]:r.shape[l-1],d=i?a.shape[u-1]:a.shape[u-2],h=o?r.shape[l-1]:r.shape[l-2],p=i?a.shape[u-2]:a.shape[u-1],f=r.shape.slice(0,-2),g=a.shape.slice(0,-2),m=W(f),y=W(g),b=Oe(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);I(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const C=i?[y,p,d]:[y,d,p],S=ft({inputs:{x:r},backend:e,attrs:{shape:o?[m,c,h]:[m,h,c]}}),T=ft({inputs:{x:a},backend:e,attrs:{shape:C}}),k=o?S.shape[1]:S.shape[2],$=o?S.shape[2]:S.shape[1],E=i?T.shape[1]:T.shape[2],P=Math.max(m,y),z=e.data.get(S.dataId).values,B=e.data.get(T.dataId).values,U=Ie(S.shape),G=Ie(T.shape),[q,K,H]=o?[U[0],1,U[1]]:[U[0],U[1],1],[X,ne,re]=i?[1,G[1],G[0]]:[G[1],1,G[0]],ie=$*E,oe=Be([P,$,E],S.dtype),pe=oe.values,le=e.blockSize;for(let me=0;me<P;me++){const Te=me%m,Ee=me%y;for(let ke=0;ke<$;ke+=le){const Me=Math.min(ke+le,$);for(let Ve=0;Ve<E;Ve+=le){const at=Math.min(Ve+le,E);for(let mt=0;mt<k;mt+=le){const kt=Math.min(mt+le,k);for(let gt=ke;gt<Me;gt++)for(let ut=Ve;ut<at;ut++){let Tt=0;for(let vt=mt;vt<kt;vt++)Tt+=z[Te*q+gt*K+vt*H]*B[vt*X+ut*ne+Ee*re];pe[me*ie+(gt*E+ut)]+=Tt}}}}}return e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(T),e.makeTensorInfo(b,oe.dtype,oe.values)}const $R={kernelName:Yi,backendName:"cpu",kernelFunc:uw},AR={kernelName:ql,backendName:"cpu",kernelFunc:function ER(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;let h,p,f;const g=[];h=uw({inputs:{a:r,b:a},attrs:{transposeA:l,transposeB:u},backend:e}),o&&(p=Ma({inputs:{a:h,b:o},backend:e}),g.push(h),h=p),c&&(f=cc(e,h,c,i,d),g.push(h),h=f);for(const y of g)e.disposeIntermediateTensorInfo(y);return h}};function cw(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const DR={kernelName:ji,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;xe(t,"abs");let s=new Float32Array(W(t.shape));return s=cw(e.data.get(t.dataId).values),e.makeOutput(s,t.shape,t.dtype)}},RR=rt(to,n=>Math.acos(n)),FR={kernelName:to,backendName:"cpu",kernelFunc:RR},OR=rt(no,n=>Math.acosh(n)),PR={kernelName:no,backendName:"cpu",kernelFunc:OR},MR={kernelName:Kc,backendName:"cpu",kernelFunc:function LR(n){const{inputs:t,backend:e}=n,s=t;xe(t,"addN");const r=s.map(i=>e.data.get(i.dataId).values),a=Be(s[0].shape,s[0].dtype),o=a.values;for(let i=0;i<s.length;i++){const l=r[i];for(let u=0;u<o.length;u++)o[u]+=l[u]}return e.makeTensorInfo(a.shape,a.dtype,a.values)}};function Af(n,t,e,s,r){const a=t.length,o=W(t),i=Ie(t),l=Ie(r),u=ln(e,W(r));for(let c=0;c<o;++c){const d=fa(c,a,i),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[s[f]];u[gs(h,a,l)]=n[c]}return u}function _n(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:a}=e;xe(r,"transpose");const i=new Array(r.shape.length);for(let d=0;d<i.length;d++)i[d]=r.shape[a[d]];const u=Af(s.data.get(r.dataId).values,r.shape,r.dtype,a,i);return{dataId:s.write(u,i,r.dtype),shape:i,dtype:r.dtype}}const VR={kernelName:ga,backendName:"cpu",kernelFunc:_n},BR={kernelName:"All",backendName:"cpu",kernelFunc:function zR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;xe(r,"all");const i=ze(a,r.shape);let l=i;const u=St(l,r.shape.length);let c=r;null!=u&&(c=_n({inputs:{x:r},backend:e,attrs:{perm:u}}),l=At(l.length,r.shape.length)),sn("all",l,c.shape.length);const[d,h]=Xt(c.shape,l),p=W(h),f=un(W(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let b=g[x];for(let w=0;w<p;++w){const C=g[x+w];b=b&&C}f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(o){const x=ft({inputs:{x:m},backend:e,attrs:{shape:Et(d,i)}});return e.disposeIntermediateTensorInfo(m),x}return m}},UR={kernelName:"Any",backendName:"cpu",kernelFunc:function WR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;xe(r,"any");const i=ze(a,r.shape);let l=i;const u=St(l,r.shape.length);let c=r;null!=u&&(c=_n({inputs:{x:r},backend:e,attrs:{perm:u}}),l=At(l.length,r.shape.length)),sn("any",l,c.shape.length);const[d,h]=Xt(c.shape,l),p=W(h),f=un(W(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let b=g[x];for(let w=0;w<p;++w){const C=g[x+w];b=b||C}f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(o){const x=ft({inputs:{x:m},backend:e,attrs:{shape:Et(d,i)}});return e.disposeIntermediateTensorInfo(m),x}return m}},HR={kernelName:qi,backendName:"cpu",kernelFunc:function GR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;xe(r,"argMax");let o=ze(a,r.shape);const i=St(o,r.shape.length);let l=r;const u=[];null!=i&&(l=_n({inputs:{x:r},backend:e,attrs:{perm:i}}),u.push(l),o=At(o.length,l.shape.length)),o=[o[0]],sn("argMax",o,l.shape.length);const[c,d]=Xt(l.shape,o),p=un(W(c),"int32"),f=W(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let x=g[y],b=0;for(let w=0;w<f;++w){const C=g[y+w];C>x&&(x=C,b=w)}p[m]=b}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},qR={kernelName:Ki,backendName:"cpu",kernelFunc:function jR(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;xe(r,"argMin");let o=ze(a,r.shape);const i=St(o,r.shape.length);let l=r;const u=[];null!=i&&(l=_n({inputs:{x:r},backend:e,attrs:{perm:i}}),u.push(l),o=At(o.length,l.shape.length)),o=[o[0]],sn("argMin",o,l.shape.length);const[c,d]=Xt(l.shape,o),p=un(W(c),"int32"),f=W(d),g=e.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const y=m*f;let x=g[y],b=0;for(let w=0;w<f;++w){const C=g[y+w];C<x&&(x=C,b=w)}p[m]=b}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),e.makeTensorInfo(c,"int32",p)}},KR=rt(so,n=>Math.asin(n)),XR={kernelName:so,backendName:"cpu",kernelFunc:KR},ZR=rt(ro,n=>Math.asinh(n)),YR={kernelName:ro,backendName:"cpu",kernelFunc:ZR},JR=rt(ao,n=>Math.atan(n)),QR={kernelName:ao,backendName:"cpu",kernelFunc:JR},eF=Ft((n,t)=>Math.atan2(n,t)),tF=Ht(lo,eF),nF={kernelName:lo,backendName:"cpu",kernelFunc:tF},sF=rt(oo,n=>Math.atanh(n)),rF={kernelName:oo,backendName:"cpu",kernelFunc:sF};function Df(n,t,e,s,r,a){const o=r.strideHeight,i=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Be(r.outShape,e),m=g.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],b=r.outShape[3];for(let w=0;w<r.batchSize;++w){const C=w*y,S=w*s[0];for(let T=0;T<r.inChannels;++T)for(let k=0;k<r.outHeight;++k){const $=k*o-h,E=Math.max(0,$),P=Math.min(r.inHeight,c+$),z=C+k*x;for(let B=0;B<r.outWidth;++B){const U=B*i-p,G=Math.max(0,U),q=Math.min(r.inWidth,d+U);let K=f,H=0,X=0;for(let re=E;re<P;re+=l){const ie=S+re*s[1];for(let oe=G;oe<q;oe+=u){const le=n[ie+oe*s[2]+T];"max"===a&&le>K?K=le:"avg"===a&&(H+=le,X++)}if(isNaN(K))break}m[z+B*b+T]="avg"===a?H/X:K}}}return g}function dw(n,t,e,s,r=!1,a=!1){const o=Be(s.outShape,"int32"),i=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,d=s.effectiveFilterHeight,h=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=Be(t,e,n);for(let m=0;m<s.batchSize;++m)for(let y=0;y<s.inChannels;++y)for(let x=0;x<s.outHeight;++x){const b=x*i-p;let w=b;for(;w<0;)w+=u;const C=Math.min(s.inHeight,d+b);for(let S=0;S<s.outWidth;++S){const T=S*l-f;let k=T;for(;k<0;)k+=c;const $=Math.min(s.inWidth,h+T);let E=Number.NEGATIVE_INFINITY,P=-1;for(let z=w;z<C;z+=u){const B=z-b;for(let U=k;U<$;U+=c){const G=U-T,q=g.get(m,z,U,y);q>E&&(E=q,P=r?a?((m*s.inHeight+z)*s.inWidth+U)*s.inChannels+y:(z*s.inWidth+U)*s.inChannels+y:B*h+G)}}o.set(P,m,x,S,y)}}return o}function hw(n,t,e,s,r,a){const o=r.strideDepth,i=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,d=r.dilationWidth,h=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,y=r.padInfo.left,x="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Be(r.outShape,e),w=b.values,C=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[2]*r.outShape[3]*r.outShape[4],T=r.outShape[3]*r.outShape[4],k=r.outShape[4];for(let $=0;$<r.batchSize;++$){const E=$*C,P=$*s[0];for(let z=0;z<r.inChannels;++z)for(let B=0;B<r.outDepth;++B){const U=B*o-g;let G=U;for(;G<0;)G+=u;const q=Math.min(r.inDepth,h+U),K=E+B*S;for(let H=0;H<r.outHeight;++H){const X=H*i-m;let ne=X;for(;ne<0;)ne+=c;const re=Math.min(r.inHeight,p+X),ie=K+H*T;for(let oe=0;oe<r.outWidth;++oe){const pe=oe*l-y;let le=pe;for(;le<0;)le+=d;const me=Math.min(r.inWidth,f+pe),Te=ie+oe*k;let Ee=x,ke=0,Me=0;for(let at=G;at<q;at+=u){const mt=P+at*s[1];for(let kt=ne;kt<re;kt+=c){const gt=mt+kt*s[2];for(let ut=le;ut<me;ut+=d){const vt=n[gt+ut*s[3]+z];if("max"===a&&vt>Ee?Ee=vt:"avg"===a&&(ke+=vt,Me++),isNaN(Ee))break}if(isNaN(Ee))break}if(isNaN(Ee))break}w[Te+z]="avg"===a?ke/Math.max(Me,1):Ee}}}}return b}const iF={kernelName:Xi,backendName:"cpu",kernelFunc:function oF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;xe(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:l}=s;I(nn(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=Kn(r.shape,a,o,1,i,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Qe(c.inShape,c.outShape))d=Es({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,p=Ie(r.shape),f=Df(h,0,r.dtype,p,c,"avg");d=e.makeTensorInfo(c.outShape,r.dtype,f.values)}return d}},uF={kernelName:Zi,backendName:"cpu",kernelFunc:function lF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=s;xe(r,"avgPool3d");const c=Ps(r.shape,a,o,1,i,l,u),h=hw(e.data.get(r.dataId).values,0,r.dtype,Ie(r.shape),c,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},dF={kernelName:Jc,backendName:"cpu",kernelFunc:function cF(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=s;xe([r,a],"avgPool3DGrad");const c=Ps(a.shape,o,i,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,m=c.filterWidth,y=c.dilationDepth,x=c.dilationHeight,b=c.dilationWidth,w=c.effectiveFilterDepth,C=c.effectiveFilterHeight,S=c.effectiveFilterWidth,T=w-1-c.padInfo.front,k=S-1-c.padInfo.left,$=C-1-c.padInfo.top,E=Be(a.shape,"float32"),P=1/(f*g*m),z=e.bufferSync(r);for(let B=0;B<c.batchSize;++B)for(let U=0;U<c.inChannels;++U)for(let G=0;G<c.inDepth;++G)for(let q=0;q<c.inHeight;++q)for(let K=0;K<c.inWidth;++K){const H=G-T,X=q-$,ne=K-k;let re=0;for(let ie=0;ie<w;ie+=y){const oe=(H+ie)/d;if(!(oe<0||oe>=c.outDepth||Math.floor(oe)!==oe))for(let pe=0;pe<C;pe+=x){const le=(X+pe)/h;if(!(le<0||le>=c.outHeight||Math.floor(le)!==le))for(let me=0;me<S;me+=b){const Te=(ne+me)/p;Te<0||Te>=c.outWidth||Math.floor(Te)!==Te||(re+=z.get(B,oe,le,Te,U))}}}E.set(re*P,B,G,q,K,U)}return e.makeTensorInfo(E.shape,E.dtype,E.values)}},pF={kernelName:Yc,backendName:"cpu",kernelFunc:function hF(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,o=a;xe([r,a],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=Kn(o.shape,i,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,y=c.effectiveFilterHeight,x=c.effectiveFilterWidth,b=x-1-c.padInfo.left,w=y-1-c.padInfo.top,C=Be(o.shape,"float32"),S=1/(p*f),T=e.data.get(r.dataId).values,k=Be(r.shape,"float32",T);for(let $=0;$<c.batchSize;++$)for(let E=0;E<c.inChannels;++E)for(let P=0;P<c.inHeight;++P)for(let z=0;z<c.inWidth;++z){const B=P-w,U=z-b;let G=0;for(let q=0;q<y;q+=g){const K=(B+q)/d;if(!(K<0||K>=c.outHeight||Math.floor(K)!==K))for(let H=0;H<x;H+=m){const X=(U+H)/h;X<0||X>=c.outWidth||Math.floor(X)!==X||(G+=k.get($,K,X,E))}}C.set(G*S,$,P,z,E)}return e.makeTensorInfo(C.shape,C.dtype,C.values)}},mF={kernelName:ul,backendName:"cpu",kernelFunc:function fF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:a,offset:o,mean:i,variance:l}=t;I(i.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(null==o||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(null==a||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),xe([r,i,l,a,o],"batchNorm");let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=e.data.get(r.dataId).values,d=e.data.get(i.dataId).values,h=e.data.get(l.dataId).values,p=a?e.data.get(a.dataId).values:new Float32Array([1]),f=o?e.data.get(o.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=f.length,y=p.length,x=h.length,b=d.length;let w=0,C=0,S=0,T=0;for(let k=0;k<c.length;++k)g[k]=f[w++]+(c[k]-d[C++])*p[S++]/Math.sqrt(h[T++]+u),w>=m&&(w=0),C>=b&&(C=0),S>=y&&(S=0),T>=x&&(T=0);return e.makeTensorInfo(r.shape,r.dtype,g)}};function pw(n,t,e,s,r){const a=Ch(s,t,e),o=W(e),i=Ie(s);if(a){const d=Sh(t,i);return"string"===r?n.slice(d,d+o):n.subarray(d,d+o)}const u=Be(s,r,"string"===r?Hs(n):n),c=Be(e,r);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,g)=>f+t[g]);c.set(u.get(...p),...h)}return"string"===r?Wy(c.values):c.values}function ta(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,size:o}=s;xe(r,"slice");const[i,l]=cu(r,a,o);wh(r,i,l);const c=pw(e.data.get(r.dataId).values,i,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,c)}const gF={kernelName:Ml,backendName:"cpu",kernelFunc:ta},xF={kernelName:Ji,backendName:"cpu",kernelFunc:function yF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,crops:o}=s;xe([r],"batchToSpaceND");const i=a.reduce((y,x)=>y*x),l=gi(r.shape,a,i),u=yi(l.length,a.length),c=xi(r.shape,a,i),d=ap(o,a.length),h=op(c,o,a.length),p=ft({inputs:{x:r},backend:e,attrs:{shape:l}}),f=_n({inputs:{x:p},backend:e,attrs:{perm:u}}),g=ft({inputs:{x:f},backend:e,attrs:{shape:c}}),m=ta({inputs:{x:g},backend:e,attrs:{begin:d,size:h}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}};function Rf(n,t,e,s,r){const a=W(s),o=un(r,e);for(let i=0;i<n.length;i++){const l=n[i];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(o[l]+=a>0?t[i]:1)}return o}function fw(n,t,e,s=!1){const r=n.shape[0],a=n.shape[1],o=Be([r,e],t.dtype);for(let i=0;i<r;i++)for(let l=0;l<a;l++){const u=n.get(i,l);if(u<0)throw new Error("Input x must be non-negative!");u>=e||o.set(s?1:t.size>0?o.get(i,u)+t.get(i,l):o.get(i,u)+1,i,u)}return o}const wF={kernelName:Qc,backendName:"cpu",kernelFunc:function bF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:o}=s,u=Rf(e.data.get(r.dataId).values,e.data.get(a.dataId).values,a.dtype,a.shape,o);return e.makeTensorInfo([o],a.dtype,u)}},mw=Ft((n,t)=>n&t),CF={kernelName:ed,backendName:"cpu",kernelFunc:Ht(ed,mw)},IF={kernelName:bm,backendName:"cpu",kernelFunc:function SF(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,a=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,i=Oe(Array.from(a),Array.from(o));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},gw=$s(n=>Math.ceil(n)),TF=xr(co,gw),NF={kernelName:co,backendName:"cpu",kernelFunc:TF},kF=rt(ho,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),_F={kernelName:ho,backendName:"cpu",kernelFunc:kF},$F={kernelName:Qi,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(W(t.shape)),r=e.data.get(t.dataId),o=r.complexTensorInfos.imag,i=e.data.get(r.complexTensorInfos.real.dataId).values,l=e.data.get(o.dataId).values;for(let u=0;u<i.length;u++)s[u]=Math.hypot(i[u],l[u]);return e.makeOutput(s,t.shape,"float32")}};function yw(n,t,e,s){const r=$t(e,W(t));if(s&&"string"!==e){let a=0;n.forEach(o=>{const i=W(o.shape);r.set(o.vals,a),a+=i})}else{let a=0;n.forEach(o=>{const i="string"===e?Hs(o.vals):o.vals;let l=0;for(let u=0;u<o.shape[0];++u){const c=u*t[1]+a;for(let d=0;d<o.shape[1];++d)r[c+d]=i[l++]}a+=o.shape[1]})}return r}function Va(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,a=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,a)}const EF={kernelName:bd,backendName:"cpu",kernelFunc:Va};function za(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,a=ze(r,t[0].shape)[0];np(t.map(g=>g.shape),a);let i=Cs(t.map(g=>g.shape),a);if(0===W(i))return e.makeTensorInfo(i,t[0].dtype,[]);const l=t.filter(g=>W(g.shape)>0);if(1===l.length)return Es({inputs:{x:l[0]},backend:e});if("complex64"===l[0].dtype){const g=l.map(w=>ea({inputs:{input:w},backend:e})),m=l.map(w=>Va({inputs:{input:w},backend:e})),y=za({inputs:g,backend:e,attrs:{axis:a}}),x=za({inputs:m,backend:e,attrs:{axis:a}}),b=Dn({inputs:{real:y,imag:x},backend:e});return g.forEach(w=>e.disposeIntermediateTensorInfo(w)),m.forEach(w=>e.disposeIntermediateTensorInfo(w)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),b}const u=l.map(g=>{const m=W(g.shape.slice(a));return ft({inputs:{x:g},backend:e,attrs:{shape:[-1,m]}})}),c=u.map(g=>({vals:e.data.get(g.dataId).values,shape:g.shape}));i=Cs(u.map(g=>g.shape),1);const h=yw(c,i,t[0].dtype,1===u[0].shape[0]),p=Cs(l.map(g=>g.shape),a),f=e.makeTensorInfo(p,t[0].dtype,h);return u.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}const AF={kernelName:el,backendName:"cpu",kernelFunc:za};function xw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s;xe([r,a],"conv2d");const d=Ls(l),h=Kt(r.shape,a.shape,o,u,i,c,!1,d),p=h.filterHeight,f=h.filterWidth,g=h.dilationHeight,m=h.dilationWidth,y=h.padInfo.left,x=h.padInfo.top,b="channelsLast"===h.dataFormat,w=new tn(h.outShape,r.dtype),C=Ie(r.shape),S=Ie(a.shape),T=C[0],k=b?C[1]:C[2],$=b?C[2]:1,E=b?1:C[1],P=w.strides[0],z=b?w.strides[1]:w.strides[2],B=b?w.strides[2]:1,U=b?1:w.strides[1],G=e.data.get(r.dataId).values,q=e.data.get(a.dataId).values,K=w.values;for(let H=0;H<h.batchSize;++H){const X=H*T,ne=H*P;for(let re=0;re<h.outHeight;++re){const ie=ne+re*z,oe=re*h.strideHeight-x;for(let pe=0;pe<p;++pe){const le=oe+pe*g;if(le<0||le>=h.inHeight)continue;const me=pe*S[0],Te=X+le*k;for(let Ee=0;Ee<h.outWidth;++Ee){const ke=ie+Ee*B,Me=Ee*h.strideWidth-y;for(let Ve=0;Ve<f;++Ve){const at=Me+Ve*m;if(at<0||at>=h.inWidth)continue;const kt=Te+at*$;let gt=me+Ve*S[1];for(let ut=0;ut<h.inChannels;++ut){const Tt=G[kt+ut*E];for(let vt=0;vt<h.outChannels;++vt)K[ke+vt*U]+=Tt*q[gt+vt];gt+=h.outChannels}}}}}}return e.makeTensorInfo(w.shape,w.dtype,K)}const DF={kernelName:tl,backendName:"cpu",kernelFunc:xw},FF={kernelName:nd,backendName:"cpu",kernelFunc:function RF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;xe([r,a],"conv2dBackpropFilter");const d=Ls(l),h=Kt(r.shape,c,o,1,i,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=h,y="channelsLast"===h.dataFormat,x=new tn(h.filterShape,"float32"),b=h.padInfo.left,w=h.padInfo.top,C=e.data.get(r.dataId).values,S=e.data.get(a.dataId).values,T=new tn(r.shape,r.dtype,C),k=new tn(a.shape,a.dtype,S);for(let $=0;$<g;++$){const E=Math.max(0,Math.ceil((w-$)/p)),P=Math.min(h.outHeight,(h.inHeight+w-$)/p);for(let z=0;z<m;++z){const B=Math.max(0,Math.ceil((b-z)/f)),U=Math.min(h.outWidth,(h.inWidth+b-z)/f);for(let G=0;G<h.inChannels;++G)for(let q=0;q<h.outChannels;++q){let K=0;for(let H=0;H<h.batchSize;++H)for(let X=E;X<P;++X){const ne=$+X*p-w;for(let re=B;re<U;++re){const ie=z+re*f-b;K+=y?T.get(H,ne,ie,G)*k.get(H,X,re,q):T.get(H,G,ne,ie)*k.get(H,q,X,re)}}x.set(K,$,z,G,q)}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},PF={kernelName:nl,backendName:"cpu",kernelFunc:function OF(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s;xe([r,a],"conv2dBackpropInput");const d=Ie(a.shape),h=Ie(r.shape);let p=Ls(u);const f=Kt(o,a.shape,i,1,l,c,!1,p),g=new tn(f.inShape,"float32"),m=g.values,y=e.data.get(r.dataId).values,x=e.data.get(a.dataId).values,[b,w,C]=d,{batchSize:S,filterHeight:T,filterWidth:k,inChannels:$,inHeight:E,inWidth:P,outChannels:z,outHeight:B,outWidth:U,strideHeight:G,strideWidth:q}=f;p=f.dataFormat;const K=T-1-f.padInfo.top,H=k-1-f.padInfo.left,X="channelsLast"===p,ne=g.strides[0],re=X?g.strides[1]:g.strides[2],ie=X?g.strides[2]:1,oe=X?1:g.strides[1],pe=h[0],le=X?h[1]:h[2],me=X?h[2]:1,Te=X?1:h[1];for(let Ee=0;Ee<S;++Ee)for(let ke=0;ke<$;++ke)for(let Me=0;Me<E;++Me){const Ve=Me-K,at=Math.max(0,Math.ceil(Ve/G)),mt=Math.min(B,(T+Ve)/G);for(let kt=0;kt<P;++kt){const gt=kt-H,ut=Math.max(0,Math.ceil(gt/q)),Tt=Math.min(U,(k+gt)/q);let vt=0;for(let an=at;an<mt;++an){const Ir=an*G-Ve;for(let Gn=ut;Gn<Tt;++Gn){const fs=pe*Ee+le*an+me*Gn,Zs=b*(T-1-Ir)+w*(k-1-(Gn*q-gt))+C*ke;for(let Tr=0;Tr<z;++Tr)vt+=y[fs+Te*Tr]*x[Zs+Tr]}}m[ne*Ee+re*Me+ie*kt+oe*ke]=vt}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},MF={kernelName:sl,backendName:"cpu",kernelFunc:function LF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dilations:l}=s;xe([r,a],"conv3d");const u=ir(r.shape,a.shape,o,l,i),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=u,y=m.front,x=m.left,b=m.top,w=new tn(u.outShape,r.dtype),C=e.data.get(r.dataId).values,S=e.data.get(a.dataId).values,T=w.values,k=Ie(r.shape),$=Ie(a.shape);for(let E=0;E<u.batchSize;++E){const P=E*k[0],z=E*w.strides[0];for(let B=0;B<u.outDepth;++B){const U=z+B*w.strides[1],G=B*u.strideDepth-y;for(let q=0;q<c;++q){const K=G+q*p;if(K<0||K>=u.inDepth)continue;const H=q*$[0],X=P+K*k[1];for(let ne=0;ne<u.outHeight;++ne){const re=U+ne*w.strides[2],ie=ne*u.strideHeight-b;for(let oe=0;oe<d;++oe){const pe=ie+oe*f;if(pe<0||pe>=u.inHeight)continue;const le=H+oe*$[1],me=X+pe*k[2];for(let Te=0;Te<u.outWidth;++Te){const Ee=re+Te*u.outChannels,ke=Te*u.strideWidth-x;for(let Me=0;Me<h;++Me){const Ve=ke+Me*g;if(Ve<0||Ve>=u.inWidth)continue;const mt=me+Ve*u.inChannels;let kt=le+Me*$[2];for(let gt=0;gt<u.inChannels;++gt){const ut=C[mt+gt];for(let Tt=0;Tt<u.outChannels;++Tt)T[Ee+Tt]+=ut*S[kt+Tt];kt+=u.outChannels}}}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}},zF={kernelName:sd,backendName:"cpu",kernelFunc:function VF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,pad:i,filterShape:l}=s;xe([r,a],"conv3dBackpropFilterV2");const u=Ie(r.shape),c=Ie(a.shape),d=ir(r.shape,l,o,1,i),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,g=d.filterDepth,m=d.filterHeight,y=d.filterWidth,x=new tn(d.filterShape,"float32"),b=x.values,[w,C,S,T]=x.strides,k=e.data.get(a.dataId).values,[$,E,P,z]=c,B=e.data.get(r.dataId).values,[U,G,q,K]=u,H=d.padInfo.front,X=d.padInfo.left,ne=d.padInfo.top;for(let re=0;re<g;++re){const ie=Math.max(0,Math.ceil((H-re)/h)),oe=Math.min(d.outDepth,(d.inDepth+H-re)/h),pe=re*w;for(let le=0;le<m;++le){const me=Math.max(0,Math.ceil((ne-le)/p)),Te=Math.min(d.outHeight,(d.inHeight+ne-le)/p),Ee=le*C+pe;for(let ke=0;ke<y;++ke){const Me=Math.max(0,Math.ceil((X-ke)/f)),Ve=Math.min(d.outWidth,(d.inWidth+X-ke)/f),at=ke*S+Ee;for(let mt=0;mt<d.inChannels;++mt){const kt=mt*T+at;for(let gt=0;gt<d.outChannels;++gt){let ut=0;for(let Tt=0;Tt<d.batchSize;++Tt){const vt=Tt*U,Xs=Tt*$;for(let an=ie;an<oe;++an){const Gn=(re+an*h-H)*G+vt,ua=an*E+Xs;for(let fs=me;fs<Te;++fs){const Tr=(le+fs*p-ne)*q+Gn,Nr=fs*P+ua;for(let kr=Me;kr<Ve;++kr)ut+=B[(ke+kr*f-X)*K+Tr+mt]*k[kr*z+Nr+gt]}}}b[kt+gt]=ut}}}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},WF={kernelName:rd,backendName:"cpu",kernelFunc:function BF(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{pad:o,strides:i,inputShape:l}=s;xe([r],"conv3dBackpropInputV2");const u=Ie(r.shape),c=Ie(a.shape),d=ir(l,a.shape,i,1,o),h=new tn(d.inShape,"float32"),p=h.values,[f,g,m,y]=h.strides,x=e.data.get(r.dataId).values,[b,w,C,S]=u,T=e.data.get(a.dataId).values,[k,$,E,P]=c,{batchSize:z,filterDepth:B,filterHeight:U,filterWidth:G,inChannels:q,inDepth:K,inHeight:H,inWidth:X,outChannels:ne,outDepth:re,outHeight:ie,outWidth:oe,strideDepth:pe,strideHeight:le,strideWidth:me}=d,Te=B-1-d.padInfo.front,Ee=U-1-d.padInfo.top,ke=G-1-d.padInfo.left;for(let Me=0;Me<z;++Me)for(let Ve=0;Ve<q;++Ve)for(let at=0;at<K;++at){const mt=at-Te,kt=Math.max(0,Math.ceil(mt/pe)),gt=Math.min(re,(B+mt)/pe);for(let ut=0;ut<H;++ut){const Tt=ut-Ee,vt=Math.max(0,Math.ceil(Tt/le)),Xs=Math.min(ie,(U+Tt)/le);for(let an=0;an<X;++an){const Ir=an-ke,Gn=Math.max(0,Math.ceil(Ir/me)),ua=Math.min(oe,(G+Ir)/me);let fs=0;for(let Zs=kt;Zs<gt;++Zs){const Tr=Zs*pe-mt;for(let Nr=vt;Nr<Xs;++Nr){const kr=Nr*le-Tt;for(let Gi=Gn;Gi<ua;++Gi){const am=b*Me+w*Zs+C*Nr+S*Gi,Kq=k*(B-1-Tr)+$*(U-1-kr)+E*(G-1-(Gi*me-Ir))+P*Ve;for(let Pc=0;Pc<ne;++Pc)fs+=x[am+Pc]*T[Kq+Pc]}}}p[f*Me+g*at+m*ut+y*an+Ve]=fs}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},UF=rt(po,n=>Math.cos(n)),GF={kernelName:po,backendName:"cpu",kernelFunc:UF},HF=rt(fo,n=>Math.cosh(n)),jF={kernelName:fo,backendName:"cpu",kernelFunc:HF},KF={kernelName:od,backendName:"cpu",kernelFunc:function qF(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:a,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=s,[c,d,h,p]=r.shape,f=a.shape[0],[g,m]=i,y=Be([f,g,m,p],"float32"),x=e.data.get(a.dataId).values,b=e.data.get(o.dataId).values,w=e.data.get(r.dataId).values,C=Ie(r.shape),S=Ie(y.shape);for(let T=0;T<f;T++){const k=4*T,$=x[k],E=x[k+1],P=x[k+2],z=x[k+3],B=b[T];if(B>=c)continue;const U=g>1?(P-$)*(d-1)/(g-1):0,G=m>1?(z-E)*(h-1)/(m-1):0;for(let q=0;q<g;q++){const K=g>1?$*(d-1)+q*U:.5*($+P)*(d-1);if(K<0||K>d-1)for(let H=0;H<m;H++)for(let X=0;X<p;X++)y.values[X+H*S[2]+q*S[1]+T*S[0]]=u;else if("bilinear"===l){const H=Math.floor(K),X=Math.ceil(K),ne=K-H;for(let re=0;re<m;re++){const ie=m>1?E*(h-1)+re*G:.5*(E+z)*(h-1);if(ie<0||ie>h-1){for(let me=0;me<p;me++)y.values[me+re*S[2]+q*S[1]+T*S[0]]=u;continue}const oe=Math.floor(ie),pe=Math.ceil(ie),le=ie-oe;for(let me=0;me<p;me++){let Te=me+oe*C[2]+H*C[1]+B*C[0];const Ee=w[Te];Te=me+pe*C[2]+H*C[1]+B*C[0];const ke=w[Te];Te=me+oe*C[2]+X*C[1]+B*C[0];const Me=w[Te];Te=me+pe*C[2]+X*C[1]+B*C[0];const Ve=w[Te],at=Ee+(ke-Ee)*le;Te=me+re*S[2]+q*S[1]+T*S[0],y.values[Te]=at+(Me+(Ve-Me)*le-at)*ne}}}else for(let H=0;H<m;++H){const X=m>1?E*(h-1)+H*G:.5*(E+z)*(h-1);if(X<0||X>h-1){for(let ie=0;ie<p;ie++)y.values[ie+H*S[2]+q*S[1]+T*S[0]]=u;continue}const ne=Math.round(X),re=Math.round(K);for(let ie=0;ie<p;ie++)y.values[ie+H*S[2]+q*S[1]+T*S[0]]=w[ie+ne*C[2]+re*C[1]+B*C[0]]}}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},ZF={kernelName:ad,backendName:"cpu",kernelFunc:function XF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;xe(r,"cumprod");const l=St([a],r.shape.length);let u=r;null!=l&&(u=_n({inputs:{x:r},backend:e,attrs:{perm:l}}));const c=At(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=An(u.dtype,"int32"),h=Gc(W(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=i?(y,x)=>y+f-x-1:(y,x)=>y+x;for(let y=0;y<p.length;y+=f)for(let x=0;x<f;x++){const b=g(y,x);if(0===x)h[b]=o?1:p[b];else{const w=g(y,x-1);h[b]=o?p[w]*h[w]:p[b]*h[w]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const x=_n({inputs:{x:m},backend:e,attrs:{perm:ur(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}},JF={kernelName:rl,backendName:"cpu",kernelFunc:function YF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;xe(r,"cumsum");const l=St([a],r.shape.length);let u=r;null!=l&&(u=_n({inputs:{x:r},backend:e,attrs:{perm:l}}));const c=At(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=An(u.dtype,"int32"),h=un(W(u.shape),d),p=e.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=i?(y,x)=>y+f-x-1:(y,x)=>y+x;for(let y=0;y<p.length;y+=f)for(let x=0;x<f;x++){const b=g(y,x);if(0===x)h[b]=o?0:p[b];else{const w=g(y,x-1);h[b]=o?p[w]+h[w]:p[b]+h[w]}}const m=e.makeTensorInfo(u.shape,d,h);if(null!=l){const x=_n({inputs:{x:m},backend:e,attrs:{perm:ur(l)}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),x}return m}},eO={kernelName:id,backendName:"cpu",kernelFunc:function QF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:o,binaryOutput:i}=s;if(1===r.shape.length){const c=Rf(e.data.get(r.dataId).values,e.data.get(a.dataId).values,a.dtype,a.shape,o);return e.makeTensorInfo([o],a.dtype,c)}if(2===r.shape.length){const c=fw(e.bufferSync(r),e.bufferSync(a),o,i);return e.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},nO={kernelName:ld,backendName:"cpu",kernelFunc:function tO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:a,dataFormat:o}=s;I("NHWC"===o,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const i=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],d=l*a,h=u*a,p=c/(a*a),f=e.data.get(r.dataId).values,g=new Float32Array(i*d*h*p);let m=0;for(let y=0;y<i;++y)for(let x=0;x<d;++x){const b=Math.floor(x/a),w=x%a;for(let C=0;C<h;++C){const S=Math.floor(C/a),k=(w*a+C%a)*p;for(let $=0;$<p;++$)g[m++]=f[$+k+c*(S+u*(b+l*y))]}}return e.makeTensorInfo([i,d,h,p],r.dtype,g)}};function bw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=s;xe([r,a],"depthwiseConv2DNative");const c=Ie(r.shape),d=Ie(a.shape);let h=l;null==h&&(h=[1,1]),I(nn(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const p=Kt(r.shape,a.shape,o,h,i,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:y,padInfo:x}=p,b=x.left,w=x.top,C=p.outChannels/p.inChannels,S=new tn(p.outShape,r.dtype),T=e.data.get(r.dataId).values,k=e.data.get(a.dataId).values,$=S.values;for(let E=0;E<p.batchSize;++E){const P=E*c[0],z=E*S.strides[0];for(let B=0;B<p.outHeight;++B){const U=z+B*S.strides[1],G=B*p.strideHeight-w;for(let q=0;q<f;++q){const K=G+q*m;if(K<0||K>=p.inHeight)continue;const H=q*d[0],X=P+K*c[1];for(let ne=0;ne<p.outWidth;++ne){const re=U+ne*S.strides[2],ie=ne*p.strideWidth-b;for(let oe=0;oe<g;++oe){const pe=ie+oe*y;if(pe<0||pe>=p.inWidth)continue;const me=X+pe*p.inChannels;let Te=re,Ee=H+oe*d[1];for(let ke=0;ke<p.inChannels;++ke){const Me=T[me+ke];for(let Ve=0;Ve<C;++Ve)$[Te+Ve]+=Me*k[Ee+Ve];Te+=C,Ee+=C}}}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const sO={kernelName:al,backendName:"cpu",kernelFunc:bw},aO={kernelName:ud,backendName:"cpu",kernelFunc:function rO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s;xe([r,a],"depthwiseConv2dNativeBackpropFilter");const d=Kt(r.shape,c,o,i,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:g}=d,m=new tn(d.filterShape,"float32"),y=d.padInfo.left,x=d.padInfo.top,b=d.outChannels/d.inChannels,w=e.data.get(r.dataId).values,C=new tn(r.shape,r.dtype,w),S=e.data.get(a.dataId).values,T=new tn(a.shape,a.dtype,S);for(let k=0;k<f;++k){const $=Math.max(0,Math.ceil((x-k)/h)),E=Math.min(d.outHeight,(d.inHeight+x-k)/h);for(let P=0;P<g;++P){const z=Math.max(0,Math.ceil((y-P)/p)),B=Math.min(d.outWidth,(d.inWidth+y-P)/p);for(let U=0;U<d.outChannels;++U){const G=Math.trunc(U/b),q=U%b;let K=0;for(let H=0;H<d.batchSize;++H)for(let X=$;X<E;++X){const ne=k+X*h-x;for(let re=z;re<B;++re)K+=C.get(H,ne,P+re*p-y,G)*T.get(H,X,re,U)}m.set(K,k,P,G,q)}}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},iO={kernelName:cd,backendName:"cpu",kernelFunc:function oO(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s;xe([r,a],"depthwiseConv2DNativeBackpropInput");const d=Ie(r.shape),h=Ie(a.shape),p=Kt(c,a.shape,o,i,l,u,!0),f=new tn(p.inShape,"float32"),g=f.values,[m,y,x]=f.strides,b=e.data.get(r.dataId).values,[w,C,S]=d,T=e.data.get(a.dataId).values,[k,$,E]=h,{batchSize:P,filterHeight:z,filterWidth:B,inChannels:U,inHeight:G,inWidth:q,outChannels:K,outHeight:H,outWidth:X,strideHeight:ne,strideWidth:re}=p,ie=z-1-p.padInfo.top,oe=B-1-p.padInfo.left,pe=K/U;for(let le=0;le<P;++le)for(let me=0;me<U;++me)for(let Te=0;Te<G;++Te){const Ee=Te-ie,ke=Math.max(0,Math.ceil(Ee/ne)),Me=Math.min(H,(z+Ee)/ne);for(let Ve=0;Ve<q;++Ve){const at=Ve-oe,mt=Math.max(0,Math.ceil(at/re)),kt=Math.min(X,(B+at)/re);let gt=0;for(let ut=ke;ut<Me;++ut){const Tt=ut*ne-Ee;for(let vt=mt;vt<kt;++vt){const an=w*le+C*ut+S*vt,Ir=k*(z-1-Tt)+$*(B-1-(vt*re-at))+E*me;for(let Gn=0;Gn<pe;++Gn)gt+=b[an+(me*pe+Gn)]*T[Ir+Gn]}}g[m*le+y*Te+x*Ve+me]=gt}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}},uO={kernelName:"Diag",backendName:"cpu",kernelFunc:function lO(n){const{inputs:t,backend:e}=n,{x:s}=t,r=W(s.shape),a=e.data.get(s.dataId).values,o=Be([r,r],s.dtype),i=o.values;for(let u=0;u<a.length;u++)i[u*r+u]=a[u];const l=[...s.shape,...s.shape];return e.makeTensorInfo(l,o.dtype,o.values)}},cO={kernelName:ol,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:a,pad:o,dilations:i}=e,l=t,u=l.data.get(s.dataId).values,c=s.shape.length,d=l.data.get(r.dataId).values,h=r.shape.length,{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:y,outWidth:x,padInfo:b,strideHeight:w,strideWidth:C,filterHeight:S,filterWidth:T,dilationHeight:k,dilationWidth:$,outShape:E}=ai(s.shape,r.shape,a,o,"NHWC",i),P=W(E),z=E.length,B=$t(s.dtype,P);for(let G=0;G<p;++G)for(let q=0;q<y;++q){const K=q*w-b.top;for(let H=0;H<x;++H){const X=H*C-b.left;for(let ne=0;ne<m;++ne){let re=Number.MIN_SAFE_INTEGER;for(let oe=0;oe<S;++oe){const pe=K+oe*k;if(pe>=0&&pe<f)for(let le=0;le<T;++le){const me=X+le*$;if(me>=0&&me<g){const Te=gs([G,pe,me,ne],c,Ie(s.shape)),Ee=gs([oe,le,ne],h,Ie(r.shape)),ke=u[Te]+d[Ee];ke>re&&(re=ke)}}}B[gs([G,q,H,ne],z,Ie(E))]=re}}}return{dataId:l.write(Dr(B,s.dtype),E,s.dtype),shape:E,dtype:s.dtype}}},dO={kernelName:hd,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:a}=n,{strides:o,pad:i,dilations:l}=e,u=t,c=ss(s.shape,u.data.get(s.dataId).values),d=ss(r.shape,u.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:b,strideWidth:w,filterHeight:C,filterWidth:S,dilationHeight:T,dilationWidth:k,outShape:$}=ai(s.shape,r.shape,o,i,"NHWC",l);I(a.rank===$.length,()=>`Error in ${hd}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const E=ss($,u.data.get(a.dataId).values),P=mm(r.shape,r.dtype);for(let B=0;B<h;++B)for(let U=0;U<m;++U){const G=U*b-x.top;for(let q=0;q<y;++q){const K=q*w-x.left;for(let H=0;H<g;++H){let X=Number.MIN_SAFE_INTEGER,ne=0,re=0;for(let ie=0;ie<C;++ie){const oe=G+ie*T;if(oe>=0&&oe<p)for(let pe=0;pe<S;++pe){const le=K+pe*k;if(le>=0&&le<f){const me=c[B][oe][le][H]+d[ie][pe][H];me>X&&(X=me,ne=ie,re=pe)}}}P[ne][re][H]+=E[B][U][q][H]}}}return{dataId:u.write(Dr(P,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},hO={kernelName:dd,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:a}=n,{strides:o,pad:i,dilations:l}=e,u=t,c=ss(s.shape,u.data.get(s.dataId).values),d=ss(r.shape,u.data.get(r.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:g,outHeight:m,outWidth:y,padInfo:x,strideHeight:b,strideWidth:w,filterHeight:C,filterWidth:S,dilationHeight:T,dilationWidth:k,outShape:$}=ai(s.shape,r.shape,o,i,"NHWC",l);I(a.rank===$.length,()=>`Error in ${dd}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const E=ss($,u.data.get(a.dataId).values),P=mm(s.shape,s.dtype);for(let B=0;B<h;++B)for(let U=0;U<m;++U){const G=U*b-x.top;for(let q=0;q<y;++q){const K=q*w-x.left;for(let H=0;H<g;++H){let X=Number.MIN_SAFE_INTEGER,ne=G<0?0:G,re=K<0?0:K;for(let ie=0;ie<C;++ie){const oe=G+ie*T;if(oe>=0&&oe<p)for(let pe=0;pe<S;++pe){const le=K+pe*k;if(le>=0&&le<f){const me=c[B][oe][le][H]+d[ie][pe][H];me>X&&(X=me,ne=oe,re=le)}}}P[B][ne][re][H]+=E[B][U][q][H]}}}return{dataId:u.write(Dr(P,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},fO={kernelName:"Draw",backendName:"cpu",kernelFunc:function pO(n){const{inputs:t,backend:e,attrs:s}=n,{image:r}=t,{canvas:a,options:o}=s,{contextOptions:i,imageOptions:l}=o||{},u=(null==l?void 0:l.alpha)||1,c=(null==i?void 0:i.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(null==i?void 0:i.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],g=e.data.get(r.dataId).values,m="float32"===r.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let b=0;b<h*p;++b){const w=[0,0,0,255*u];for(let S=0;S<f;S++){const T=g[b*f+S];if("float32"===r.dtype){if(T<0||T>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${T}.`)}else if("int32"===r.dtype&&(T<0||T>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${T}.`);1===f?(w[0]=T*m,w[1]=T*m,w[2]=T*m):w[S]=T*m}const C=4*b;y[C+0]=Math.round(w[0]),y[C+1]=Math.round(w[1]),y[C+2]=Math.round(w[2]),y[C+3]=Math.round(w[3])}a.width=p,a.height=h;const x=new ImageData(y,p,h);return d.putImageData(x,0,0),r}},Ff=Ft((n,t)=>n*t),mO=Ef((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e})),hc=Ht(Do,Ff,mO),gO={kernelName:Do,backendName:"cpu",kernelFunc:hc};function Ri(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;let i;xe(r,"sum"),i="bool"===r.dtype?br({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):Es({inputs:{x:r},backend:e});const l=i.shape.length,u=ze(a,i.shape),c=St(u,l);let d=u,h=i;null!=c&&(h=_n({inputs:{x:i},backend:e,attrs:{perm:c}}),d=At(d.length,l)),sn("sum",d,h.shape.length);const[p,f]=Xt(h.shape,d);let m=dc(e,p,An(h.dtype,"int32"));const y=W(f),x=e.data.get(m.dataId).values,b=e.data.get(h.dataId).values;for(let w=0;w<x.length;++w){const C=w*y;let S=0;for(let T=0;T<y;++T)S+=b[C+T];x[w]=S}if(o){const C=m;m=ft({inputs:{x:m},backend:e,attrs:{shape:Et(m.shape,u)}}),e.disposeIntermediateTensorInfo(C)}return e.disposeIntermediateTensorInfo(i),null!=c&&e.disposeIntermediateTensorInfo(h),m}const yO={kernelName:Vl,backendName:"cpu",kernelFunc:Ri},bO={kernelName:pd,backendName:"cpu",kernelFunc:function xO(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,a=t,{allDims:o,summedDims:i,idDims:l}=gp(r,a.length);xp(o.length,l,a);const{path:u,steps:c}=bp(i,l),d=c.length;let h=null,p=o.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:x}=yp(p,l[m]);let b;wp(y)?b=a[m]:(b=_n({inputs:{x:a[m]},backend:e,attrs:{perm:y}}),f.push(b));const w=b.shape.slice();for(let C=0;C<x.length;++C)w.splice(x[C],0,1);Qe(b.shape,w)||(b=ft({inputs:{x:b},backend:e,attrs:{shape:w}}),f.push(b)),null===h?h=b:(h=hc({inputs:{a:b,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=Ri({inputs:{x:h},backend:e,attrs:{axis:u[g]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},vO={kernelName:fd,backendName:"cpu",kernelFunc:function wO(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;xe([s,r],"eluGrad");const a=new Float32Array(W(r.shape)),o=e.data.get(r.dataId).values,i=e.data.get(s.dataId).values;for(let l=0;l<o.length;++l){const u=o[l];a[l]=u>=0?i[l]:i[l]*(u+1)}return e.makeTensorInfo(r.shape,"float32",a)}},ww=Ft((n,t)=>n===t?1:0),vw=Ht(il,ww,null,"bool"),CO={kernelName:il,backendName:"cpu",kernelFunc:vw},SO=lp,IO=up,TO=cp,NO=dp,kO=hp,_O=pp,$O=rt(yo,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+SO*e);return t*(1-((((_O*s+kO)*s+NO)*s+TO)*s+IO)*s*Math.exp(-e*e))}),EO={kernelName:yo,backendName:"cpu",kernelFunc:$O},Cw=$s(n=>Math.exp(n)),Sw=xr(xo,Cw,"float32"),AO={kernelName:xo,backendName:"cpu",kernelFunc:Sw};function pc(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:a}=s,o=r.shape.length,i=r.shape.slice();let l=a;return a<0&&(I(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+a+1),i.splice(l,0,1),ft({inputs:{x:r},backend:e,attrs:{shape:i}})}const DO={kernelName:ll,backendName:"cpu",kernelFunc:pc},Iw=$s(n=>Math.expm1(n)),RO=xr(bo,Iw),FO={kernelName:bo,backendName:"cpu",kernelFunc:RO},OO=Ft((n,t)=>n/t),Of=Ht(mo,OO),Pf={kernelName:mo,backendName:"cpu",kernelFunc:Of},Tw=Ft((n,t)=>n-t),PO=Ef((n,t,e,s)=>({real:n-e,imag:t-s})),Lf=Ht(qo,Tw,PO),LO={kernelName:qo,backendName:"cpu",kernelFunc:Lf};function Nw(n,t,e){const s=n.shape,r=s[0],a=s[1],o=e.data.get(n.dataId),i=o.complexTensorInfos.real,l=o.complexTensorInfos.imag,u=[r,a],c=W(u),d=ln("float32",c),h=ln("float32",c);for(let m=0;m<r;m++){const y=ta({inputs:{x:i},backend:e,attrs:{begin:[m,0],size:[1,a]}}),x=ta({inputs:{x:l},backend:e,attrs:{begin:[m,0],size:[1,a]}}),b=Dn({inputs:{real:y,imag:x},backend:e}),{real:w,imag:C}=MO(b,t,e),S=Gs(w,C);for(let T=0;T<a;T++){const k=fp(S,T);d[m*a+T]=k.real,h[m*a+T]=k.imag}e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b)}const p=e.makeTensorInfo(u,"float32",d),f=e.makeTensorInfo(u,"float32",h),g=Dn({inputs:{real:p,imag:f},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),g}function MO(n,t,e){const s=W(n.shape),r=e.data.get(n.dataId),a=e.data.get(r.complexTensorInfos.real.dataId).values,o=e.data.get(r.complexTensorInfos.imag.dataId).values;if(function VO(n){return 0==(n&n-1)}(s)){const i=Mf(a,o,s,t,e),l=[n.shape[0],n.shape[1]];if(t){const u=e.makeTensorInfo(l,"float32",i.real),c=e.makeTensorInfo(l,"float32",i.imag),d=e.makeTensorInfo([],"float32",er(s,"float32")),h=Es({inputs:{x:d},backend:e}),p=Pf.kernelFunc({inputs:{a:u,b:d},backend:e}),f=Pf.kernelFunc({inputs:{a:c,b:h},backend:e}),g=e.data.get(p.dataId).values,m=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),{real:g,imag:m}}return i}{const l=function zO(n,t,e){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let a=0,o=0;for(let i=0;i<t;i++){const l=Ny(r*i,t,e),u=fp(n,i);a+=u.real*l.real-u.imag*l.imag,o+=u.real*l.imag+u.imag*l.real}e&&(a/=t,o/=t),Iy(s,a,o,r)}return s}(Gs(a,o),s,t);return vy(l)}}function Mf(n,t,e,s,r){if(1===e)return{real:n,imag:t};const a=Gs(n,t),o=e/2,i=Cy(a),l=i.real,u=i.imag,c=[l.length],d=r.makeTensorInfo(c,"float32",l),h=r.makeTensorInfo(c,"float32",u),p=Dn({inputs:{real:d,imag:h},backend:r}),f=Sy(a),g=f.real,m=f.imag,y=[g.length],x=r.makeTensorInfo(y,"float32",g),b=r.makeTensorInfo(y,"float32",m),w=Dn({inputs:{real:x,imag:b},backend:r}),C=Mf(l,u,o,s,r),S=C.real,T=C.imag,k=[S.length],$=r.makeTensorInfo(k,"float32",S),E=r.makeTensorInfo(k,"float32",T),P=Dn({inputs:{real:$,imag:E},backend:r}),z=Mf(g,m,o,s,r),B=z.real,U=z.imag,G=[B.length],q=r.makeTensorInfo(G,"float32",B),K=r.makeTensorInfo(G,"float32",U),H=Dn({inputs:{real:q,imag:K},backend:r}),X=Ty(e,s),ne=[X.real.length],re=r.makeTensorInfo(ne,"float32",X.real),ie=r.makeTensorInfo(ne,"float32",X.imag),oe=Dn({inputs:{real:re,imag:ie},backend:r}),pe=hc({inputs:{a:oe,b:H},backend:r}),le=Ma({inputs:{a:P,b:pe},backend:r}),me=Lf({inputs:{a:P,b:pe},backend:r}),Te=ea({inputs:{input:le},backend:r}),Ee=ea({inputs:{input:me},backend:r}),ke=Va({inputs:{input:le},backend:r}),Me=Va({inputs:{input:me},backend:r}),Ve=za({inputs:[Te,Ee],backend:r,attrs:{axis:0}}),at=za({inputs:[ke,Me],backend:r,attrs:{axis:0}}),mt=r.data.get(Ve.dataId).values,kt=r.data.get(at.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(ie),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(pe),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(me),r.disposeIntermediateTensorInfo(Te),r.disposeIntermediateTensorInfo(ke),r.disposeIntermediateTensorInfo(Ee),r.disposeIntermediateTensorInfo(Me),r.disposeIntermediateTensorInfo(Ve),r.disposeIntermediateTensorInfo(at),{real:mt,imag:kt}}const WO={kernelName:"FFT",backendName:"cpu",kernelFunc:function BO(n){const{inputs:t,backend:e}=n,{input:s}=t,r=W(s.shape),a=s.shape[s.shape.length-1],i=ft({inputs:{x:s},backend:e,attrs:{shape:[r/a,a]}}),l=Nw(i,!1,e),u=ft({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}};function Vf(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:a}=e,o=a||pa(r),i=$t(o,W(s));return function GO(n,t,e){n.fill(t)}(i,r),t.makeTensorInfo(s,o,i)}const UO={kernelName:gd,backendName:"cpu",kernelFunc:Vf},HO={kernelName:yd,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:s}=n,r=e,a=ln(s.dtype,W(s.shape)),[o,i,l,u]=s.shape,c=r.data.get(s.dataId).values;for(let h=0;h<o;h++){const p=h*l*i*u;for(let f=0;f<i;f++){const g=f*(l*u);for(let m=0;m<l;m++){const y=m*u;for(let x=0;x<u;x++){const b=Math.round(l-m-1),w=p+g+y+x;let C=c[w];b>=0&&b<l&&(C=c[p+g+b*u+x]),a[w]=C}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},kw=$s(n=>Math.floor(n)),jO=xr(wo,kw),qO={kernelName:wo,backendName:"cpu",kernelFunc:jO},_w=Ft((n,t)=>Math.floor(n/t)),KO=Ht(vo,_w,null,"int32"),XO={kernelName:vo,backendName:"cpu",kernelFunc:KO},YO={kernelName:Kl,backendName:"cpu",kernelFunc:function ZO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let g=xw({inputs:{x:r,filter:a},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const m=g;if("NCHW"===c&&1===o.shape.length&&1!==o.shape[0]){const y=ft({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});g=Ma({inputs:{a:g,b:y},backend:e}),e.disposeIntermediateTensorInfo(y)}else g=Ma({inputs:{a:g,b:o},backend:e});e.disposeIntermediateTensorInfo(m)}if(p){const m=g;if("NCHW"===c&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const y=ft({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});g=cc(e,g,p,y,f),e.disposeIntermediateTensorInfo(y)}else g=cc(e,g,p,i,f);e.disposeIntermediateTensorInfo(m)}return g}},QO={kernelName:Xl,backendName:"cpu",kernelFunc:function JO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s;let g=bw({inputs:{x:r,filter:a},backend:e,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(o){const m=g;g=Ma({inputs:{a:g,b:o},backend:e}),e.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=cc(e,g,p,i,f),e.disposeIntermediateTensorInfo(m)}return g}};function $w(n,t,e,s,r,a,o,i,l){const u=Be([s,a],e);for(let c=0;c<s;c++){const d=[];let h=0;for(let p=0;p<r;p++){const f=n[c*r+p];h+=f*o[p],d.push(f)}if(h<0||h>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let p=0;p<a;p++)u.values[c*a+p]=t.get(...t.indexToLoc(h*a+p))}return u}const tP={kernelName:vm,backendName:"cpu",kernelFunc:function eP(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,a=W(s.shape),o=r.shape,i=o[o.length-1],[l,u,c,d]=ip(s,r);if(0===u)return e.makeTensorInfo(l,s.dtype,[]);const f=$w(e.data.get(r.dataId).values,e.bufferSync(s),s.dtype,u,i,c,d,s.shape,a);return e.makeTensorInfo(l,s.dtype,f.values)}};function Ew(n,t,e){const s=Be(e,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),u=t.locToIndex([o[0],o[2]]);o[2]=t.values[u];const c=n.locToIndex(o);0<=c&&c<n.values.length&&(s.values[r]=n.values[c])}return s}const sP={kernelName:cl,backendName:"cpu",kernelFunc:function nP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:a}=t,{axis:o,batchDims:i}=s;xe([r,a],"gatherV2");const l=ze(o,r.shape)[0],u=e.data.get(a.dataId).values,c=r.shape[l];for(let w=0;w<u.length;++w){const C=u[w];I(C<=c-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${c-1}]`)}let d=i;null==i&&(d=0);const h=W(a.shape),p=Sp(r,a,l,d),f=ft({inputs:{x:r},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=ft({inputs:{x:a},backend:e,attrs:{shape:[p.batchSize,h/p.batchSize]}}),m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=e.bufferSync(g),b=Ew(e.bufferSync(f),y,m);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.makeTensorInfo(p.outputShape,b.dtype,b.values)}},Aw=Ft((n,t)=>n>t?1:0),rP=Ht(dl,Aw,null,"bool"),aP={kernelName:dl,backendName:"cpu",kernelFunc:rP},Dw=Ft((n,t)=>n>=t?1:0),oP=Ht(Co,Dw,null,"bool"),iP={kernelName:Co,backendName:"cpu",kernelFunc:oP},uP={kernelName:xd,backendName:"cpu",kernelFunc:function lP(n){const{inputs:t,backend:e}=n,{input:s}=t,r=W(s.shape),a=s.shape[s.shape.length-1],i=ft({inputs:{x:s},backend:e,attrs:{shape:[r/a,a]}}),l=Nw(i,!0,e),u=ft({inputs:{x:l},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),u}},cP=rt(Io,n=>Number.isFinite(n)?1:0,"bool"),dP={kernelName:Io,backendName:"cpu",kernelFunc:cP},hP=rt(To,n=>Math.abs(n)===1/0?1:0,"bool"),pP={kernelName:To,backendName:"cpu",kernelFunc:hP},fP=rt(No,n=>Number.isNaN(n)?1:0,"bool"),mP={kernelName:No,backendName:"cpu",kernelFunc:fP},Rw=Ft((n,t)=>n<t?1:0),gP=Ht(pl,Rw,null,"bool"),yP={kernelName:pl,backendName:"cpu",kernelFunc:gP},Fw=Ft((n,t)=>n<=t?1:0),xP=Ht(fl,Fw,null,"bool"),bP={kernelName:fl,backendName:"cpu",kernelFunc:xP};function Ow(n,t,e){const s=(t-n)/(e-1),r=un(e,"float32");r[0]=n;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}const vP={kernelName:Cm,backendName:"cpu",kernelFunc:function wP(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:a}=e,o=Ow(s,r,a);return t.makeTensorInfo([o.length],"float32",o)}},Pw=$s(n=>Math.log(n)),CP=xr(ko,Pw),SP={kernelName:ko,backendName:"cpu",kernelFunc:CP},IP=rt(_o,n=>Math.log1p(n)),TP={kernelName:_o,backendName:"cpu",kernelFunc:IP},NP=Ft((n,t)=>n&&t),kP=Ht(ml,NP,null,"bool"),_P={kernelName:ml,backendName:"cpu",kernelFunc:kP},$P=rt(gl,n=>n?0:1,"bool"),EP={kernelName:gl,backendName:"cpu",kernelFunc:$P},AP=Ft((n,t)=>n||t),DP=Ht(yl,AP,null,"bool"),RP={kernelName:yl,backendName:"cpu",kernelFunc:DP},OP={kernelName:xl,backendName:"cpu",kernelFunc:function FP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:a,bias:o,alpha:i,beta:l}=s;xe(r,"LRN");const u=r.shape[3],c=u-1,d=e.data.get(r.dataId).values,h=W(r.shape),p=new Float32Array(h);function f(g){const m=g%u;let y=g-m+Math.max(0,m-a);const x=g-m+Math.min(m+a,c);let b=0;for(;y<=x;y++){const w=d[y];b+=w*w}return b}for(let g=0;g<h;g++){const m=f(g),y=d[g]*Math.pow(o+i*m,-l);p[g]=y}return e.makeTensorInfo(r.shape,r.dtype,p)}},LP={kernelName:wd,backendName:"cpu",kernelFunc:function PP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:a,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=s;xe(o,"LRNGrad");const d=W(o.shape),h=o.shape[3],p=e.data.get(o.dataId).values,f=e.data.get(r.dataId).values,g=e.data.get(a.dataId).values,m=new Float32Array(d),y=d;for(let x=0;x<y;x++){const b=x%h,w=x-b+Math.max(0,b-i),C=x-b+Math.min(h,b+i+1);let S=0;for(let T=w;T<C;T++)S+=Math.pow(f[T],2);S=u*S+l;for(let T=w;T<C;T++){let k=-2*u*c*f[T]*g[x]/S;x===T&&(k+=Math.pow(S,-c)),k*=p[x],m[T]+=k}}return e.makeTensorInfo(o.shape,r.dtype,m)}};function Lw(n,t,e,s){const r=ln(s,W(e));for(let a=0;a<r.length;++a){const o=a*t;let i=n[o];for(let l=0;l<t;++l){const u=n[o+l];(Number.isNaN(u)||u>i)&&(i=u)}r[a]=i}return r}function Mw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:a,keepDims:o}=s,i=e;let l=r.shape;const u=l.length,c=ze(a,l);let d=c;const h=St(d,u);let p=i.data.get(r.dataId).values;if(null!=h){const w=new Array(u);for(let C=0;C<w.length;C++)w[C]=l[h[C]];p=Af(p,l,r.dtype,h,w),d=At(d.length,u),l=w}xe(r,"max"),sn("max",d,u);const[f,g]=Xt(l,d),y=Lw(p,W(g),f,r.dtype),x=i.write(y,f,r.dtype);let b=f;return o&&(b=Et(f,c)),{dataId:x,shape:b,dtype:r.dtype}}const MP={kernelName:bl,backendName:"cpu",kernelFunc:Mw},Vw=Ft((n,t)=>Math.max(n,t)),VP=Ht($o,Vw),zP={kernelName:$o,backendName:"cpu",kernelFunc:VP},WP={kernelName:wl,backendName:"cpu",kernelFunc:function BP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;xe(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:l}=s;I(nn(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=Kn(r.shape,a,o,1,i,l);let d;if(1===c.filterWidth&&1===c.filterHeight&&Qe(c.inShape,c.outShape))d=Es({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,p=Ie(r.shape),f=Df(h,0,r.dtype,p,c,"max");d=e.makeTensorInfo(c.outShape,r.dtype,f.values)}return d}},GP={kernelName:vl,backendName:"cpu",kernelFunc:function UP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=s;xe(r,"maxPool3d");const c=Ps(r.shape,a,o,1,i,l,u),h=hw(e.data.get(r.dataId).values,0,r.dtype,Ie(r.shape),c,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},jP={kernelName:Cd,backendName:"cpu",kernelFunc:function HP(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,{filterSize:o,strides:i,pad:l,dimRoundingMode:u}=s;xe([r,a],"maxPool3DGrad");const c=Ps(a.shape,o,i,1,l,u),h=function aF(n,t){const e=Be(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,a=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let y=0;y<t.outDepth;++y){const x=y*s-h;let b=x;for(;b<0;)b+=o;const w=Math.min(t.inDepth,u+x);for(let C=0;C<t.outHeight;++C){const S=C*r-p;let T=S;for(;T<0;)T+=i;const k=Math.min(t.inHeight,c+S);for(let $=0;$<t.outWidth;++$){const E=$*a-f;let P=E;for(;P<0;)P+=l;const z=Math.min(t.inWidth,d+E);let B=Number.NEGATIVE_INFINITY,U=-1;for(let G=b;G<w;G+=o){const q=G-x;for(let K=T;K<k;K+=i){const H=K-S;for(let X=P;X<z;X+=l){const ne=X-E,re=n.get(g,G,K,X,m);re>=B&&(B=re,U=q*c*d+H*c+ne)}}}e.set(U,g,y,C,$,m)}}}return e}(e.bufferSync(a),c),p=c.strideDepth,f=c.strideHeight,g=c.strideWidth,m=c.dilationDepth,y=c.dilationHeight,x=c.dilationWidth,b=c.effectiveFilterDepth,w=c.effectiveFilterHeight,C=c.effectiveFilterWidth,S=b-1-c.padInfo.front,T=C-1-c.padInfo.left,k=w-1-c.padInfo.top,$=Be(a.shape,"float32"),E=e.bufferSync(r);for(let P=0;P<c.batchSize;++P)for(let z=0;z<c.inChannels;++z)for(let B=0;B<c.inDepth;++B)for(let U=0;U<c.inHeight;++U)for(let G=0;G<c.inWidth;++G){const q=B-S,K=U-k,H=G-T;let X=0;for(let ne=0;ne<b;ne+=m){const re=(q+ne)/p;if(!(re<0||re>=c.outDepth||Math.floor(re)!==re))for(let ie=0;ie<w;ie+=y){const oe=(K+ie)/f;if(!(oe<0||oe>=c.outHeight||Math.floor(oe)!==oe))for(let pe=0;pe<C;pe+=x){const le=(H+pe)/g;if(le<0||le>=c.outWidth||Math.floor(le)!==le)continue;const Ee=b*w*C-1-h.get(P,re,oe,le,z)===ne*w*C+ie*C+pe?1:0;0!==Ee&&(X+=E.get(P,re,oe,le,z)*Ee)}}}$.set(X,P,B,U,G,z)}return e.makeTensorInfo($.shape,$.dtype,$.values)}},KP={kernelName:vd,backendName:"cpu",kernelFunc:function qP(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a,output:o}=t,i=a;xe([a,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,h=Kn(i.shape,l,u,1,c,d),p=e.data.get(i.dataId).values,f=Be(h.outShape,i.dtype,dw(p,i.shape,i.dtype,h).values),g=h.strideHeight,m=h.strideWidth,y=h.dilationHeight,x=h.dilationWidth,b=h.effectiveFilterHeight,w=h.effectiveFilterWidth,C=w-1-h.padInfo.left,S=b-1-h.padInfo.top,T=Be(i.shape,"float32"),k=e.data.get(r.dataId).values,$=Be(r.shape,"float32",k);for(let E=0;E<h.batchSize;++E)for(let P=0;P<h.inChannels;++P)for(let z=0;z<h.inHeight;++z)for(let B=0;B<h.inWidth;++B){const U=z-S,G=B-C;let q=0;for(let K=0;K<b;K+=y){const H=(U+K)/g;if(!(H<0||H>=h.outHeight||Math.floor(H)!==H))for(let X=0;X<w;X+=x){const ne=(G+X)/m;if(ne<0||ne>=h.outWidth||Math.floor(ne)!==ne)continue;const oe=b*w-1-f.get(E,H,ne,P)===K*w+X?1:0;0!==oe&&(q+=$.get(E,H,ne,P)*oe)}}T.set(q,E,z,B,P)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}},ZP={kernelName:Sm,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=t,l=e;xe(s,"MaxPoolWithArgmax");const u=l.data.get(s.dataId).values,c=Kn(s.shape,r,a,[1,1],o),[d,h]=function XP(n,t,e,s,r){const o=Df(n,0,e,Ie(t),r,"max"),i=dw(n,t,e,r,!0,s);return[o.values,i.values]}(u,s.shape,s.dtype,i,c),p=l.write(d,c.outShape,s.dtype),f=l.write(h,c.outShape,s.dtype);return[{dataId:p,shape:c.outShape,dtype:s.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},JP={kernelName:Cl,backendName:"cpu",kernelFunc:function YP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s,i=ze(a,r.shape),c=W(Xt(r.shape,i)[1]),d=[],h=e.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=br({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});d.push(p);const f=Of({inputs:{a:p,b:h},backend:e});d.push(f);const g=Ri({inputs:{x:f},backend:e,attrs:{axis:a,keepDims:o}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),g}},eL={kernelName:Sl,backendName:"cpu",kernelFunc:function QP(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;xe(r,"min");const i=ze(a,r.shape);let l=i;const u=St(l,r.shape.length);let c=r;null!=u&&(c=_n({inputs:{x:r},backend:e,attrs:{perm:u}}),l=At(l.length,r.shape.length)),sn("min",l,c.shape.length);const[d,h]=Xt(c.shape,l),p=W(h),f=un(W(d),c.dtype),g=e.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const x=y*p;let b=g[x];for(let w=0;w<p;++w){const C=g[x+w];(Number.isNaN(C)||C<b)&&(b=C)}f[y]=b}null!=u&&e.disposeIntermediateTensorInfo(c);const m=e.makeTensorInfo(d,c.dtype,f);if(o){const x=ft({inputs:{x:m},backend:e,attrs:{shape:Et(d,i)}});return e.disposeIntermediateTensorInfo(m),x}return m}},zw=Ft((n,t)=>Math.min(n,t)),tL=Ht(Eo,zw),nL={kernelName:Eo,backendName:"cpu",kernelFunc:tL},rL={kernelName:Il,backendName:"cpu",kernelFunc:function sL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,mode:o}=s;xe(r,"mirrorPad");const i=a.map((b,w)=>b[0]+r.shape[w]+b[1]),l=a.map(b=>b[0]),u=a.map((b,w)=>b[0]+r.shape[w]),c="reflect"===o?0:1,d=e.data.get(r.dataId).values,h=r.shape.length,p=Ie(r.shape),f=W(i),g=i.length,m=Ie(i),y=ln(r.dtype,f);for(let b=0;b<f;b++){let w=fa(b,g,m);for(let S=0;S<g;S++)w[S]<l[S]?w[S]=2*l[S]-w[S]-c:w[S]>=u[S]&&(w[S]=2*(u[S]-1)-w[S]+c);w=w.map((S,T)=>S-l[T]);const C=gs(w,h,p);y[b]=d[C]}return{dataId:e.write(y,i,r.dtype),shape:i,dtype:r.dtype}}},aL=Ft((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),oL=Ht(Ao,aL),iL={kernelName:Ao,backendName:"cpu",kernelFunc:oL};function Bw(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:a}=s,o=r.shape.length;let i=a;if(-1===i&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const l=ze([i],r.shape),u=Mw({inputs:{x:r},backend:e,attrs:{reductionIndices:l,keepDims:!1}}),c=Et(u.shape,l),d=ft({inputs:{x:u},backend:e,attrs:{shape:c}}),h=Lf({inputs:{a:r,b:d},backend:e}),p=Sw({inputs:{x:h},backend:e}),f=Ri({inputs:{x:p},backend:e,attrs:{axis:l,keepDims:!1}}),g=ft({inputs:{x:f},backend:e,attrs:{shape:c}}),m=Of({inputs:{a:p,b:g},backend:e});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),m}const lL={kernelName:Wl,backendName:"cpu",kernelFunc:Bw},cL={kernelName:Im,backendName:"cpu",kernelFunc:function uL(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:a,seed:o,normalized:i}=s;xe(r,"multinomial");const l=i?r:Bw({inputs:{logits:r},backend:e,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=e.data.get(l.dataId).values,h=[u,a],p=un(W(h),"int32");for(let f=0;f<u;++f){const g=f*c,m=new Float32Array(c-1);m[0]=d[g];for(let b=1;b<m.length;++b)m[b]=m[b-1]+d[g+b];const y=Vh.alea(o.toString()),x=f*a;for(let b=0;b<a;++b){const w=y();p[x+b]=m.length;for(let C=0;C<m.length;C++)if(w<m[C]){p[x+b]=C;break}}}return i||e.disposeIntermediateTensorInfo(l),e.makeTensorInfo(h,"int32",p)}};function Ww(n,t,e){const s=er(-1,e);return Ff([],t,s,n,e)}const hL={kernelName:Tl,backendName:"cpu",kernelFunc:function dL(n){const{inputs:t,backend:e}=n,{x:s}=t;xe(s,"neg");const r=e.data.get(s.dataId).values,[a,o]=Ww(r,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,a)}},pL=Xh,mL={kernelName:Sd,backendName:"cpu",kernelFunc:function fL(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=s;xe(r,"NonMaxSuppression");const u=e.data.get(r.dataId).values,c=e.data.get(a.dataId).values,{selectedIndices:d}=pL(u,c,o,i,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},gL=Zh,xL={kernelName:Id,backendName:"cpu",kernelFunc:function yL(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s;xe(r,"NonMaxSuppressionPadded");const c=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=gL(c,d,o,i,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},bL=Yh,vL={kernelName:Td,backendName:"cpu",kernelFunc:function wL(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s;xe(r,"NonMaxSuppressionWithScore");const c=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,h=o,p=i,f=l,g=u,{selectedIndices:m,selectedScores:y}=bL(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},Uw=Ft((n,t)=>n!==t?1:0),CL=Ht(Nl,Uw,null,"bool"),SL={kernelName:Nl,backendName:"cpu",kernelFunc:CL},TL={kernelName:_l,backendName:"cpu",kernelFunc:function IL(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:a,depth:o,onValue:i,offValue:l}=s;xe(r,"oneHot");const u=W(r.shape),c=new Float32Array(u*o);c.fill(l);const d=e.data.get(r.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<o&&(c[h*o+d[h]]=i);return e.makeTensorInfo([...r.shape,o],a,c)}};function fc(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const r=ea({inputs:{input:s},backend:e}),a=fc({inputs:{x:r},backend:e}),o=Va({inputs:{input:s},backend:e}),i=fc({inputs:{x:o},backend:e}),l=Dn({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),l}return Vf({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const NL={kernelName:jl,backendName:"cpu",kernelFunc:fc},kL={kernelName:kl,backendName:"cpu",kernelFunc:function Gw(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const r=ea({inputs:{input:s},backend:e}),a=Gw({inputs:{x:r},backend:e}),o=Va({inputs:{input:s},backend:e}),i=fc({inputs:{x:o},backend:e}),l=Dn({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),l}return Vf({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function Hw(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return pc({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach(c=>{Hn(a,c.shape,"All tensors passed to stack must have matching shapes"),I(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=za({inputs:t.map(c=>{const d=pc({inputs:{input:c},backend:e,attrs:{dim:r}});return i.push(d),d}),backend:e,attrs:{axis:r}});return i.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}const _L={kernelName:$l,backendName:"cpu",kernelFunc:Hw},jw={kernelName:El,backendName:"cpu",kernelFunc:function $L(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,constantValue:o}=s;xe(r,"pad");const i=a.map((x,b)=>x[0]+r.shape[b]+x[1]),l=a.map(x=>x[0]),u=e.data.get(r.dataId).values,c=W(r.shape),d=r.shape.length,h=Ie(r.shape),p=W(i),f=i.length,g=Ie(i),m=ln(r.dtype,p);0!==o&&m.fill(o);for(let x=0;x<c;x++)m[gs(fa(x,d,h).map((S,T)=>S+l[T]),f,g)]=u[x];return{dataId:e.write(m,i,r.dtype),shape:i,dtype:r.dtype}}},EL=Ft((n,t)=>Math.pow(n,t)),AL=Ht(Ro,EL),DL={kernelName:Ro,backendName:"cpu",kernelFunc:AL};function qw(n,t,e,s){const[r,a]=Xt(n,s),o=An(t,"int32"),i=un(W(r),o),l=W(a);for(let u=0;u<i.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=e[c+h];i[u]=d}return{outVals:i,outShape:r,outDtype:o}}const FL={kernelName:Dl,backendName:"cpu",kernelFunc:function RL(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;xe(r,"prod");const i=r.shape.length,l=ze(a,r.shape),u=St(l,i);let c=l,d=r;const h=[];null!=u&&(d=_n({inputs:{x:r},backend:e,attrs:{perm:u}}),h.push(d),c=At(c.length,i));const p=e.data.get(d.dataId).values,{outVals:f,outShape:g,outDtype:m}=qw(d.shape,d.dtype,p,c);let y=g;return o&&(y=Et(g,l)),h.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.makeTensorInfo(y,m,f)}};function Kw(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function Xw(n,t,e,s,r,a,o,i){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function OL(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const a=fa(r,t.length,Ie(t)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${e})`)}})}(a,o,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const u=s[0],{outSplits:c,valueSlices:d,numValues:h}=function LL(n,t,e,s){const r=[];let a=0;const i=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function PL(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(0===s.length)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}(e,s);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)i[u].push(d*c)}for(let u=0;u<n.length;++u){let c=n[u],d=n[u]+1;for(let h=0;h<e.length;++h){const p=e[h],f=h+t.length-1;if(f>=0){const g=i[f],m=g[g.length-1]-p[c];for(let y=c;y<d;++y)i[f].push(p[y+1]+m)}c=p[c],d=p[d]}d!==c&&(r.push([c,d]),a+=d-c)}return{outSplits:i,valueSlices:r,numValues:a}}(a,o,n,u),p=function ML(n){const t=[];for(let e=0;e<n.length;++e){const r=$t("int32",n[e].length);t.push(r),n[e].forEach((a,o)=>r[o]=a)}return t}(c),f=function zL(n,t,e,s,r){const a=t.slice();a[0]=r;const o=$t(e,W(a)),i=n.length;return function VL(n,t,e,s,r,a){const o=Kw(t,2)[1],i=Kw(a,2)[1];let l=0;for(const u of e)for(let c=u[0];c<u[1];++c){for(let d=0;d<s;++d)r[l*i+d]=n[c*o+d];++l}}(n,t,s,0===i?0:i/t[0],o,a),[o,a]}(e,s,r,d,h);return[p,f[0],f[1]]}const WL={kernelName:Tm,backendName:"cpu",kernelFunc:function BL(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:o}=t,l=r.map(y=>e.data.get(y.dataId).values),u=r.map(y=>y.shape),c=e.data.get(a.dataId).values,d=e.data.get(o.dataId).values,[h,p,f]=Xw(l,u,c,a.shape,a.dtype,d,o.shape),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,a.dtype,p);return g.concat([m])}},Zw=2147483647;function Yw(n,t,e,s,r,a,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,l=0===r.length,u=0===o.length,c=[];i||c.push(t[0]),l||c.push(r[0]),u||c.push(o[0]);for(let m=1;m<c.length;++m)if(c[m]!==c[m-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=$t("int32",d+1);h[0]=0;for(let m=0;m<d;++m){const y=i?n[0]:n[m],x=l?s[0]:s[m],b=u?a[0]:a[m];if(0===b)throw new Error("Requires delta != 0");let w;if(b>0&&x<y||b<0&&x>y)w=0;else if(w=Math.ceil(Math.abs((x-y)/b)),w>Zw)throw new Error(`Requires ((limit - start) / delta) <= ${Zw}`);h[m+1]=h[m]+w}const f=$t(e,h[d]);let g=0;for(let m=0;m<d;++m){const y=h[m+1]-h[m];let x=i?n[0]:n[m];const b=u?a[0]:a[m];for(let w=0;w<y;++w)f[g++]=x,x+=b}return[h,f]}const GL={kernelName:Nm,backendName:"cpu",kernelFunc:function UL(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:a}=t,o=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,l=e.data.get(a.dataId).values,[u,c]=Yw(o,s.shape,s.dtype,i,r.shape,l,a.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],s.dtype,c)]}};var ts=Yn;class mc{constructor(t,e,s,r,a,o,i,l,u,c){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=yy(c),this.raggedRank=xy(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===ts.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===ts.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case ts.VALUE_ROWIDS:return mc.getMaxWidthValueRowID(e);case ts.ROW_SPLITS:return mc.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${ts[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let s=0;for(let r=0;r<e-1;++r){const a=t[r+1]-t[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let s=0,r=t[0],a=0;for(let o=1;o<e;++o){const i=t[o];i!==r&&(r=i,a=Math.max(o-s,a),s=o)}return Math.max(e-s,a)}tensorShapeFromTensor(t,e,s=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Qw(t,s)}calculateOutputSize(t){const e=this.valuesShape;by(this.defaultValueShape,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=gy(this.raggedRank,r,e);o[0]<0&&(o[0]=t);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),a=[];let o=0;for(let i=0;i<r;++i,o+=e)a.push(o);for(let i=r;i<t;++i)a.push(-1);return I(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,e,s,r){const a=t.length,o=[];for(let i=0;i<a-1;++i){const l=t[i+1]-t[i];let u=Math.min(r,l),c=e[i];-1===c&&(u=0);for(let d=0;d<u;++d)o.push(c),c+=s;for(let d=0;d<l-u;++d)o.push(-1)}if(a>0&&o.length!==t[a-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,s,r){const a=t.length,o=[];if(0===a)return[];let i=0,l=t[0];if(l>=e.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${e.length}`);let u=e[l];o.push(u);for(let c=1;c<a;++c){const d=t[c];if(d===l)u>=0&&(++i,i<r?u+=s:u=-1);else{if(i=0,l=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);u=e[d]}o.push(u)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,s,r){const a=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case ts.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,e,s,r);case ts.ROW_SPLITS:if(a.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(a,e,s,r);default:throw new Error(`Unsupported partition type: ${ts[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case ts.FIRST_DIM_SIZE:return t[0];case ts.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ts.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ts[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l)r[l]=r[l+1]*s[l+1];const a=Qw(s,!1),o=$t(this.valuesDType,W(a));if(r[0]*s[0]>0){let l=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,r[u],s[u]);this.setOutput(this.raggedRank,l,o,a)}return[a,o]}setOutput(t,e,s,r){if(0===s.length)return;const a=this.values,o=s;let i=r.slice();i=i.slice(t+1);const l=W(i),u=e.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const f=this.defaultValueShape;L(()=>{const g=O(c,f);c=li(g,i).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let g=f<u?e[f]:-1;if(g!==p){if(h<p){const m=a.subarray(d*l);Jw(o.subarray(h*l),m,(p-h)*l)}if(f>=u&&(g=Math.floor(s.length/l)),g>p)if(1===this.defaultValue.length)o.subarray(p*l,g*l).fill(this.defaultValue[0]),p=g;else for(;g>p;)Jw(o.slice(p*l),c,l),++p;g<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}else++p}}}function Jw(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function Qw(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function e1(n,t,e,s,r,a,o,i,l,u){return new mc(n,t,e,s,r,a,o,i,l,u).compute()}const jL={kernelName:km,backendName:"cpu",kernelFunc:function HL(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:a,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:l}=s,u=e.data.get(r.dataId).values,c=e.data.get(a.dataId).values,d=e.data.get(o.dataId).values,h=i.map(m=>e.data.get(m.dataId).values),p=i.map(m=>m.shape),[f,g]=e1(u,r.shape,c,a.shape,a.dtype,d,o.shape,h,p,l);return e.makeTensorInfo(f,a.dtype,g)}};function t1(n,t,e,s){if(n===t||n<t&&e<0||t<n&&e>1)return un(0,s);const l=un(Math.abs(Math.ceil((t-n)/e)),s);t<n&&1===e&&(e=-1),l[0]=n;for(let u=1;u<l.length;u++)l[u]=l[u-1]+e;return l}const KL={kernelName:Nd,backendName:"cpu",kernelFunc:function qL(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:a,step:o}=e,i=t1(s,r,o,a);return t.makeTensorInfo([i.length],a,i)}},XL=rt(Fo,n=>1/n),ZL={kernelName:Fo,backendName:"cpu",kernelFunc:XL},JL={kernelName:Ol,backendName:"cpu",kernelFunc:function YL(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;xe(r,"resizeBilinear");const l=Ie(r.shape),[u,c]=i,[d,h,p,f]=r.shape,g=e.data.get(r.dataId).values,m=new Float32Array(W([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],x=[a&&u>1?u-1:u,a&&c>1?c-1:c];let b=0;const w=y[0]/x[0],C=y[1]/x[1];for(let S=0;S<d;S++)for(let T=0;T<u;T++){let k;k=o?w*(T+.5)-.5:w*T;const $=Math.max(0,Math.floor(k)),E=k-$,P=Math.min(h-1,Math.ceil(k)),z=S*l[0]+$*l[1],B=S*l[0]+P*l[1];for(let U=0;U<c;U++){let G;G=o?C*(U+.5)-.5:C*U;const q=Math.max(0,Math.floor(G)),K=G-q,H=Math.min(p-1,Math.ceil(G)),X=z+q*l[2],ne=B+q*l[2],re=z+H*l[2],ie=B+H*l[2];for(let oe=0;oe<f;oe++){const pe=g[X+oe],le=g[ne+oe],Ee=pe+(g[re+oe]-pe)*K;m[b++]=Ee+(le+(g[ie+oe]-le)*K-Ee)*E}}}return e.makeTensorInfo([d,u,c,f],"float32",m)}},eM={kernelName:$d,backendName:"cpu",kernelFunc:function QL(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:o}=s;xe([a,r],"resizeBilinearGrad");const i=Ie(r.shape),[l,u,c,d]=r.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),g=[o&&h>1?u-1:u,o&&p>1?c-1:c],m=[o&&h>1?h-1:h,o&&p>1?p-1:p],y=g[0]/m[0],x=g[1]/m[1],b=e.data.get(a.dataId).values;let w=0;for(let C=0;C<l;C++){const S=C*i[0];for(let T=0;T<h;T++){const k=T*y,$=Math.floor(k),E=Math.min(Math.ceil(k),u-1),P=S+$*i[1],z=S+E*i[1],B=k-$,U=1-B;for(let G=0;G<p;G++){const q=G*x,K=Math.floor(q),H=Math.min(Math.ceil(q),c-1),X=q-K,ne=1-X,re=P+K*i[2],ie=P+H*i[2],oe=z+K*i[2],pe=z+H*i[2],le=U*ne,me=U*X,Te=B*ne,Ee=B*X;for(let ke=0;ke<d;ke++){const Me=b[w++];f[re+ke]+=Me*le,f[ie+ke]+=Me*me,f[oe+ke]+=Me*Te,f[pe+ke]+=Me*Ee}}}}return e.makeTensorInfo([l,c,u,d],"float32",f)}},nM={kernelName:Fl,backendName:"cpu",kernelFunc:function tM(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s;xe(r,"resizeNearestNeighbor");const l=Ie(r.shape),[u,c]=i,[d,h,p,f]=r.shape,g=e.data.get(r.dataId).values,m=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],x=[a&&u>1?u-1:u,a&&c>1?c-1:c],b=y[0]/x[0],w=y[1]/x[1];let C=0;for(let S=0;S<d;S++){const T=S*l[0];for(let k=0;k<u;k++){const $=o?b*(k+.5):b*k;let E=Math.min(h-1,a?Math.round($):Math.floor($));o&&(E=Math.max(0,E));const P=T+E*l[1];for(let z=0;z<c;z++){const B=o?w*(z+.5):w*z;let U=Math.min(p-1,a?Math.round(B):Math.floor(B));o&&(U=Math.max(0,U));const G=P+U*l[2];for(let q=0;q<f;q++)m[C++]=g[G+q]}}}return e.makeTensorInfo([d,u,c,f],r.dtype,m)}},rM={kernelName:_d,backendName:"cpu",kernelFunc:function sM(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:o}=s;xe([a,r],"resizeNearestNeighborGrad");const i=Ie(r.shape),l=Ie(a.shape),[u,c,d,h]=r.shape,[,p,f]=a.shape,g=new Float32Array(u*c*d*h),m=e.data.get(a.dataId).values,y=[o&&p>1?c-1:c,o&&f>1?d-1:d],x=[o&&p>1?p-1:p,o&&f>1?f-1:f],b=y[0]/x[0],w=y[1]/x[1],C=1/b,S=1/w,T=2*Math.ceil(C)+2,k=2*Math.ceil(S)+2;for(let $=0;$<u;$++){const E=$*i[0];for(let P=0;P<c;P++){const z=E+P*i[1],B=Math.floor(P*C),U=Math.floor(B-T/2);for(let G=0;G<d;G++){const q=z+G*i[2],K=Math.floor(G*S),H=Math.floor(K-k/2);for(let X=0;X<h;X++){let ne=0;for(let re=0;re<T;re++){const ie=re+U;if(ie<0||ie>=p)continue;const oe=E+ie*l[1],pe=ie*b;if(P===Math.min(c-1,o?Math.round(pe):Math.floor(pe)))for(let me=0;me<k;me++){const Te=me+H;if(Te<0||Te>=f)continue;const Ee=oe+Te*l[2],ke=Te*w;G===Math.min(d-1,o?Math.round(ke):Math.floor(ke))&&(ne+=m[Ee+X])}}g[q+X]=ne}}}}return e.makeTensorInfo(r.shape,r.dtype,g)}},oM={kernelName:Pl,backendName:"cpu",kernelFunc:function aM(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:a}=s;xe(r,"reverse");const o=r.shape.length,i=ze(a,r.shape);if(0===o)return Es({inputs:{x:r},backend:e});const l=new tn(r.shape,r.dtype),u=e.bufferSync(r);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();i.forEach(p=>h[p]=r.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return e.makeTensorInfo(l.shape,l.dtype,l.values)}},iM={kernelName:Wd,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:a,center:o}=t,i=e,l=ln(s.dtype,W(s.shape)),[u,c,d,h]=s.shape,[p,f]=rp(o,c,d),m=Math.sin(r),y=Math.cos(r),x=i.data.get(s.dataId).values;for(let w=0;w<u;w++){const C=w*d*c*h;for(let S=0;S<c;S++){const T=S*(d*h);for(let k=0;k<d;k++){const $=k*h;for(let E=0;E<h;E++){const P=[u,S,k,E],z=P[2],B=P[1];let U=(z-p)*y-(B-f)*m,G=(z-p)*m+(B-f)*y;U=Math.round(U+p),G=Math.round(G+f);let q=a;"number"!=typeof a&&(q=3===E?255:a[E]),U>=0&&U<d&&G>=0&&G<c&&(q=x[C+G*(d*h)+U*h+E]),l[C+T+$+E]=q}}}}return{dataId:i.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},lM=rt(Lo,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),uM={kernelName:Lo,backendName:"cpu",kernelFunc:lM},n1=$s(n=>1/Math.sqrt(n)),cM=xr(Mo,n1),dM={kernelName:Mo,backendName:"cpu",kernelFunc:cM};function na(n,t,e,s,r,a,o,i,l,u){const c=[s/r,r],d=n.values,h=t.values;if(0===s)return Be(e,t.dtype);const p=l instanceof tn?l:Be(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let f=0;f<a;f++){const g=[];let m=0;for(let y=0;y<o;y++){const x=d[f*o+y];g.push(x),m+=x*i[y]}if(m<0||m>=s/r)throw new Error(`Invalid indices: ${g} does not index into ${e}`);for(let y=0;y<r;y++)u?p.values[m*r+y]+=h[f*r+y]:p.values[m*r+y]=0===t.rank?h[0]:h[f*r+y]}return p}const pM={kernelName:_m,backendName:"cpu",kernelFunc:function hM(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:a}=t,{shape:o}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=jr(0,r,o),g=na(e.bufferSync(r),e.bufferSync(a),o,d,u,l,i,c,0,!0);return e.makeTensorInfo(o,g.dtype,g.values)}};function fM(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function mM(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}const xM={kernelName:Em,backendName:"cpu",kernelFunc:function yM(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:a}=t,{side:o}=s,u=function gM(n,t,e,s,r,a){const o=$t("int32",e*r);for(let i=0;i<e;++i){const l=n.slice(i*s,(i+1)*s),u=i*r;for(let c=0;c<r;++c)o[u+c]="left"===a?fM(l,t[c+u]):mM(l,t[c+u])}return o}(e.data.get(r.dataId).values,e.data.get(a.dataId).values,r.shape[0],r.shape[1],a.shape[1],o);return e.makeTensorInfo(a.shape,"int32",u)}},wM={kernelName:Ll,backendName:"cpu",kernelFunc:function bM(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:a}=t;xe([s,r,a],"select");const o=s.shape.length,i=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,c=An(r.dtype,a.dtype),d=un(W(r.shape),c);let h=0;const p=0===o||o>1||1===r.shape.length?1:W(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let g=0;g<p;g++)d[h++]=1===i[f]?l[f]:u[f];return e.makeTensorInfo(r.shape,c,d)}},vM=ku,CM=_u,SM=rt(Vo,n=>n>=0?CM*n:vM*(Math.exp(n)-1)),IM={kernelName:Vo,backendName:"cpu",kernelFunc:SM},TM=rt(Wo,n=>n<0?-1:n>0?1:0),NM={kernelName:Wo,backendName:"cpu",kernelFunc:TM},kM=rt(zo,n=>Math.sin(n)),_M={kernelName:zo,backendName:"cpu",kernelFunc:kM},$M=rt(Bo,n=>Math.sinh(n)),EM={kernelName:Bo,backendName:"cpu",kernelFunc:$M},s1=Math.log(1.1920928955078125e-7)+2,AM=rt(Go,n=>{const t=n>-s1,e=n<s1,s=Math.exp(n);let r;return r=e?s:t?n:Math.log(1+s),r}),DM={kernelName:Go,backendName:"cpu",kernelFunc:AM},FM={kernelName:zl,backendName:"cpu",kernelFunc:function RM(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,paddings:o}=s;xe([r],"spaceToBatchND");const i=W(a),l=[[0,0]];l.push(...o);for(let S=1+a.length;S<r.shape.length;++S)l.push([0,0]);const u=jw.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),c=gi(u.shape,a,i,!1),d=yi(c.length,a.length,!1),h=xi(u.shape,a,i,!1),g=ft({inputs:{x:u},backend:e,attrs:{shape:c}}),x=_n({inputs:{x:g},backend:e,attrs:{perm:d}}),C=ft({inputs:{x},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(x),C}};function r1(n,t,e,s,r,a,o){const i=t[0],l=a[0],u=new Array(l),c=new Array(i),d=t[1];if(0===l){if(0!==i)throw new Error($y(i));return[$t(e,0),[0,d],$t(r,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<i;++m){const y=n[m*d];if(y<0)throw new Error(Ey(m,y));if(y>=l)throw new Error(Ay(m,y,l));++f[y],h=h&&y>=p,p=y}let g=!0;for(let m=0;m<l;++m){const y=0===f[m];u[m]=y,g=g&&!y,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&h){const m=n,y=s;for(let x=0;x<i;++x)c[x]=x;return[m,[i,d],y,u,c]}{const m=f[l-1],y=$t(e,m*d),x=$t(r,m),b=new Array(l).fill(0);for(let w=0;w<i;++w){const C=n[w*d],T=(0===C?0:f[C-1])+b[C];b[C]++;for(let k=0;k<d;++k)y[T*d+k]=n[w*d+k];x[T]=s[w],c[w]=T}for(let w=0;w<l;++w)if(0===b[w]){const S=0===w?0:f[w-1];y[S*d+0]=w;for(let T=1;T<d;++T)y[S*d+T]=0;x[S]=o}return[y,[m,d],x,u,c]}}const PM={kernelName:Ed,backendName:"cpu",kernelFunc:function OM(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:a,defaultValue:o}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=e.data.get(s.dataId).values,l=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,c=e.data.get(o.dataId).values[0],[d,h,p,f,g]=r1(i,s.shape,s.dtype,l,r.dtype,u,c);return[e.makeTensorInfo(h,s.dtype,d),e.makeTensorInfo([h[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}};function a1(n,t,e,s,r){const a=W(s),o=t[0],i=r.length,l=[];let u=1,c=-1;for(let m=0;m<i;++m){const y=r[m];if(-1===y){if(-1!==c)throw new Error(Dy(c,m));c=m,l.push(1)}else{if(y<0)throw new Error(Ry(m,y));u*=y,l.push(y)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const m=Math.trunc(a/u);if(u*m!==a)throw new Error(Oy(s,l));l[c]=m}if(W(l)!==a)throw new Error(Py(s,l));const h=s.length,p=[];if(h>0){p[h-1]=1;for(let m=h-2;m>=0;--m)p[m]=p[m+1]*s[m+1]}const f=[];if(i>0){f[i-1]=1;for(let m=i-2;m>=0;--m)f[m]=f[m+1]*l[m+1]}const g=$t(e,o*i);for(let m=0;m<o;++m){let y=0;for(let x=0;x<h;++x)y+=n[m*h+x]*p[x];for(let x=0;x<i;++x)g[m*i+x]=Math.trunc(y/f[x]),y%=f[x]}return[g,[o,i],l]}const MM={kernelName:Ad,backendName:"cpu",kernelFunc:function LM(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(e.data.get(r.dataId).values),i=e.data.get(s.dataId).values,l=Array.from(e.data.get(a.dataId).values),[u,c,d]=a1(i,s.shape,s.dtype,o,l);return[e.makeTensorInfo(c,s.dtype,u),e.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}};function zf(n,t,e,s,r,a=!1,o=0){const i=s.length,l=[t[0],n.length/t[0]],u=l[1],d=i>0?r[i-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=d;const f=$t(e,h.reduce((b,w)=>b*w,1));if(0===i)return d>0&&f.fill(o),[f,h];if(d<=0)throw new Error("segment ids must be >= 0");let g=0,m=1,y=0,x=r[g];for(;;){let b=0;if(m<i){if(b=r[m],x===b){++m;continue}if(x>=b)throw new Error("segment ids are not increasing")}if(x<0||x>=d)throw new Error(My(x,d));x>y&&f.fill(o,y*u,x*u);for(let w=g;w<m;++w){const C=s[w];if(C<0||C>=l[0])throw new Error(Vy(w,s[w],l[0]));for(let S=0;S<u;S++)f[x*u+S]+=n[C*u+S]}if(a)for(let w=0;w<u;w++)f[x*u+w]/=m-g;if(g=m,++m,y=x+1,x=b,m>i)break}return y<d&&f.fill(o,y*u,d*u),[f,h]}const zM={kernelName:Dd,backendName:"cpu",kernelFunc:function VM(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,l=e.data.get(a.dataId).values,[u,c]=zf(o,s.shape,s.dtype,i,l,!0);return e.makeTensorInfo(c,s.dtype,u)}},WM={kernelName:Rd,backendName:"cpu",kernelFunc:function BM(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,l=e.data.get(a.dataId).values,[u,c]=zf(o,s.shape,s.dtype,i,l);return e.makeTensorInfo(c,s.dtype,u)}},GM={kernelName:Am,backendName:"cpu",kernelFunc:function UM(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:o}=t,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=jr(0,r,i),p=!1,f=e.bufferSync(r);let g;switch(a.dtype){case"bool":g=na(f,e.bufferSync(a),i,h,c,u,l,d,Boolean(e.data.get(o.dataId).values[0]),p);break;case"float32":case"int32":g=na(f,e.bufferSync(a),i,h,c,u,l,d,e.data.get(o.dataId).values[0],p);break;case"string":g=na(f,e.bufferSync(a),i,h,c,u,l,d,nr(e.data.get(o.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return e.makeTensorInfo(i,g.dtype,g.values)}},jM={kernelName:Bl,backendName:"cpu",kernelFunc:function HM(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:a,axis:o}=s,i=ze(o,r.shape)[0],l=vp(r,a,i),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map(d=>{const h=[...c];h[i]=d;const p=ta({inputs:{x:r},backend:e,attrs:{begin:u,size:h}});return u[i]+=d,p})}},qM=$s(n=>Math.sqrt(n)),KM=rt(Ho,n=>Math.sqrt(n)),XM={kernelName:Ho,backendName:"cpu",kernelFunc:KM},ZM={kernelName:Fd,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;xe(e,"square");const r=s.data.get(e.dataId).values,a=new Float32Array(r.length);for(let i=0;i<r.length;++i){const l=r[i];a[i]=l*l}return{dataId:s.write(a,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},o1=Ft((n,t)=>{const e=n-t;return e*e}),YM=Ht(jo,o1),JM={kernelName:jo,backendName:"cpu",kernelFunc:YM},i1=$s((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),eV={kernelName:Ul,backendName:"cpu",kernelFunc:xr(Ul,i1)},tV=rt(Yo,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),nV={kernelName:Yo,backendName:"cpu",kernelFunc:tV};function l1(n,t,e,s){const r=Be(n,t.dtype);for(let a=0;a<r.size;a++){const o=r.indexToLoc(a),i=new Array(o.length);for(let l=0;l<i.length;l++)i[l]=o[l]*e[l]+s[l];r.set(t.get(...i),...o)}return r}const rV={kernelName:Od,backendName:"cpu",kernelFunc:function sV(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s;xe(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:b,strides:w}=Ih(r.shape,a,o,i,l,u,c,d,h);let C;if(g)C=ft({inputs:{x:r},backend:e,attrs:{shape:f}});else if(m||y){I(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const S=vh(x,b,w),T=ta({inputs:{x:r},backend:e,attrs:{begin:x,size:S}});C=ft({inputs:{x:T},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(T)}else{const T=l1(p,e.bufferSync(r),w,x);C=e.makeTensorInfo(f,T.dtype,T.values)}return C}};class aV{constructor(t,e,s,r,a,o){this.separator=tr(t),this.nGramWidths=e,this.leftPad=tr(s),this.rightPad=tr(r),this.padWidth=a,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,a,o){for(let i=0;i<a;++i){const l=this.getPadWidth(o),u=Math.max(0,l-i),c=Math.max(0,l-(a-(i+1))),d=o-(u+c),h=e+(u>0?0:i-l);let p=0;p+=u*this.leftPad.length;for(let x=0;x<d;++x)p+=t[h+x].length;p+=c*this.rightPad.length,p+=(u+c+d-1)*this.separator.length,s[r+i]=new Uint8Array(p);const g=s[r+i];let m=0;const y=x=>x.forEach(b=>g[m++]=b);for(let x=0;x<u;++x)y(this.leftPad),y(this.separator);for(let x=0;x<d-1;++x)y(t[h+x]),y(this.separator);if(d>0){y(t[h+d-1]);for(let x=0;x<c;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<c-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let l=e[0];if(0!==l)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<r;++u){let c=e[u]>=l;if(c=c&&e[u]<=s,!c)throw new Error(`Invalid split value ${e[u]}, must be in [${l}, ${s}]`);l=e[u]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const a=r-1,o=$t("int32",r);if(0===s||0===r){const l=new Array(s);for(let u=0;u<=a;++u)o[u]=0;return[l,o]}o[0]=0;for(let l=1;l<=a;++l){const u=e[l]-e[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&0===c&&(c=1),o[l]=o[l-1]+c}const i=new Array(o[a]);for(let l=0;l<a;++l){const u=e[l];let c=o[l];if(this.nGramWidths.forEach(d=>{const p=this.getNumNGrams(e[l+1]-e[l],d);this.createNGrams(t,u,i,c,p,d),c+=p}),this.preserveShort&&c===o[l]){const d=e[l+1]-e[l];if(0===d)continue;this.createNGrams(t,u,i,c,1,d+2*this.padWidth)}}return[i,o]}}function u1(n,t,e,s,r,a,o,i){return new aV(e,s,r,a,o,i).compute(n,t)}const iV={kernelName:Pd,backendName:"cpu",kernelFunc:function oV(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=t,h=e.data.get(c.dataId).values,p=e.data.get(d.dataId).values,[f,g]=u1(h,p,r,a,o,i,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}};function lV(n,t,e,s){if(!n.length)return;if(0===t.length){for(let a=0;a<n.length;++a)s.push(n.subarray(a,a+1));return}if(1===t.length){const a=t[0];let o=n.indexOf(a);for(;-1!==o;){const i=n.subarray(0,o);(!e||0!==i.length)&&s.push(i),o=(n=n.subarray(o+1)).indexOf(a)}return void((!e||0!==n.length)&&s.push(n))}let r=0;for(let a=0;a<n.length+1;a++)if(a===n.length||-1!==t.indexOf(n[a])){const o=n.subarray(r,a);(!e||0!==o.length)&&s.push(o),r=a+1}}function c1(n,t,e){const s=n.length,r=[];let a=0,o=0;const i=new Array(s);for(let h=0;h<s;++h){const p=r.length;lV(n[h],t,e,r);const f=r.length-p;i[h]=f,a+=f,o=Math.max(o,f)}const l=$t("int32",2*a),u=new Array(a),c=[s,o];let d=0;for(let h=0;h<s;++h)for(let p=0;p<i[h];++p)l[2*d]=h,l[2*d+1]=p,u[d]=r[d],++d;return[l,u,c]}const cV={kernelName:Ld,backendName:"cpu",kernelFunc:function uV(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:o}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=e.data.get(a.dataId).values,l=e.data.get(o.dataId).values[0],[u,c,d]=c1(i,l,r),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}};function d1(n,t){const e=$t("int32",n.length);for(let s=0;s<n.length;++s)e[s]=bC(n[s]).modulo(t).getLowBitsUnsigned();return e}const hV={kernelName:Md,backendName:"cpu",kernelFunc:function dV(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=d1(e.data.get(a.dataId).values,r);return e.makeTensorInfo(a.shape,"int32",i)}},pV=rt(Ko,n=>Math.tan(n)),fV={kernelName:Ko,backendName:"cpu",kernelFunc:pV},mV=rt(Xo,n=>Math.tanh(n));function h1(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=Be(e,n.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=a[l]%n.shape[l];const i=n.locToIndex(o);s.values[r]=n.values[i]}return s}const Fi=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function p1(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const i=s-e+1,l=t-e+1,u=Math.log(i),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(i-c)/i)*Math.sign(l-i/2);p1(n,t,Math.max(e,Math.floor(t-l*c/i+d)),Math.min(s,Math.floor(t+(i-l)*c/i+d)))}const r=n[t];let a=e,o=s;for(Ys(n,e,t),Fi(n[s],r)>0&&Ys(n,e,s);a<o;){for(Ys(n,a,o),a++,o--;Fi(n[a],r)<0;)a+=1;for(;Fi(n[o],r)>0;)o-=1}0===Fi(n[e],r)?Ys(n,e,o):(o+=1,Ys(n,o,s)),o<=t&&(e=o+1),t<=o&&(s=o-1)}}function f1(n,t,e,s,r){const a=t[t.length-1],[o,i]=[n.length/a,a],l=ln(e,o*s),u=ln("int32",o*s);for(let d=0;d<o;d++){const h=d*i,p=n.subarray(h,h+i);let f=new Array(p.length);p.forEach((x,b)=>f[b]={value:x,index:b}),s<f.length&&(p1(f,s),f=f.slice(0,s)),r&&f.sort(Fi);const g=d*s,m=l.subarray(g,g+s),y=u.subarray(g,g+s);for(let x=0;x<s;x++)m[x]=f[x].value,y[x]=f[x].index}const c=t.slice();return c[c.length-1]=s,[Be(c,e,l),Be(c,"int32",u)]}function m1(n,t,e){switch(e){case"reflect":return function TV(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return $r(0,e,t-1)}(n,t);case"wrap":return function NV(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),$r(0,e,t-1)}(n,t);case"nearest":return function _V(n,t){return $r(0,n,t-1)}(n,t);default:return function kV(n,t){return n}(n)}}function Oi(n,t,e,s,r,a,o,i,l,u,c){return 0<=i&&i<t&&0<=l&&l<e?n[o*s+i*r+l*a+u]:c}function $V(n,t,e,s,r,a,o,i,l,u,c){return Oi(n,t,e,s,r,a,o,Math.round(i),Math.round(l),u,c)}function EV(n,t,e,s,r,a,o,i,l,u,c){const d=Math.floor(i),h=Math.floor(l),p=d+1,f=h+1;return(p-i)*((f-l)*Oi(n,t,e,s,r,a,o,d,h,u,c)+(l-h)*Oi(n,t,e,s,r,a,o,d,f,u,c))+(i-d)*((f-l)*Oi(n,t,e,s,r,a,o,p,h,u,c)+(l-h)*Oi(n,t,e,s,r,a,o,p,f,u,c))}function g1(n,t,e,s){const r=ze(t,e)[0],a=[1,e[0],1];for(let f=0;f<r;f++)a[0]*=e[f];a[1]=e[r];for(let f=r+1;f<e.length;f++)a[2]*=e[f];const o=new Map,i=new Int32Array(e[r]),l=new tn(a,s,n),u=[],c=1===a[0]&&1===a[2];for(let f=0;f<e[r];f++){let g;if(c)g=n[f].toString();else{const y=[];for(let x=0;x<a[0];x++)for(let b=0;b<a[2];b++)y.push(l.get(x,f,b));g=y.join(",")}const m=o.get(g);if(null!=m)i[f]=m;else{const y=o.size;o.set(g,y),i[f]=y,u.push(f)}}const d=a.slice();d[1]=o.size;const h=new tn(d,s);u.forEach((f,g)=>{for(let m=0;m<a[0];m++)for(let y=0;y<a[2];y++)h.set(l.get(m,f,y),m,g,y)});const p=e.slice();return p[r]=d[1],{outputValues:h.values,outputShape:p,indices:i}}const LV=[AR,DR,FR,PR,kR,MR,BR,UR,HR,qR,XR,YR,QR,nF,rF,iF,uF,dF,pF,$R,mF,xF,wF,CF,IF,TR,NF,_F,SR,$F,AF,DF,FF,PF,MF,zF,WF,GF,jF,KF,ZF,JF,eO,nO,sO,aO,iO,uO,cO,dO,hO,fO,bO,fR,vO,CO,EO,AO,DO,FO,WO,UO,HO,qO,XO,YO,QO,tP,sP,aP,iP,mR,uP,EF,dP,pP,mP,gR,yP,bP,vP,SP,TP,_P,EP,RP,OP,LP,MP,zP,WP,GP,jP,KP,ZP,JP,eL,nL,rL,iL,cL,gO,hL,mL,xL,vL,SL,TL,kL,_L,jw,DL,xR,FL,WL,GL,jL,KL,IR,Pf,ZL,bR,wR,_R,JL,eM,nM,rM,oM,iM,uM,dM,pM,xM,wM,IM,CR,NM,_M,EM,gF,lL,DM,FM,PM,MM,zM,WM,GM,jM,XM,ZM,JM,eV,nV,rV,iV,cV,hV,LO,yO,fV,{kernelName:Xo,backendName:"cpu",kernelFunc:mV},{kernelName:$m,backendName:"cpu",kernelFunc:function yV(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:a}=t,{sliceRank:o,numUpdates:i,sliceSize:l,strides:u,outputSize:c}=jr(0,r,s.shape),h=e.bufferSync(r),p=e.bufferSync(a),f=e.bufferSync(s),g=na(h,p,s.shape,c,l,i,o,u,f,!1);return e.makeTensorInfo(s.shape,g.dtype,g.values)}},{kernelName:Zo,backendName:"cpu",kernelFunc:function bV(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:a}=s;xe(r,"tile");const o=h1(e.bufferSync(r),a);return e.makeTensorInfo(o.shape,o.dtype,o.values)}},{kernelName:Vd,backendName:"cpu",kernelFunc:function vV(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:a,sorted:o}=s;xe(r,"topk");const i=e.data.get(r.dataId).values,[l,u]=f1(i,r.shape,r.dtype,a,o);return[e.makeTensorInfo(l.shape,l.dtype,l.values),e.makeTensorInfo(u.shape,u.dtype,u.values)]}},{kernelName:zd,backendName:"cpu",kernelFunc:function SV(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=e,[c,d,h,p]=r.shape,[f,g]=null!=u?u:[d,h],m=[c,f,g,p],y=Ie(r.shape),x=y[0],b=y[1],w=y[2],C=Ie(m),S=C[0],T=C[1],k=C[2],$=ln(r.dtype,W(m));$.fill(l);const E=s.data.get(r.dataId).values,P=s.data.get(a.dataId).values;for(let B=0;B<c;++B){const U=1===a.shape[0]?P:P.subarray(8*B,8*B+8);for(let G=0;G<f;++G)for(let q=0;q<g;++q)for(let K=0;K<p;++K){let H;const X=U[6]*q+U[7]*G+1;if(0===X)continue;const re=(U[3]*q+U[4]*G+U[5])/X,ie=m1((U[0]*q+U[1]*G+U[2])/X,h,i),oe=m1(re,d,i);switch(o){case"nearest":H=$V(E,d,h,x,b,w,B,oe,ie,K,l);break;case"bilinear":H=EV(E,d,h,x,b,w,B,oe,ie,K,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}$[B*S+G*T+q*k+K]=H}return s.makeTensorInfo(m,r.dtype,$)}return{dataId:s.write($,m,r.dtype),shape:r.shape,dtype:r.dtype}}},VR,{kernelName:Bd,backendName:"cpu",kernelFunc:function AV(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:a}=t;xe(a,"unique");const o=s.data.get(a.dataId).values,{outputValues:i,outputShape:l,indices:u}=g1(o,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}},{kernelName:Gl,backendName:"cpu",kernelFunc:function RV(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r.shape.length,i=r.shape[a],l=new Array(o-1);let u=0;for(let p=0;p<o;p++)p!==a&&(l[u++]=r.shape[p]);const c=new Array(o).fill(0),d=r.shape.slice();d[a]=1;const h=new Array(i);for(let p=0;p<h.length;p++){c[a]=p;const f=ta({inputs:{x:r},backend:e,attrs:{begin:c,size:d}});h[p]=ft({inputs:{x:f},backend:e,attrs:{shape:l}}),e.disposeIntermediateTensorInfo(f)}return h}},{kernelName:Hl,backendName:"cpu",kernelFunc:function OV(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:a}=t,{numSegments:o}=s;xe(r,"unsortedSegmentSum");const u=[],c=[],d=r.shape.length-a.shape.length;let h=a;for(let f=0;f<d;++f){const g=pc({inputs:{input:h},backend:e,attrs:{dim:f+1}});h=g,c.push(g)}for(let f=0;f<o;++f){const g=er(f,"int32"),m=e.makeTensorInfo([],"int32",g),y=vw({inputs:{a:m,b:h},backend:e}),x=br({inputs:{x:y},backend:e,attrs:{dtype:"float32"}}),b=hc({inputs:{a:x,b:r},backend:e}),w=Ri({inputs:{x:b},backend:e,attrs:{axis:0,keepDims:!1}});u.push(w),c.push(m),c.push(y),c.push(x),c.push(b),c.push(w)}const p=Hw({inputs:u,backend:e,attrs:{axis:0}});return c.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},NL];for(const n of LV)Gd(n);const wr={},gc={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function ps(n,t){if(!(n in wr)||null!=t){const s=function zV(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=null==t?function VV(n){if(!V().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===n)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n):t;return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete wr[n]},!1),V().getBool("SOFTWARE_WEBGL_ENABLED")&&(gc.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",gc)||e.getContext("experimental-webgl",gc):e.getContext("webgl2",gc)}(n,t);if(null===s)return console.log("Could not get context for WebGL version",n),null;wr[n]=s}const e=wr[n];return null==e||e.isContextLost()?(delete wr[n],ps(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),wr[n])}var Ba=(()=>{return(n=Ba||(Ba={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",Ba;var n})(),Rn=(()=>{return(n=Rn||(Rn={}))[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD",Rn;var n})(),Jt=(()=>{return(n=Jt||(Jt={}))[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",Jt;var n})();function Pi(n,t){return[t,n]}function yc(n){const t=W(n);return zc(Math.ceil(t/4))}function Wa(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function Bf(n,t){const e=n;let s,r,a,o,i,l,u,c,d,h;return 2===V().getNumber("WEBGL_VERSION")?(s=e.R32F,r=e.R16F,a=e.RGBA16F,o=e.RGBA32F,i=e.RED,u=4,c=1,d=e.HALF_FLOAT,h=e.FLOAT,l=e.RGBA8):(s=n.RGBA,r=n.RGBA,a=n.RGBA,o=e.RGBA,i=n.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function ce(n,t){const e=t();return V().getBool("DEBUG")&&function UV(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function qV(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function jV(n){return!!(V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function xc(n,t){return Ks(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const ZV=/ERROR: [0-9]+:([0-9]+):/g;function y1(n,t){const e=ZV.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const s=+e[1],r=n.split("\n"),a=r.length.toString().length+2,o=r.map((d,h)=>ha((h+1).toString(),a)+d);let i=0;for(let d=0;d<o.length;d++)i=Math.max(o[d].length,i);const l=o.slice(0,s-1),u=o.slice(s-1,s),c=o.slice(s);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ha(u[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function Wf(n,t){if(ce(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function x1(n,t,e,s,r,a,o){const i=n.getAttribLocation(t,e);return-1!==i&&(ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ce(n,()=>n.vertexAttribPointer(i,r,n.FLOAT,!1,a,o)),ce(n,()=>n.enableVertexAttribArray(i)),!0)}function i3(n,t,e,s){ce(n,()=>function r3(n,t,e){(function w1(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),ce(n,()=>n.activeTexture(n.TEXTURE0+e)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,s)),ce(n,()=>n.uniform1i(e,s))}function Uf(n,t,e){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function b1(n,t){ce(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ce(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function bc(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function l3(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Ks(n,t,e){const s=ce(n,()=>t());if(null==s)throw new Error(e);return s}function Ua(n,t=2){return W(n.slice(0,n.length-t))}function Ga(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function wc(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Ua(n),...Ga(n)]),t}function vc(n){return n%2==0}function Cc(n,t){if(Qe(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||vc(e)&&vc(s)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&vc(n[0])&&vc(t[0])}let Sc,Ic;function ns(n,t){return null!=n.getExtension(t)}function v1(n){try{if(null!=ps(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Gf(n){const t=Bf(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(a),o}function Li(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&I("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Ce=V();function vn(){let n,t,e,s,r,a,o,i,l,u;return 2===V().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",s="in",r="texture",a="outputColor",o="out vec4 outputColor;",i=V().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",s="varying",r="texture2D",a="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:l,defineRound:u}}function sa(n,t,e="index"){const s=Ie(t);return s.map((r,a)=>`int ${n[a]} = ${e} / ${r}; ${a===s.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * ${r}`:`index -= ${n[a]} * ${r}`};`).join("")}function Tc(n,t,e="index"){const s=Ie(t);return s.map((r,a)=>`int ${n[a]} = ${e} / outShapeStrides[${a}]; ${a===s.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`};`).join("")}function Hf(n){const t=Ie(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}Ce.registerFlag("HAS_WEBGL",()=>Ce.getNumber("WEBGL_VERSION")>0),Ce.registerFlag("WEBGL_VERSION",()=>v1(2)?2:v1(1)?1:0),Ce.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),Ce.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===Ce.get("WEBGL_VERSION")),Ce.registerFlag("WEBGL_CPU_FORWARD",()=>!0),Ce.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),Ce.registerFlag("WEBGL_PACK",()=>Ce.getBool("HAS_WEBGL")),Ce.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_CLIP",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_REDUCE",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_CONV_IM2COL",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Ce.getBool("WEBGL_PACK")),Ce.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function c3(n){if(null==Sc){const t=ps(n);Sc=t.getParameter(t.MAX_TEXTURE_SIZE)}return Sc}(Ce.getNumber("WEBGL_VERSION"))),Ce.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function d3(n){if(null==Ic){const t=ps(n);Ic=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Ic)}(Ce.getNumber("WEBGL_VERSION"))),Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ce.getNumber("WEBGL_VERSION");return 0===n?0:function h3(n){if(0===n)return 0;let t;const e=ps(n);return t=ns(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:ns(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),Ce.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ce.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Km()),Ce.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function p3(n){if(0===n)return!1;const t=ps(n);if(1===n){if(!ns(t,"OES_texture_float"))return!1}else if(!ns(t,"EXT_color_buffer_float"))return!1;return Gf(t)}(Ce.getNumber("WEBGL_VERSION"))),Ce.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!Ce.getBool("WEBGL_FORCE_F16_TEXTURES")&&Ce.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),Ce.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function f3(n){if(0===n)return!1;const t=ps(n);if(1!==n){if(ns(t,"EXT_color_buffer_float"))return Gf(t);const s="EXT_color_buffer_half_float";if(ns(t,s)){const r=t.getExtension(s);return function m3(n,t){const e=Bf(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),i}(t,r)}return!1}return!(!ns(t,"OES_texture_float")||!ns(t,"WEBGL_color_buffer_float"))&&Gf(t)}(Ce.getNumber("WEBGL_VERSION"))),Ce.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function g3(n){return 2===n&&null!=ps(n).fenceSync}(Ce.getNumber("WEBGL_VERSION"))),Ce.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ce.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),Ce.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),Ce.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Km()?1:-1,n=>{if("number"!=typeof n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),Ce.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),Ce.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),Ce.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),Ce.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),Ce.registerFlag("WEBGL_EXP_CONV",()=>!1),Ce.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Ce.getBool("IS_TEST")),Ce.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),Ce.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),Ce.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),Ce.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const C1="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:S1}=Ae;function b3(n,t,e){const s=[];if(n.forEach(p=>{const f=W(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),e.enableShapeUniforms){const{uniformShape:g}=qf(e.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`)}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;")}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join("\n"),a=n.map(p=>function w3(n,t,e=!1,s){let r="";return r+=e?I1(n,s):Ha(n,s),n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=e?function Q3(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=S1(n.shapeInfo.logicalShape,t.logicalShape),l=lt(o),u=o-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":o<2&&i.length>=1?"coords = 0;":i.map(x=>`coords.${d[x+u]} = 0;`).join("\n");let h="";h=o<2&&a>0?"coords":n.shapeInfo.logicalShape.map((x,b)=>`coords.${d[b+u]}`).join(", ");let p="return outputValue;";const g=1===W(n.shapeInfo.logicalShape),y=1===W(t.logicalShape);if(1!==a||g||y){if(g&&!y)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const x=a-2,b=a-1;i.indexOf(x)>-1&&i.indexOf(b)>-1?p="return vec4(outputValue.x);":i.indexOf(x)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${h});\n      ${p}\n    }\n  `}(n,t):function ez(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!n.shapeInfo.isUniform&&i===l&&null==n.shapeInfo.flatOffset&&Qe(n.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const u=lt(l),c=S1(n.shapeInfo.logicalShape,t.logicalShape),d=l-i;let h;const p=["x","y","z","w","u","v"];h=0===i?"":l<2&&c.length>=1?"coords = 0;":c.map(g=>`coords.${p[g+d]} = 0;`).join("\n");let f="";return f=l<2&&i>0?"coords":n.shapeInfo.logicalShape.map((g,m)=>`coords.${p[m+d]}`).join(", "),`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${s}(${f});\n    }\n  `}(n,t)),r}(p,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),o=t.texShape,i=vn(),l=function S3(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(i);let u,c,d=function N3(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${k3}\n    ${_3}\n    ${$3}\n  `}(i);return t.isPacked?(u=function v3(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function A3(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===s[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `:1===s[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function V3(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(Qe(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;const r=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function R3(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),a=r*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function O3(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),a=r*Math.ceil(n[n.length-2]/2);let o=a,i="",l="b, r, c";for(let u=2;u<n.length-1;u++)o*=n[n.length-u-1],i=`\n      int b${u} = index / ${o};\n      index -= b${u} * ${o};\n    `+i,l=`b${u}, `+l;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${i}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${n.length}(${l});\n    }\n  `}(n,t,e)}}(t.logicalShape,o,e.enableShapeUniforms),c=function T3(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(i)):(u=function C3(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function D3(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function z3(n,t,e){return Qe(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function F3(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${Tc(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const s=sa(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function P3(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${Tc(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const s=sa(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function L3(n,t){const e=sa(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function M3(n,t){const e=sa(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,o,e.enableShapeUniforms),c=function I3(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(i)),e.packedInputs&&(d+=E3),[d,l,c,r,u,a,e.userCode].join("\n")}function Ha(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function W3(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,a]=n.shapeInfo.texShape;if(1===r&&1===a)return`\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=ra(e);if(t)return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[i,l]=n.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${i}, ${l}, ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function G3(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${s}(int index) {\n        ${ja(n)}\n      }\n    `;const r=n.shapeInfo.texShape,a=r[0],o=r[1];if(1===o&&1===a)return`\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=ra(e);return 1===o?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===a?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function j3(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape;if(null!=a&&Qe(e,a))return t?`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${a[0]}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const{newShape:o,keptDims:i}=Js(e);if(o.length<e.length){const p=["row","col"];return`\n      ${Ha(qa(n,o),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${Ka(p,i)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${ja(n)}\n      }\n    `;const u=a[0],c=a[1],d=ra(s);return 1===c?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:1===u?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(n,t);case 3:return function K3(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e[1]*e[2],o=e[2],{newShape:i,keptDims:l}=Js(e);if(i.length<e.length){const m=["row","col","depth"];return`\n        ${Ha(qa(n,i),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${Ka(m,l)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${o}, 1)));\n        ${ja(n)}\n      }\n    `;const c=n.shapeInfo.texShape,d=c[0],h=c[1],p=n.shapeInfo.flatOffset;if(h===a&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${o}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;if(h===o&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const f=ra(s);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${o} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(n,t);case 4:return function Z3(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e[3],o=e[2]*a,i=e[1]*o,{newShape:l,keptDims:u}=Js(e);if(l.length<e.length){const b=["row","col","depth","depth2"];return`\n      ${Ha(qa(n,l),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${Ka(b,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${i}, ${o}, ${a}, 1)));\n        ${ja(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===i&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${o}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;const y=ra(s);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${s}, uv);\n    }\n  `}(n,t);case 5:return function Y3(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],a=t[3]*r,o=t[2]*a,i=t[1]*o,{newShape:l,keptDims:u}=Js(t);if(l.length<t.length){const m=["row","col","depth","depth2","depth3"];return`\n      ${Ha(qa(n,l))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${Ka(m,u)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${i}, ${o}, ${a}, ${r})) +\n          depth3;\n        ${ja(n)}\n      }\n    `;const c=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1];if(p===i&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${o}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(p===r&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${i} + col * ${o} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${ra(e)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function J3(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:a}=Js(t);if(r.length<t.length){const y=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Ha(qa(n,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${Ka(y,a)});\n      }\n    `}const o=t[5],i=t[4]*o,l=t[3]*i,u=t[2]*l,c=t[1]*u;if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${i})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${o}, 1)));\n        ${ja(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${i}, ${o})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===o&&null==d)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${i} + depth3 * ${o} + depth4 + ${ra(e)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function I1(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function B3(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${vn().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function U3(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,a=vn();if(t)return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${o[0]}, ${o[1]}, index);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function H3(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,o=a[0],i=a[1],l=vn();if(null!=a&&Qe(e,a))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `}(n,t);case 3:return function q3(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===e[0]){const p=[1,2],g=["b","row","col"];return`\n        ${I1(qa(n,e.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${Ka(g,p)});\n        }\n      `}const i=vn();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${i.texture2D}(${s}, uv);\n    }\n  `;const l=o[0],u=o[1],c=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(e[1]/2)}, ${c}, b, row, col);\n      return ${i.texture2D}(${s}, uv);\n    }\n  `}(n,t);default:return function X3(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=vn();if(t)return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);\n    }\n  `;const a=n.shapeInfo.logicalShape,o=a.length,i=n.shapeInfo.texShape,l=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[o-1]/2);let h=d*Math.ceil(a[o-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let g=2;g<o-1;g++)p=`int b${g}, `+p,h*=a[o-g-1],f=`b${g} * ${h} + `+f;return`\n    vec4 ${s}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const k3="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_3="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$3="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",E3="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function ra(n){return`offset${n}`}function ja(n){const t=n.name,e=W(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function lt(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function qf(n,t,e){const{newShape:s,keptDims:r}=Js(t),a=t.length,o=n&&3===a&&1===t[0],i=o?t.slice(1):s,l=!n&&a>1&&!Qe(t,e)&&s.length<a||o;return{useSqueezeShape:l,uniformShape:l?i:t,keptDims:r}}function qa(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function Ka(n,t){return t.map(e=>n[e]).join(", ")}function N1(n,t,e){const s=[],r=[];let a,o,i,l=null,u=null;u=n.getUniformLocation(e,"NAN",!1),1===V().getNumber("WEBGL_VERSION")&&(l=n.getUniformLocation(e,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const h={name:d,uniform:n.getUniformLocation(e,d,c),offset:n.getUniformLocation(e,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=n.getUniformLocation(e,`${d}Shape`,c),h.texShape=n.getUniformLocation(e,`${d}TexShape`,c)),s.push(h)}if(t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",c),i=n.getUniformLocation(e,"outShapeStrides",c),o=n.getUniformLocation(e,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)r.push(n.getUniformLocation(e,d.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}}function k1(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,a=t[s],o=a.shape;if(!Qe(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(e.isUniform&&a.isUniform)return;const i=e.texShape,l=a.isUniform?null:a.texData.texShape;if(!Qe(i,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${l} must match`)})}function pn(n){return V().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class rz{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ba.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=vn();this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Tc(["r","c","d"],t):sa(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class az{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ba.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=vn();this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?Tc(["r","c","d"],t):sa(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class oz{constructor(t){this.variableNames=["A"],this.outTexUsage=Rn.DOWNLOAD;const e=vn();this.outputShape=t,this.userCode=`\n      ${C1}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class iz{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Rn.DOWNLOAD;const e=vn();this.outputShape=t,this.userCode=`\n      ${C1}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const lz={R:0,G:1,B:2,A:3};class _1{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=vn();this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length);let a="result";e&&(a="floor(result * 255. + 0.5)");let o="";for(let i=0;i<s.length;i++)o+=`\n          if(offset == ${i}) {\n            result = values[${lz[s[i]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Hf(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${s.length});\n\n        flatIndex = idiv(flatIndex, ${s.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${o}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class uz{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=vn();this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length);let r="",a="result";e&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const l=2*o+i;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${i};\n          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${o};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${s.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${l}] = values[0];\n            } else if (offset == 1) {\n              result[${l}] = values[1];\n            } else if (offset == 2) {\n              result[${l}] = values[2];\n            } else {\n              result[${l}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Hf(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${s.output} = ${a};\n        }\n    `}}function Mi(n,t,e,s,r,a){!function n3(n,t){const e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const o=function t3(n){return Ks(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),i=n.TEXTURE_2D;return ce(n,()=>n.bindTexture(i,o)),ce(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ce(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),ce(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===V().getNumber("WEBGL_VERSION")?ce(n,()=>n.texImage2D(i,0,s,t,e,0,r,a,null)):ce(n,()=>n.texStorage2D(i,1,s,t,e)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function $1(n){return n.internalFormatFloat}function E1(n){return n.internalFormatHalfFloat}function A1(n){return n.downloadTextureFormat}function D1(n){return n.internalFormatPackedFloat}function R1(n){return n.internalFormatPackedHalfFloat}class Kf{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=V().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function MV(n,t){wr[n]=t}(e,t)):this.gl=ps(e),t=this.gl,2===V().getNumber("WEBGL_VERSION")){const a=t;this.createVertexArray=()=>ce(a,()=>a.createVertexArray()),this.bindVertexArray=o=>ce(a,()=>a.bindVertexArray(o)),this.deleteVertexArray=o=>ce(a,()=>a.deleteVertexArray(o)),this.getVertexArray=()=>ce(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(null!=t){const a=t.getExtension("OES_vertex_array_object");if(null==a)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>ce(t,()=>a.createVertexArrayOES()),this.bindVertexArray=o=>ce(t,()=>a.bindVertexArrayOES(o)),this.deleteVertexArray=o=>ce(t,()=>a.deleteVertexArrayOES(o)),this.getVertexArray=()=>ce(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===V().getNumber("WEBGL_VERSION")){const o="OES_texture_half_float";if(this.textureFloatExtension=xc(this.gl,"OES_texture_float"),ns(this.gl,o))this.textureHalfFloatExtension=xc(this.gl,o);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ns(this.gl,r))this.colorBufferHalfFloatExtension=xc(this.gl,r);else if(V().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ns(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else{if(!ns(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function dz(n){return function QV(n,t){const e=Ks(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),ce(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function hz(n){return function e3(n,t){const e=Ks(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ce(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),ce(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function s3(n){return Ks(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Bf(this.gl,this.textureHalfFloatExtension)}get debug(){return V().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;ce(t,()=>t.finish()),ce(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ce(t,()=>t.deleteFramebuffer(this.framebuffer)),ce(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ce(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ce(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function pz(n,t,e,s){const[r,a]=Pi(t,e);return Mi(n,r,a,$1(s),s.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function fz(n,t,e,s){const[r,a]=Pi(t,e);return Mi(n,r,a,E1(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function mz(n,t,e,s){const[r,a]=Pi(t,e);return Mi(n,r,a,A1(s),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function wz(n,t,e){ce(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===V().getNumber("WEBGL_VERSION")?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===V().getNumber("WEBGL_VERSION")?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),function bz(n,t,e,s,r,a){let o,i,l;ce(n,()=>n.bindTexture(n.TEXTURE_2D,t)),r instanceof Uint8Array?(o=new Uint8Array(e*s*4),i=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(e*s*4),i=n.FLOAT,l=a.internalFormatPackedFloat),o.set(r),2===V().getNumber("WEBGL_VERSION")?ce(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,i,o)):ce(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,e,s,0,n.RGBA,i,o)),ce(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function yz(n,t,e,s){const[r,a]=Wa(t,e);return Mi(n,r,a,R1(s),n.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function gz(n,t,e,s){const[r,a]=Wa(t,e);return Mi(n,r,a,D1(s),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(b1(this.gl,this.framebuffer),this.outputTexture=null),ce(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function Sz(n,t,e,s){const[r,a]=Pi(t,e),i=new Uint8Array(function BV(n,t){return n*t}(t*e,4));return ce(n,()=>n.readPixels(0,0,r,a,s.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,a,o){return function Iz(n,t,e,s,r,a,o,i){const l=n,u=new Float32Array(function WV(n,t){const[e,s]=Wa(n,t);return e*s*4}(a,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}(this.gl,t,0,0,0,a,o)}downloadFloat32MatrixFromBuffer(t,e){return function Cz(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=function vz(n,t,e,s){const r=n.createBuffer();ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const i=16*t*e;return ce(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),ce(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),ce(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,s);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if(V().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const o=r.clientWaitSync(a,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},e=a}else V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function Tz(n,t,e){const s=new Float32Array(t*e*4);return ce(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function cz(n){const t=vn();return function KV(n,t){const e=Ks(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ce(n,()=>n.shaderSource(e,t)),ce(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const s=function YV(n){return Ks(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);ce(e,()=>e.attachShader(s,this.vertexShader)),ce(e,()=>e.attachShader(s,t)),function JV(n,t){if(ce(n,()=>n.linkProgram(t)),!V().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Wf(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;ce(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function xz(n,t,e){ce(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),x1(n,t,"clipSpacePos",e,3,20,0)&&x1(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(ce(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Wf(this.gl,this.program),ce(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?function a3(n,t,e){return Ks(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function o3(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ce(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),i3(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,a]=Wa(e,s);this.setOutputMatrixTextureDriver(t,r,a)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Wf(this.gl,this.program),bc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}ce(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ce(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=xc(this.gl,2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();return void e.endQuery(s.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return Z(function*(){return yield dm(()=>e.disposed||e.isQueryAvailable(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function Nz(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in V().platform&&(s=V().platform.setTimeoutCustom.bind(V().platform)),dm(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Uf(this.gl,t,this.framebuffer),this.debug&&bc(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Uf(this.gl,this.outputTexture,this.framebuffer),this.debug&&bc(this.gl)):b1(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;Uf(r,t,this.framebuffer),this.debug&&bc(r),this.outputTexture=t,ce(r,()=>r.viewport(0,0,e,s)),ce(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),ce(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:kz,bincountImpl:F1,bincountReduceImpl:_z,bitwiseAndImpl:$z,castImpl:Ez,ceilImpl:Az,concatImpl:Dz,equalImpl:Rz,expImpl:Fz,expm1Impl:Oz,floorImpl:Pz,gatherNdImpl:Lz,gatherV2Impl:Mz,greaterImpl:Vz,greaterEqualImpl:zz,lessImpl:Bz,lessEqualImpl:Wz,linSpaceImpl:Uz,logImpl:Gz,maxImpl:Hz,maximumImpl:jz,minimumImpl:qz,multiplyImpl:Kz,negImpl:Xz,notEqualImpl:Zz,prodImpl:Yz,raggedGatherImpl:Jz,raggedRangeImpl:Qz,raggedTensorToTensorImpl:eB,rangeImpl:tB,rsqrtImpl:nB,scatterImpl:sB,sigmoidImpl:rB,simpleAbsImpl:O1,sliceImpl:aB,sparseFillEmptyRowsImpl:oB,sparseReshapeImpl:iB,sparseSegmentReductionImpl:P1,sqrtImpl:lB,staticRegexReplaceImpl:uB,stridedSliceImpl:cB,stringNGramsImpl:dB,stringSplitImpl:hB,stringToHashBucketFastImpl:pB,subImpl:fB,tileImpl:mB,topKImpl:gB,transposeImpl:Xf,uniqueImpl:yB}=yt;function L1(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Cn(n,t){return 1===t?[n]:L1(n,t)}class bB{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=pn(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Cn("rc",this.rank),s=lt(this.rank),r=this.getOutOfBoundsCondition(e),a=this.getSetup(e),o=this.getOutput(e);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${o}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let o=2;o<this.rank;o++)a=`${t[t.length-1-o]},`+a;e.push(a)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class M1{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`\n        ${a}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function wB(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function x3(n,t,e="index"){const r=function y3(n,t){const e=n.length,s=n.map(a=>`${t}[${a}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let a=e-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}(n.map((a,o)=>o),t);return r.map((a,o)=>`int ${n[o]} = ${e} / ${r[o]}; ${o===r.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`};`).join("")}(["r","c","d"],"inputShape"):sa(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Hf(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${s}\n\n        setOutput(result);\n      }\n    `}}class vB{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=z1(e,s),a=B1(t,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=V1(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let i;return r===Jt.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===Jt.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===Jt.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===Jt.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===Jt.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(t,e,s,r){if(null==this.freeTextures)return;const a=z1(s,r),o=B1(e,a,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=V1(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=V().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==l&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const u=this.usedTextures[o],c=u&&u.indexOf(t);if(null==c||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function V1(n,t,e,s,r){const a=function SB(n,t){switch(n){case Jt.PACKED_2X2_FLOAT32:return D1(t);case Jt.PACKED_2X2_FLOAT16:return R1(t);case Jt.UNPACKED_FLOAT32:return $1(t);case Jt.UNPACKED_FLOAT16:return E1(t);case Jt.PACKED_4X1_UNSIGNED_BYTE:return A1(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,s);let o;if(r){const[l,u]=Wa(n[0],n[1]);o=l*u}else{const[l,u]=Pi(n[0],n[1]);o=l*u}const i=function CB(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,a);return o*i}function z1(n,t){if(n===Rn.UPLOAD)return Jt.PACKED_2X2_FLOAT32;if(n===Rn.RENDER||null==n)return function IB(n){return V().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Jt.PACKED_2X2_FLOAT32:Jt.UNPACKED_FLOAT32:n?Jt.PACKED_2X2_FLOAT16:Jt.UNPACKED_FLOAT16}(t);if(n===Rn.DOWNLOAD||n===Rn.PIXELS)return Jt.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function B1(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class As{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const W1="return abs(x);",vr="return x;";class Cr{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class OB{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length);const e=t.length,s=Cn("rc",e),r=lt(e),a=function xB(n,t){if(1===n)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}(e,s),o=s.slice(-2),i=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const PB=Uy,kc={},zB=V().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let UB=(()=>{class n extends Mc{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!V().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let s;if(null!=e){if(e instanceof Kf)s=e;else{const r=ps(V().getNumber("WEBGL_VERSION"),e);s=new Kf(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=ps(V().getNumber("WEBGL_VERSION"));s=new Kf(r),this.binaryCache=function VB(n){return n in kc||(kc[n]={}),kc[n]}(V().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=s,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new vB(this.gpgpu),this.numMBBeforeWarning=function WB(){return null==V().global.screen?1024:V().global.screen.height*V().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new lm(this,xs())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,s,r,a,o,i){const l=this.makeTensorInfo(s,r),u=this.texData.get(l.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[a,o]},u.texShape=[a,o];const c=wc(s),d=new _1(c,!1,i),h=this.runWebGLProgram(d,[l],r,[[a,o]]);return h.shape=s,u.texture=null,this.disposeIntermediateTensorInfo(l),h.dataId}write(e,s,r){if((V().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||V().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:s,dtype:r,values:e,usage:Rn.UPLOAD,refCount:1}),a}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,s,r,a,o){if(V().getBool("DEBUG")&&this.checkNumericalProblems(s),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:a,values:s,usage:Rn.UPLOAD,refCount:o})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const s=this.texData.get(e),{values:r,dtype:a,complexTensorInfos:o,slice:i,shape:l,isPacked:u}=s;if(null!=i){let p;p=u?new Cr(l,vr):new As(l,vr);const f=this.runWebGLProgram(p,[{dataId:e,shape:l,dtype:a}],a),g=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),g}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===a)return r;const c=null!=this.activeTimers;let d,h;return c&&(d=In()),h="complex64"===a?Gs(this.readSync(o.real.dataId),this.readSync(o.imag.dataId)):this.getValuesFromTexture(e),c&&(this.downloadWaitMs+=In()-d),this.convertAndCacheOnCPU(e,h)}read(e){var s=this;return Z(function*(){if(s.pendingRead.has(e)){const m=s.pendingRead.get(e);return new Promise(y=>m.push(y))}const r=s.texData.get(e),{values:a,shape:o,slice:i,dtype:l,complexTensorInfos:u,isPacked:c}=r;if(null!=i){let m;m=c?new Cr(o,vr):new As(o,vr);const y=s.runWebGLProgram(m,[{dataId:e,shape:o,dtype:l}],l),x=s.read(y.dataId);return s.disposeIntermediateTensorInfo(y),x}if(null!=a)return s.convertAndCacheOnCPU(e);if(V().getBool("DEBUG")&&!V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===V().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,p,d=null;if("complex64"!==l&&V().get("WEBGL_BUFFER_SUPPORTED")){h=s.decode(e);const m=s.texData.get(h.dataId);d=s.gpgpu.createBufferFromTexture(m.texture.texture,...yc(o))}if(s.pendingRead.set(e,[]),"complex64"!==l&&(yield s.gpgpu.createAndWaitForFence()),"complex64"===l){const m=yield Promise.all([s.read(u.real.dataId),s.read(u.imag.dataId)]);p=Gs(m[0],m[1])}else if(null==d)p=s.getValuesFromTexture(e);else{const m=W(o);p=s.gpgpu.downloadFloat32MatrixFromBuffer(d,m)}if(null!=h&&s.disposeIntermediateTensorInfo(h),null!=d){const m=s.gpgpu.gl;ce(m,()=>m.deleteBuffer(d))}const f=s.convertAndCacheOnCPU(e,p),g=s.pendingRead.get(e);return s.pendingRead.delete(e),g.forEach(m=>m(f)),s.pendingDisposal.has(e)&&(s.pendingDisposal.delete(e),s.disposeData(e)&&xs().removeDataId(e,s),s.pendingDeletes--),f})()}readToGPU(e,s={}){const r=this.texData.get(e),{values:a,shape:o,slice:i,dtype:l,isPacked:u,texture:c}=r;if("complex64"===l)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let f;f=u?new Cr(o,vr):new As(o,vr);const g=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:l}],l),m=this.readToGPU(g,s);return this.disposeIntermediateTensorInfo(g),m}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const d=this.decode(e,s.customTexShape),h=xs().makeTensorFromTensorInfo(d),p=this.texData.get(d.dataId);return Object.assign({tensorRef:h},p.texture)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(a=>nr(a));return Be(e.shape,e.dtype,r)}catch(r){throw new Error("Failed to decode encoded string bytes into utf-8")}return Be(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let s=0;s<e.length;s++){const r=e[s];if(!jV(r))throw V().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:s,dtype:r,isPacked:a}=this.texData.get(e),o=W(s);if(V().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),f=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...yc(s)).subarray(0,o);return this.disposeIntermediateTensorInfo(p),g}const i=V().getBool("WEBGL_PACK")&&!0===a,l=i?wc(s):s,u=i?new iz(l):new oz(l),c=this.runWebGLProgram(u,[{shape:l,dtype:r,dataId:e}],"float32"),d=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(d.texture.texture,d.texShape[0],d.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var s=this;const r=this.activeTimers,a=[];let o=!1;null==this.programTimersStack?(this.programTimersStack=a,o=!0):this.activeTimers.push(a),this.activeTimers=a,e();const i=Rr(this.activeTimers.map(c=>c.query)).filter(c=>null!=c),l=Rr(this.activeTimers.map(c=>c.name)).filter(c=>null!=c);this.activeTimers=r,o&&(this.programTimersStack=null);const u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return Z(function*(){if(V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=yield Promise.all(i);u.kernelMs=function Zv(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}(c),u.getExtraProfileInfo=()=>c.map((d,h)=>({name:l[h],ms:d})).map(d=>`${d.name}: ${d.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return s.uploadWaitMs=0,s.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:In(),endMs:null}}endTimer(e){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=In(),e)}getQueryTime(e){var s=this;return Z(function*(){return V().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?s.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,s=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(s?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!s&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return null!=r&&(this.disposeData(r.real.dataId,s),this.disposeData(r.imag.dataId,s)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:s,dtype:r,texShape:a,usage:o,isPacked:i,slice:l}=this.texData.get(e),u=l&&l.origDataId||e,c=this.dataRefCount.get(u);c>1?this.dataRefCount.set(u,c-1):(this.dataRefCount.delete(u),null!=s&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(s,a,o,i)));const d=this.texData.get(e);d.texture=null,d.texShape=null,d.isPacked=!1,d.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,s=zB){return V().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>null==this.texData.get(r.dataId).texture&&W(r.shape)<s)}getGPGPUContext(){return this.gpgpu}where(e){On("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const s=e.dataSync();return PB(e.shape,s)}packedUnaryOp(e,s,r){const a=new Cr(e.shape,s),o=this.compileAndRun(a,[e],r);return xs().makeTensorFromTensorInfo(o)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const a=O1(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,a)}if(V().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,W1,e.dtype);const s=new As(e.shape,W1),r=this.compileAndRun(s,[e]);return xs().makeTensorFromTensorInfo(r)}makeTensorInfo(e,s,r){let a;if("string"===s&&null!=r&&r.length>0&&eo(r[0])){const o=r.map(i=>tr(i));a=this.write(o,e,s)}else a=this.write(r,e,s);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:s}}makeOutput(e,s,r){return xs().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,r),this)}unpackTensor(e){const s=new OB(e.shape);return this.runWebGLProgram(s,[e],e.dtype)}packTensor(e){const s=new bB(e.shape);return this.runWebGLProgram(s,[e],e.dtype,null,!0)}packedReshape(e,s){const r=[Ua(e.shape),...Ga(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},o=[Ua(s),...Ga(s)],i=new M1(o,r),c=this.runWebGLProgram(i,[a],e.dtype,[r],!0);return{dataId:c.dataId,shape:s,dtype:c.dtype}}decode(e,s){const r=this.texData.get(e),{isPacked:a,shape:o,dtype:i}=r;null!=s&&I(W(o)<=s[0]*s[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const l=wc(o);let u;u=a?new az(l):new rz(l);const d=[null!=s?s:yc(l)];return{dtype:i,shape:o,dataId:this.runWebGLProgram(u,[{shape:l,dtype:i,dataId:e}],i,d,!0,s).dataId}}runWebGLProgram(e,s,r,a,o=!1,i){const l=this.makeTensorInfo(e.outputShape,r),u=this.texData.get(l.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===Ba.DENSE){const x=null!=i?i:yc(e.outputShape);u.texShape=x.map(b=>2*b)}if(null!=e.outTexUsage&&(u.usage=e.outTexUsage),0===W(l.shape))return u.values=ln(l.dtype,0),l;const c=[],d=s.map(x=>{if("complex64"===x.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(x.dataId);if(null==b.texture){if(!e.packedInputs&&W(x.shape)<=V().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:x.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=x.shape)}if(this.uploadToGPU(x.dataId),!!b.isPacked!=!!e.packedInputs)x=b.isPacked?this.unpackTensor(x):this.packTensor(x),c.push(x),b=this.texData.get(x.dataId);else if(b.isPacked&&!Cc(b.shape,x.shape)){const w=x,C=x.shape;x.shape=b.shape,x=this.packedReshape(x,C),c.push(x),b=this.texData.get(x.dataId),w.shape=C}return{shape:x.shape,texData:b,isUniform:!1}});this.uploadToGPU(l.dataId);const h={shape:l.shape,texData:u,isUniform:!1},p=function sz(n,t,e){let s="";t.concat(e).forEach(o=>{const i=null!=o.texData&&null!=o.texData.slice&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=qf(n.packedInputs,o.shape,l);let h="",p="",f="";if(1===c.length&&n.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${C[0]>1}_${C[1]>1}`}else if(2!==c.length||n.packedInputs){if(c.length>2&&!n.packedInputs){const C=Ie(c);f=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}}else p=`${c[0]>1}_${c[1]>1}`;const g=o.shape.length,m=2===c.length&&Qe(o.shape,l),y=1===W(o.shape),x=Ia(o.shape,e.shape),b=!n.packedInputs&&g===e.shape.length&&Qe(l,e.texData.texShape);s+=`${g}_${b}_${u?d:""}_${c.length}_${y}_${x}_${m}_${h}_${p}_${f}_${n.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`}_${i}`}else s+=`${o.shape}_${o.isUniform?"uniform":o.texData.texShape}_${i}`});let a=n.constructor.name;return a+="_"+s+"_"+n.userCode+`${V().getNumber("WEBGL_VERSION")}`,a}(e,d,h),f=this.getAndSaveBinary(p,()=>function tz(n,t,e,s){const r=e.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:!c.isUniform&&c.texData.isPacked,flatOffset:null};return null!=c.texData&&null!=c.texData.slice&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=r.map(c=>c.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},i=b3(r,o,t),l=function XV(n,t){const e=Ks(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ce(n,()=>n.shaderSource(e,t)),ce(n,()=>n.compileShader(e)),V().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw y1(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,i),u=n.createProgram(l);return V().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:a,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(u),Object.assign({program:t,fragmentShader:l,source:i,webGLProgram:u,inShapeInfos:a,outShapeInfo:o},N1(n,t,u)))}(this.gpgpu,e,d,h)),g=null!=this.activeTimers;let m;g&&(m=this.startTimer()),V().get("ENGINE_COMPILE_ONLY")||function nz(n,t,e,s,r){t.program.enableShapeUniforms||(k1(t.inShapeInfos,e),k1([t.outShapeInfo],[s]));const a=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(a.texture,o[0],o[1]):n.setOutputMatrixTexture(a.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===V().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<e.length;++l){const u=e[l],{uniform:c,offset:d,shape:h,texShape:p}=t.variablesLocations[l];if(h){const{uniformShape:f}=qf(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:n.gl.uniform1iv(h,new Int32Array(f));break;case 2:n.gl.uniform2iv(h,new Int32Array(f));break;case 3:n.gl.uniform3iv(h,new Int32Array(f));break;case 4:n.gl.uniform4iv(h,new Int32Array(f))}}if(p&&n.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),null!=c){if(u.isUniform){if(W(u.shape)<2)n.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),n.gl.uniform1fv(c,f)}continue}null!=u.texData.slice&&null!=d&&n.gl.uniform1i(d,u.texData.slice.flatOffset),n.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const i=t.outShapeLocation;if(i)switch(s.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(s.shape))}if(t.outShapeStridesLocation){const l=Ie(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=r[l];if("float"===u.type)n.gl.uniform1fv(c,d);else if("vec2"===u.type)n.gl.uniform2fv(c,d);else if("vec3"===u.type)n.gl.uniform3fv(c,d);else if("vec4"===u.type)n.gl.uniform4fv(c,d);else if("int"===u.type)n.gl.uniform1iv(c,d);else if("ivec2"===u.type)n.gl.uniform2iv(c,d);else if("ivec3"===u.type)n.gl.uniform3iv(c,d);else{if("ivec4"!==u.type)throw Error(`uniform type ${u.type} is not supported yet.`);n.gl.uniform4iv(c,d)}}n.executeProgram()}(this.gpgpu,f,d,h,a),c.forEach(x=>this.disposeIntermediateTensorInfo(x)),g&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)}));const y=V().getNumber("WEBGL_FLUSH_THRESHOLD");if(y>0){const x=In();x-this.lastGlFlushTime>y&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=x)}if(!V().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&!1===o){const x=this.unpackTensor(l);return this.disposeIntermediateTensorInfo(l),x}return l}compileAndRun(e,s,r,a,o=!1){return this.runWebGLProgram(e,s,r=r||s[0].dtype,a,o)}getAndSaveBinary(e,s){return e in this.binaryCache||(this.binaryCache[e]=s()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(V().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(s=>{this.gpgpu.deleteProgram(this.binaryCache[s].webGLProgram),delete this.binaryCache[s]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=L(()=>{if(!V().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=V().getBool("DEBUG");V().set("DEBUG",!1);const s=this.abs(Re(1e-8)).dataSync()[0];if(V().set("DEBUG",e),s>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const s=this.texData.get(e),{shape:r,dtype:a,values:o,texture:i,usage:l,isPacked:u}=s;if(null!=i)return;const c=null!=this.activeTimers;let d;c&&(d=In());let h=s.texShape;if(null==h&&(h=function u3(n,t=!1){let e=V().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=V().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&V().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e*=2,s*=2,1===(n=n.map((i,l)=>l>=n.length-2?Vc(n[l]):n[l])).length&&(n=[2,n[0]])),2!==n.length&&(n=Js(n).newShape);let r=W(n),a=null;n.length<=1&&r<=e?a=[1,r]:2===n.length&&n[0]<=e&&n[1]<=e?a=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?a=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?a=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?a=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(a=[n[0],n[1]*n[2]*n[3]]);const o=null!=a&&Math.max(...a)>s&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||o)if(t){const i=Ua(n);let l=2,u=2;n.length&&([l,u]=Ga(n)),r=i*(l/2)*(u/2),a=zc(r).map(c=>2*c)}else a=zc(r);return a}(r,u),s.texShape=h),null!=o){const p=wc(r);let f,g=h[1],m=h[0];const y=o instanceof Uint8Array||o instanceof Uint8ClampedArray;(u||!y)&&([g,m]=Wa(h[0],h[1])),f=u?new uz(p,y):new _1(p,y);const x=y?[m,g]:h,b=this.makeTensorInfo(x,a),w=this.texData.get(b.dataId);w.usage=y?Rn.PIXELS:Rn.UPLOAD,w.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),g,m,o);const T=this.runWebGLProgram(f,[b],a,[[m,g]],!0),k=this.texData.get(T.dataId);s.texShape=k.texShape,s.isPacked=k.isPacked,s.usage=k.usage,V().get("ENGINE_COMPILE_ONLY")?this.disposeData(T.dataId):(s.texture=k.texture,s.values=null,this.texData.delete(T.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=In()-d)}else{const p=this.acquireTexture(h,l,a,u);s.texture=p}}convertAndCacheOnCPU(e,s){const r=this.texData.get(e),{dtype:a}=r;return null!=s&&(r.values=function GB(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}throw new Error(`Unknown dtype ${t}`)}(s,a)),r.values}acquireTexture(e,s,r,a){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,s,a)}computeBytes(e,s){return e[0]*e[1]*Hi(s)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return Z(function*(){const s=[];if(e.gpgpu.parallelCompilationExtension){for(const[,r]of Object.entries(e.binaryCache))s.push(e.checkCompletionAsync_(r));return Promise.all(s)}for(const[,r]of Object.entries(e.binaryCache)){const a=new Promise(o=>{try{e.checkCompletion_(r),o(!0)}catch(i){throw i}});s.push(a)}return Promise.all(s)})()}checkCompletionAsync_(e){var s=this;return Z(function*(){return s.gpgpu.gl.getProgramParameter(e.webGLProgram,s.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?s.checkCompletion_(e):(yield my(),s.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(y1(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:s,customUniformLocations:r,infLoc:a,nanLoc:o,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}=N1(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=s,e.customUniformLocations=r,e.infLoc=a,e.nanLoc=o,e.outShapeLocation=i,e.outShapeStridesLocation=l,e.outTexShapeLocation=u}}createTensorFromGPUData(e,s,r){e.channels=e.channels||"RGBA";const{texture:a,height:o,width:i,channels:l}=e,u=xs().backend;if(!u.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=u.writeTexture(a,s,r,o,i,l);return xs().makeTensorFromDataId(c,s,r,u)}}return n.nextDataId=0,n})();Xm()&&Qm("webgl",()=>new UB,2);class aa{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=Oe(e,s),this.enableShapeUniforms=pn(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const oa="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class Xa{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Oe(e,s);const a=this.outputShape.length;this.enableShapeUniforms=pn(a);let o="";if(r)if(0===a||1===W(this.outputShape))o="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(o=`\n          ${lt(a)} coords = getOutputCoords();\n        `,1===a)o+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const l=Cn("coords",a);o+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${l[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${l[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${o}\n\n        setOutput(result);\n      }\n    `}}function Fn(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const qB={kernelName:So,backendName:"webgl",kernelFunc:Fn};function Sr(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,a=e.makeTensorInfo(s.shape,"complex64"),o=e.texData.get(a.dataId),i=Fn({inputs:{x:s},backend:e}),l=Fn({inputs:{x:r},backend:e});return o.complexTensorInfos={real:i,imag:l},a}const KB={kernelName:td,backendName:"webgl",kernelFunc:Sr},U1="return (a < 0.) ? b * a : a;",G1="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",ZB={kernelName:hl,backendName:"webgl",kernelFunc:function XB(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:a}=s,o=e.makeTensorInfo([],"float32",er(a,"float32")),i=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Xa(G1,r.shape,o.shape):new aa(U1,r.shape,o.shape),l=e.runWebGLProgram(i,[r,o],"float32");return e.disposeIntermediateTensorInfo(o),l}},H1="return (a < 0.) ? b * a : a;",j1="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",JB={kernelName:Al,backendName:"webgl",kernelFunc:function YB(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Xa(j1,s.shape,r.shape):new aa(H1,s.shape,r.shape);return e.runWebGLProgram(a,[s,r],"float32")}};function Ke({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:a})=>{const{x:o}=r,i=a,l=s||o.dtype;if(i.shouldExecuteOnCPU([o])&&null!=e){const d=i.texData.get(o.dataId),h=e(d.values,l);return i.makeTensorInfo(o.shape,l,h)}let c;return c=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new Cr(o.shape,t):new As(o.shape,n),i.runWebGLProgram(c,[o],l)}}function rn({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:o,backend:i})=>{const{a:l,b:u}=o,c=i;if(s&&"complex64"===l.dtype){const f=c.texData.get(l.dataId),g=c.texData.get(u.dataId),[m,y]=[[f.complexTensorInfos.real,g.complexTensorInfos.real],[f.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(b=>{const[w,C]=b,S={dataId:w.dataId,dtype:w.dtype,shape:l.shape},T={dataId:C.dataId,dtype:C.dtype,shape:u.shape},k=new aa(n,l.shape,u.shape);return c.runWebGLProgram(k,[S,T],An(w.dtype,C.dtype))}),x=Sr({inputs:{real:m,imag:y},backend:c});return c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(y),x}const d=a||An(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=r){const f=c.texData.get(l.dataId).values,g=c.texData.get(u.dataId).values,m="string"===l.dtype?Hs(f):f,y="string"===l.dtype?Hs(g):g,[x,b]=r(l.shape,u.shape,m,y,d),w=c.makeTensorInfo(b,d);return c.texData.get(w.dataId).values=x,w}let p;return p=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new Xa(t,l.shape,u.shape,e):new aa(n,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function Vi(n,t=!1){if("linear"===n)return"return x;";if("relu"===n)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n";if("elu"===n)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===n)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";if("prelu"===n)return t?j1:H1;if("leakyrelu"===n)return t?G1:U1;if("sigmoid"===n)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class q1{constructor(t,e,s,r=!1,a=!1,o=!1,i=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=pn(this.outputShape.length);const d=Math.ceil((r?t[1]:t[2])/2),h=r?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",y="";i&&(m=l?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:u?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,y="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";t[0]<e[0]?b=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(w=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${d}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${w};\n        for (int i = 0; i < ${d}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${p});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${f[0]} * ${g[0]});\n          result += (${f[1]} * ${g[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${x}\n\n        ${y}\n\n        setOutput(result);\n      }\n    `}}class X1{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Oe(e,s),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const Z1="return a * b;";function Yf(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,a=An(s.dtype,r.dtype);if("complex64"===s.dtype){const i=e.texData.get(s.dataId),l=e.texData.get(r.dataId),u=new X1("return areal * breal - aimag * bimag;",s.shape,r.shape),c=new X1("return areal * bimag + aimag * breal;",s.shape,r.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=Sr({inputs:{real:h,imag:p},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}if(e.shouldExecuteOnCPU([s,r])){const i=e.texData.get(s.dataId),l=e.texData.get(r.dataId),[u,c]=Kz(s.shape,r.shape,i.values,l.values,a),d=e.makeTensorInfo(c,a);return e.texData.get(d.dataId).values=u,d}let o;return o=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Xa(Z1,s.shape,r.shape):new aa(Z1,s.shape,r.shape),e.runWebGLProgram(o,[s,r],a)}const QB={kernelName:Do,backendName:"webgl",kernelFunc:Yf};function ue(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:a}=s,o=e,i=W(r.shape),l=hm(a,i),u=W(l);I(i===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const c=o.texData.get(r.dataId);return!c.isPacked||Cc(r.shape,l)||null!==c.texture&&Cc(c.shape,l)?(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function eW(n,t,e){const s=[Ua(n.shape),...Ga(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},a=[Ua(t),...Ga(t)],o=new M1(a,s),u=e.runWebGLProgram(o,[r],n.dtype,[s],!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(r,l,o)}const tW={kernelName:Rl,backendName:"webgl",kernelFunc:ue};class Y1{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:o}=t;this.outputShape=[r,o];const i=4*Math.floor(s/4),l=s%4;let u="sumValue += dot(values, ones);";if(null!=e){const d=1/e;u=`sumValue += dot(values * ${da(d)?d.toPrecision(2):d}, ones);`}let c="";a%s>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===l}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}class nW{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:o}=t;this.outputShape=[r,o];let i="0.0",l="";"prod"===e?i="1.0":"min"===e?(i="1.0 / 1e-20",l="min"):"max"===e&&(i="-1.0 / 1e-20",l="max");let u=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?u="sumValue":"prod"===e?u="prodValue":"all"===e?u="allValue":"any"===e&&(u="anyValue");const c=4*Math.floor(s/4),d=s%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${l}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${l}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,p="vec4";"all"===e?(i="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",p="bvec4"):"any"===e&&(i="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",p="bvec4");let f="";a%s>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          ${p} values = ${p}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${u});\n      }\n    `}}function ia(n,t,e,s){const r=function sW(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],s=Nu(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}(n.shape);let a=n;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:l,outSize:u}=r[o];let c,d;c="mean"===e?0===o?new Y1({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u},i):new Y1({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u}):new nW({windowSize:l,inSize:i,batchSize:n.shape[0],outSize:u},e),d=a,a=s.runWebGLProgram(c,[a],t),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return a}class rW{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[e[o]];this.outputShape=s,this.rank=s.length;const r=lt(this.rank),a=function aW(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class oW{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let c=0;c<s.length;c++)s[c]=t[e[c]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=lt(this.rank),a=L1("rc",this.rank),o=new Array(this.rank);for(let c=0;c<e.length;c++)o[e[c]]=a[c];const i=`vec2(${o.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${s[this.rank-1]}`,u=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${u};\n      if(${l}) {\n        result[1] = ${u};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {\n        result[2] = ${u};\n        if(${l}) {\n          result[3] = ${u};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function _c(n,t,e){const s=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oW(n.shape,t):new rW(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function $c(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s;return function iW(n,t,e,s){const a=n.shape.length,o=ze(t,n.shape);let i=o;const l=St(i,a),u=null!=l;let c=n;u&&(c=_c(n,l,s),i=At(i.length,a)),sn("sum",i,a);const[d,h]=Xt(c.shape,i);let p=d;e&&(p=Et(d,o));const f=W(h),y=ue({inputs:{x:c},attrs:{shape:[W(n.shape)/f,f]},backend:s}),b=ia(y,Kd(n.dtype),"sum",s),w=ue({inputs:{x:b},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(b),u&&s.disposeIntermediateTensorInfo(c),w}(r,a,o,e)}const lW={kernelName:Vl,backendName:"webgl",kernelFunc:$c};function Sn(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:a}=s,o=e,l=new Array(r.shape.length);for(let c=0;c<l.length;c++)l[c]=r.shape[a[c]];let u;if(o.shouldExecuteOnCPU([r])){const d=o.texData.get(r.dataId).values,h=Xf(d,r.shape,r.dtype,a,l);u=o.makeTensorInfo(l,r.dtype),o.texData.get(u.dataId).values=h}else u=_c(r,a,o);return u}const uW={kernelName:ga,backendName:"webgl",kernelFunc:Sn};function Ec({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:l=null}){const u=n.shape.length,c=t.shape.length,d=e?n.shape[u-2]:n.shape[u-1],h=s?t.shape[c-1]:t.shape[c-2],p=e?n.shape[u-1]:n.shape[u-2],f=s?t.shape[c-2]:t.shape[c-1],g=n.shape.slice(0,-2),m=t.shape.slice(0,-2),y=W(g),x=W(m),w=Oe(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);I(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const C=e?[y,d,p]:[y,p,d],S=s?[x,f,h]:[x,h,f],T=ue({inputs:{x:n},backend:r,attrs:{shape:C}}),k=ue({inputs:{x:t},backend:r,attrs:{shape:S}}),$=[T,k],E=Math.max(y,x),P=e?T.shape[1]:T.shape[2],z=null!=a,B=null!=o,U="leakyrelu"===l,G=null!=l?Vi(l,!0):null;let K;if((1===p||1===f)&&P>1e3&&!1===(z||B||U||null!=G)){let X=T,ne=k;e&&(X=Sn({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),$.push(X)),s&&(ne=Sn({inputs:{x:k},backend:r,attrs:{perm:[0,2,1]}}),$.push(ne));const ie=1===f;let oe=X;1!==f&&(oe=ue({inputs:{x:X},backend:r,attrs:{shape:[E,P,1]}}),$.push(oe));const pe=1===f?2:1;let le=ne;ie&&(le=ue({inputs:{x:ne},backend:r,attrs:{shape:[E,1,P]}}),$.push(le));const me=Yf({inputs:{a:oe,b:le},backend:r});K=$c({inputs:{x:me},backend:r,attrs:{axis:pe,keepDims:!0}}),$.push(me)}else{const X=An(n.dtype,t.dtype),ne=new q1(C,S,[E,p,f],e,s,z,G,B,U),re=[T,k];if(null!=a&&re.push(a),B&&re.push(o),U){const ie=r.makeTensorInfo([],"float32",er(i,"float32"));re.push(ie),$.push(ie)}K=r.runWebGLProgram(ne,re,X)}const H=ue({inputs:{x:K},backend:r,attrs:{shape:w}});$.push(K);for(const X of $)r.disposeIntermediateTensorInfo(X);return H}const dW={kernelName:ql,backendName:"webgl",kernelFunc:function cW(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a,bias:o,preluActivationWeights:i}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=s;return Ec({a:r,b:a,transposeA:l,transposeB:u,backend:e,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:c})}},Q1="return abs(x);",pW={kernelName:ji,backendName:"webgl",kernelFunc:function hW(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const a=e.texData.get(s.dataId),o=O1(a.values);return e.makeTensorInfo(s.shape,s.dtype,o)}let r;return r=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Cr(s.shape,Q1):new As(s.shape,Q1),e.runWebGLProgram(r,[s],s.dtype)}},mW=Ke({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),gW={kernelName:to,backendName:"webgl",kernelFunc:mW},xW=Ke({opSnippet:"if (isnan(x)) return x;\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),bW={kernelName:no,backendName:"webgl",kernelFunc:xW},ev="return a + b;",wW=rn({opSnippet:ev,packedOpSnippet:ev,supportsComplex:!0,cpuKernelImpl:kz}),vW={kernelName:ma,backendName:"webgl",kernelFunc:wW};class CW{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class SW{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const IW={kernelName:Kc,backendName:"webgl",kernelFunc:function Ac(n){const{inputs:t,backend:e}=n,s=t;if(1===s.length)return Fn({inputs:{x:s[0]},backend:e});if(s.length>V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),u=Ac({inputs:s.slice(0,l),backend:e}),c=Ac({inputs:s.slice(l),backend:e});return Ac({inputs:[u,c],backend:e})}const r=s.map(l=>l.dtype).reduce((l,u)=>An(l,u)),a=s.map(l=>l.shape),i=V().getBool("WEBGL_PACK")?new SW(s[0].shape,a):new CW(s[0].shape,a);return e.runWebGLProgram(i,s,r)}},NW={kernelName:"All",backendName:"webgl",kernelFunc:function TW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,l=ze(a,r.shape);let u=l;const c=St(u,i);let d=r;null!=c&&(d=Sn({inputs:{x:r},backend:e,attrs:{perm:c}}),u=At(u.length,i)),sn("all",u,i);const[h,p]=Xt(d.shape,u),g=ue({inputs:{x:d},backend:e,attrs:{shape:[-1,W(p)]}}),m=ia(g,g.dtype,"all",e);let y;return y=ue(o?{inputs:{x:m},backend:e,attrs:{shape:Et(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},_W={kernelName:"Any",backendName:"webgl",kernelFunc:function kW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,l=ze(a,r.shape);let u=l;const c=St(u,i);let d=r;null!=c&&(d=Sn({inputs:{x:r},backend:e,attrs:{perm:c}}),u=At(u.length,i)),sn("any",u,i);const[h,p]=Xt(d.shape,u),g=ue({inputs:{x:d},backend:e,attrs:{shape:[-1,W(p)]}}),m=ia(g,g.dtype,"any",e);let y;return y=ue(o?{inputs:{x:m},backend:e,attrs:{shape:Et(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}};class $W{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class EW{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,I(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const o=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,l=i.length,u=lt(l),c=Cn("coords",l);let d,h;if(1===o){h=l+1;const k=lt(h);d=`\n        ${k} sourceLocR = ${k}(${c.join()}, 0);\n        ++${c[l-1]};\n        ${k} sourceLocG = ${k}(${c.join()}, 0);\n        ++${c[l-2]};\n        ${k} sourceLocA = ${k}(${c.join()}, 0);\n        --${c[l-1]};\n        ${k} sourceLocB = ${k}(${c.join()}, 0);\n        --${c[l-2]};`}else h=l,d=`\n        ${u} sourceLocR = coords;\n        ++${c[l-1]};\n        ${u} sourceLocG = coords;\n        ++${c[l-2]};\n        ${u} sourceLocA = coords;\n        --${c[l-1]};\n        ${u} sourceLocB = coords;\n        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],g=p.map(k=>"int "+k),m=Cn("sourceLocR",h-1).concat("inIdx.r"),y=Cn("sourceLocG",h-1).concat("inIdx.g"),x=Cn("sourceLocB",h-1).concat("inIdx.b"),b=Cn("sourceLocA",h-1).concat("inIdx.a"),w="max"===s?"greaterThan":"lessThan",C=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,S=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${y.join()}) : 0.,\n            hasNextRow ? getAChannel(${x.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,T=r?"":`\n      float getBestIndicesAChannel(${g.join()}) {\n        return getChannel(getBestIndicesA(${p.join()}),\n                                          vec2(${p.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${g.join()}) {\n        return getChannel(getA(${p.join()}),\n                               vec2(${p.slice(-2).join()}));\n      }\n      ${T}\n      void main() {\n        ${u} coords = getOutputCoords();\n        bool hasNextCol = ${c[l-1]} < ${i[l-1]-1};\n        bool hasNextRow = ${c[l-2]} < ${i[l-2]-1};\n        ${d}\n        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},\n          sourceLocB${f}, sourceLocA${f}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${S};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${C}\n          vec4 candidate = ${S};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function tv(n,t,e,s=null){let r=t.shape[0],a=t.shape[1];null!=s&&(r=s.shape[0],a=s.shape[1]);const o=Nu(a),i={windowSize:o,inSize:a,batchSize:r,outSize:Math.ceil(a/o)},l=new $W(i,e,null==s),u=[t];null!=s&&u.push(s);const c=n.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=tv(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}function nv(n,t,e,s=null){const r=null!=s?s.shape:t.shape,o=Nu(r[r.length-1]),i=new EW(r,o,e,null==s),u=n.runWebGLProgram(i,null==s?[t]:[t,s],"int32");if(u.shape.length===t.shape.length){const c=nv(n,t,e,u);return n.disposeIntermediateTensorInfo(u),c}return u}function sv(n,t,e,s){const r=[e];if(sn("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!V().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],o=n.texData.get(t.dataId);let l=t;null!==o&&o.isPacked&&(l=n.unpackTensor(t),a.push(l));const[u,c]=Xt(l.shape,r),d=W(c),h=ue({inputs:{x:l},backend:n,attrs:{shape:[-1,d]}});a.push(h);const p=tv(n,h,s);a.push(p);const f=ue({inputs:{x:p},backend:n,attrs:{shape:u}});return a.forEach(g=>n.disposeIntermediateTensorInfo(g)),f}return nv(n,t,s)}const DW={kernelName:qi,backendName:"webgl",kernelFunc:function AW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;let o=ze(a,r.shape);const i=St(o,r.shape.length);let l=r;const u=[];null!=i&&(l=Sn({inputs:{x:r},backend:e,attrs:{perm:i}}),u.push(l),o=At(o.length,l.shape.length)),sn("argMax",[o[0]],l.shape.length);const c=sv(e,l,o[0],"max");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},FW={kernelName:Ki,backendName:"webgl",kernelFunc:function RW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;let o=ze(a,r.shape);const i=St(o,r.shape.length);let l=r;const u=[];null!=i&&(l=Sn({inputs:{x:r},backend:e,attrs:{perm:i}}),u.push(l),o=At(o.length,l.shape.length)),sn("argMin",[o[0]],l.shape.length);const c=sv(e,l,o[0],"min");return u.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}},PW=Ke({opSnippet:"if (isnan(x)) return x;\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),LW={kernelName:so,backendName:"webgl",kernelFunc:PW},VW=Ke({opSnippet:"if (isnan(x)) return x;return log(x + sqrt(x * x + 1.0));"}),zW={kernelName:ro,backendName:"webgl",kernelFunc:VW},WW=Ke({opSnippet:"if (isnan(x)) return x;\n  return atan(x);\n"}),UW={kernelName:ao,backendName:"webgl",kernelFunc:WW},jW=rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),qW={kernelName:lo,backendName:"webgl",kernelFunc:jW},XW=Ke({opSnippet:"if (isnan(x)) return x;\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),ZW={kernelName:oo,backendName:"webgl",kernelFunc:XW};class zi{constructor(t,e,s,r=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,i=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const g="avg"===e;let x="0.0";if(g||(x="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${l});\n        const ivec2 pads = ivec2(${p}, ${f});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${d};\n              wR += ${u}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${c}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(w="avgValue / max(count, 1.0)");const C=4*Math.floor(o/4),S=o%4,T=`\n      if (${g}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${l});\n      const ivec2 pads = ivec2(${p}, ${f});\n      const float initializationValue = ${x};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${x});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${d};\n            wR += ${u}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${C}; wC += 4) {\n            int xC = xCCorner + wC * ${c};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              getValue(batch, xR, xC + 3 * ${c}, d)\n            );\n\n            ${T}\n          }\n\n          int xC = xCCorner + ${C};\n          if (${1===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${2===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${T}\n          } else if (${3===S}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${c}, d),\n              getValue(batch, xR, xC + 2 * ${c}, d),\n              initializationValue\n            );\n\n            ${T}\n          }\n        }\n        setOutput(${w});\n      }\n    `}}class Jf{constructor(t,e,s,r=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,i=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,g=t.effectiveFilterWidth,m=t.padInfo.front,y=t.padInfo.top,x=t.padInfo.left;this.outputShape=t.outShape;const b="avg"===e;let w="0.0";if(b||(w="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${l}, ${u});\n        const ivec3 pads = ivec3(${m}, ${y}, ${x});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${p};\n              wD += ${c}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${f};\n                wR += ${d}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${g};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${g} +\n                      wR * ${g} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let S=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(S="avgValue / max(count, 1.0)");const T=4*Math.floor(o/4),k=o%4,$=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${l}, ${u});\n      const ivec3 pads = ivec3(${m}, ${y}, ${x});\n      const float initializationValue = ${w};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${w});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${c}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${f};\n            wR += ${d}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${T}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${$}\n            }\n\n            int xC = xCCorner + ${T};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${$}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${$}\n            }\n          }\n        }\n        setOutput(${S});\n      }\n    `}}const JW={kernelName:Xi,backendName:"webgl",kernelFunc:function YW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Li(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:l}=s;I(nn(o,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=Kn(r.shape,a,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Qe(c.inShape,c.outShape))return Fn({inputs:{x:r},backend:e});const d=new zi(c,"avg",!1);return e.runWebGLProgram(d,[r],"float32")}},e4={kernelName:Zi,backendName:"webgl",kernelFunc:function QW(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:o,pad:i,dimRoundingMode:l,dataFormat:u}=s,d=Ps(r.shape,a,o,[1,1,1],i,l,u),h=new Jf(d,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}};class t4{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const l=t.effectiveFilterHeight,u=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${l-1-t.padInfo.top}, ${u-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${l};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${u};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class n4{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${d-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${p-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${p};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const r4={kernelName:Jc,backendName:"webgl",kernelFunc:function s4(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,o=a,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=Ps(o.shape,i,l,[1,1,1],u,c),p=new n4(h);return e.runWebGLProgram(p,[r],o.dtype)}},o4={kernelName:Yc,backendName:"webgl",kernelFunc:function a4(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,o=a;Li([r,a],"avgPoolGrad");const{filterSize:i,strides:l,pad:u}=s,c=Kn(o.shape,i,l,1,u),d=new t4(c);return e.runWebGLProgram(d,[r],o.dtype)}},l4={kernelName:Yi,backendName:"webgl",kernelFunc:function i4(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a}=t,{transposeA:o,transposeB:i}=s;return Ec({a:r,b:a,transposeA:o,transposeB:i,backend:e})}};class u4{constructor(t,e,s,r,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Oe(t,e),Oe(t,s);let i="0.0";null!=r&&(Oe(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="1.0";null!=a&&(Oe(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${l};\n        float inv = scale * inversesqrt(variance + float(${o}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class c4{constructor(t,e,s,r,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Oe(t,e),Oe(t,s);let i="vec4(0.0)";null!=r&&(Oe(t,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let l="vec4(1.0)";null!=a&&(Oe(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${l};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${o}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const d4={kernelName:ul,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:a,offset:o,scale:i}=n;I(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(null==i||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=e;null==l&&(l=.001);const u=[s,r,a];let c=null;null!=o&&(c=o.shape,u.push(o));let d=null;null!=i&&(d=i.shape,u.push(i));const h=V().getBool("WEBGL_PACK_NORMALIZATION")?new c4(s.shape,r.shape,a.shape,c,d,l):new u4(s.shape,r.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class h4{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=lt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=function p4(n){if(1===n)return"sourceLoc";if(n<=6)return Qf.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((o,i)=>`sourceLoc.${Qf[i]} = start[${i}] + coords.${Qf[i]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}}const Qf=["x","y","z","w","u","v"];class f4{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=lt(this.rank),s=Cn("coords",this.rank),r=Cn("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${a})`,i=`\n      result.x = ${o};\n      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${o};\n        --${r[this.rank-1]};\n      }\n    `,l=1===this.rank?"":`\n      --${s[this.rank-1]};\n      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${o};\n        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${o};\n        }\n      }\n    `,u=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${u}\n        vec4 result = vec4(0.);\n        ${i}\n        ${l}\n        setOutput(result);\n      }\n    `}}function Ya(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,size:o}=s,[i,l]=cu(r,a,o);if(wh(r,i,l),0===W(l))return e.makeTensorInfo(l,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||"string"===r.dtype){const d=e.texData.get(r.dataId),h=aB(d.values,i,l,r.shape,r.dtype);return e.makeTensorInfo(l,r.dtype,h)}const{isPacked:u}=e.texData.get(r.dataId),c=Ch(r.shape,i,l);if(u||!c){const d=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new f4(l):new h4(l);return e.runWebGLProgram(d,[r],r.dtype,[i])}return e.uploadToGPU(r.dataId),function m4(n,t,e,s){const r=s.texData.get(n.dataId),a=s.makeTensorInfo(e,n.dtype),o=s.texData.get(a.dataId);Object.assign(o,r),o.refCount=1,o.shape=e,o.dtype=n.dtype;let i=Sh(t,Ie(n.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),a}(r,i,l,e)}const g4={kernelName:Ml,backendName:"webgl",kernelFunc:Ya},y4={kernelName:Ji,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,crops:o}=s;I(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((x,b)=>x*b),l=gi(r.shape,a,i),u=yi(l.length,a.length),c=xi(r.shape,a,i),d=ap(o,a.length),h=op(c,o,a.length),p=[],f=ue({inputs:{x:r},backend:e,attrs:{shape:l}}),g=Sn({inputs:{x:f},backend:e,attrs:{perm:u}}),m=ue({inputs:{x:g},backend:e,attrs:{shape:c}}),y=Ya({inputs:{x:m},backend:e,attrs:{begin:d,size:h}});return p.push(f),p.push(g),p.push(m),p.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}},b4={kernelName:Qc,backendName:"webgl",kernelFunc:function x4(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:o}=s,i=e.readSync(r.dataId),l=e.readSync(a.dataId),u=F1(i,l,a.dtype,a.shape,o);return e.makeTensorInfo([o],a.dtype,u)}},S4={kernelName:ed,backendName:"webgl",kernelFunc:function C4(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=V().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([s,r])||1===o){const l=e.texData.get(s.dataId).values,u=e.texData.get(r.dataId).values,[c,d]=$z(s.shape,r.shape,l,u,s.dtype),h=e.makeTensorInfo(d,s.dtype);return e.texData.get(h.dataId).values=c,h}let i;return i=a?new Xa("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",s.shape,r.shape,!1):new aa("\n  return float(int(a.r) & int(b.r));\n",s.shape,r.shape),e.runWebGLProgram(i,[s,r],s.dtype)}},T4={kernelName:bm,backendName:"webgl",kernelFunc:function I4(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,a=e.readSync(s.dataId),o=e.readSync(r.dataId),i=Oe(Array.from(a),Array.from(o));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},rv=rn({opSnippet:"return float(a != b);",cpuKernelImpl:Zz,dtype:"bool"}),N4={kernelName:Nl,backendName:"webgl",kernelFunc:rv};function Bi(n){const{inputs:t,backend:e}=n,{input:s}=t;return Fn({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.real},backend:e})}const k4={kernelName:kd,backendName:"webgl",kernelFunc:Bi},E4={kernelName:uo,backendName:"webgl",kernelFunc:function em(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return Fn({inputs:{x:r},backend:e});const o=Zt(r.shape),i=em({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),l=Sr({inputs:{real:i,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(i),l}if("complex64"===r.dtype){const o=Bi({inputs:{input:r},backend:e}),i=em({inputs:{x:o},backend:e,attrs:{dtype:a}});return e.disposeIntermediateTensorInfo(o),i}if(!pm(r.dtype,a)){const o=Fn({inputs:{x:r},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(e.shouldExecuteOnCPU([r])){const o=e.texData.get(r.dataId).values,[i,l,u]=Ez(o,r.shape,r.dtype,a);return e.makeTensorInfo(i,l,u)}if("int32"===a)return function $4(n,t){const e=new As(n.shape,"return float(int(x));"),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(r,e);if("bool"===a){const o=e.makeTensorInfo([],"bool",ln("bool",1)),l=rv({inputs:{a:r,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}},av="return ceil(x);",A4=Ke({opSnippet:av,packedOpSnippet:av,cpuKernelImpl:Az}),D4={kernelName:co,backendName:"webgl",kernelFunc:A4};class R4{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class F4{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const P4={kernelName:ho,backendName:"webgl",kernelFunc:function O4(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:a,clipValueMax:o}=s;let i;return i=V().getBool("WEBGL_PACK_CLIP")?new F4(r.shape):new R4(r.shape),e.runWebGLProgram(i,[r],r.dtype,[[a],[o]])}};class L4{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function ov(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const V4={kernelName:Qi,backendName:"webgl",kernelFunc:function M4(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),a=new L4(s.shape),o=[ov(s,r.complexTensorInfos.real),ov(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(a,o,o[0].dtype)}};class z4{constructor(t){this.outputShape=[],this.outputShape=Cs(t,1),this.variableNames=t.map((o,i)=>`T${i}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++)s.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${e[o-1]}));`);s.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `}}class B4{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Cs(t,e);const s=this.outputShape,r=s.length,a=lt(r),o=Cn("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((g,m)=>`T${m}`);const l=new Array(t.length-1);l[0]=t[0][e];for(let g=1;g<l.length;g++)l[g]=l[g-1]+t[g][e];const u=i[e],c=i.slice(-2),d=i.join();let h=`if (${u} < ${l[0]}) {\n        return getChannel(\n            getT0(${d}), vec2(${c.join()}));\n        }`;for(let g=1;g<l.length;g++){const m=l[g-1];h+=`\n        if (${u} < ${l[g]}  && ${u} >= ${l[g-1]}) {\n          return getChannel(\n            getT${g}(${Dc(i,u,m)}),\n            vec2(${Dc(c,u,m)}));\n        }`}const f=l[l.length-1];h+=`\n        return getChannel(\n          getT${l.length}(${Dc(i,u,f)}),\n          vec2(${Dc(c,u,f)}));`,this.userCode=`\n      float getValue(${i.map(g=>"int "+g)}) {\n        ${h}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${o}), 0., 0., 0.);\n\n        ${o[r-1]} = ${o[r-1]} + 1;\n        if (${o[r-1]} < ${s[r-1]}) {\n          result.g = getValue(${o});\n        }\n\n        ${o[r-2]} = ${o[r-2]} + 1;\n        if (${o[r-2]} < ${s[r-2]}) {\n          result.a = getValue(${o});\n        }\n\n        ${o[r-1]} = ${o[r-1]} - 1;\n        if (${o[r-2]} < ${s[r-2]} &&\n            ${o[r-1]} < ${s[r-1]}) {\n          result.b = getValue(${o});\n        }\n        setOutput(result);\n      }\n    `}}function Dc(n,t,e){const s=n.indexOf(t);return n.map((a,o)=>o===s?`${a} - ${e}`:a).join()}function Rc(n){const{inputs:t,backend:e}=n,{input:s}=t;return Fn({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.imag},backend:e})}const W4={kernelName:bd,backendName:"webgl",kernelFunc:Rc};function Wi(n,t,e){const s=n[0].dtype;if("complex64"===s){const p=n.map(x=>Bi({inputs:{input:x},backend:e})),f=n.map(x=>Rc({inputs:{input:x},backend:e})),g=Wi(p,t,e),m=Wi(f,t,e),y=Sr({inputs:{real:g,imag:m},backend:e});return p.forEach(x=>e.disposeIntermediateTensorInfo(x)),f.forEach(x=>e.disposeIntermediateTensorInfo(x)),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),y}let r=e.shouldExecuteOnCPU(n);if("string"===s&&(r=!0),r){const p=n.map(w=>{const C=W(w.shape.slice(t));return ue({inputs:{x:w},backend:e,attrs:{shape:[-1,C]}})}),f=p.map(w=>({vals:e.readSync(w.dataId),shape:w.shape})),g=Cs(p.map(w=>w.shape),1),y=Dz(f,g,s,1===p[0].shape[0]),x=Cs(n.map(w=>w.shape),t),b=e.makeTensorInfo(x,s,y);return p.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}const a=n.filter(p=>W(p.shape)>0),o=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const p=o?new As(n[0].shape,vr):new Cr(n[0].shape,vr);return e.runWebGLProgram(p,n,s)}const i=V().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>i){const p=[];for(let g=0;g<a.length;g+=i){const m=a.slice(g,g+i);p.push(Wi(m,t,e))}const f=Wi(p,t,e);for(const g of p)e.disposeIntermediateTensorInfo(g);return f}if(o){const p=new B4(a.map(f=>f.shape),t);return e.runWebGLProgram(p,a,s)}const{tensors2D:l,outShape:u}=function U4(n,t,e){const s=Cs(n.map(a=>a.shape),t);return{tensors2D:n.map(a=>ue({inputs:{x:a},attrs:{shape:[-1,W(a.shape.slice(t))]},backend:e})),outShape:s}}(a,t,e),c=new z4(l.map(p=>p.shape)),d=e.runWebGLProgram(c,l,s);l.forEach(p=>e.disposeIntermediateTensorInfo(p));const h=ue({inputs:{x:d},attrs:{shape:u},backend:e});return e.disposeIntermediateTensorInfo(d),h}function iv(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,a=ze(r,t[0].shape)[0];np(t.map(u=>u.shape),a);const i=Cs(t.map(u=>u.shape),a);if(0===W(i))return e.makeTensorInfo(i,t[0].dtype,[]);const l=t.filter(u=>W(u.shape)>0);return 1===l.length?Fn({inputs:{x:l[0]},backend:e}):Wi(l,a,e)}const G4={kernelName:el,backendName:"webgl",kernelFunc:iv};class lv{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,i=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),g=t.inChannels%4,m="channelsLast"===t.dataFormat,y=m?1:2,x=m?2:3,b=m?3:1;let w="",C="";s&&(w=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,C="result = activation(result);");const S=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${w}\n\n      const ivec2 strides = ivec2(${l}, ${u});\n      const ivec2 pads = ivec2(${o}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${y}], coords[${x}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${c};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${p}; wC++) {\n            int xC = xCCorner + wC * ${d};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${f}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===g}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${f}) *\n                    getW(wR, wC, ${f}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${f}, xR, xC) *\n                    getW(wR, wC, ${f}, d2);\n              }\n\n            } else if (${2===g}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===g}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${f}, d2),\n                getW(wR, wC, ${f} + 1, d2),\n                getW(wR, wC, ${f} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${f}),\n                  getX(batch, xR, xC, ${f} + 1),\n                  getX(batch, xR, xC, ${f} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${f}, xR, xC),\n                  getX(batch, ${f} + 1, xR, xC),\n                  getX(batch, ${f} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${S}\n        ${C}\n        setOutput(result);\n      }\n    `}}class H4{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,a=t.strideDepth,o=t.strideHeight,i=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=4*Math.floor(t.inChannels/4),g=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${o}, ${i});\n      const ivec3 pads = ivec3(${e}, ${s}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${d}; wF++) {\n          int xF = xFCorner + wF * ${l};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${u};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${p}; wC++) {\n              int xC = xCCorner + wC * ${c};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${f}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===g}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${f}) *\n                  getW(wF, wR, wC, ${f}, d2);\n              } else if (${2===g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${f}),\n                  getX(batch, xF, xR, xC, ${f} + 1),\n                  getX(batch, xF, xR, xC, ${f} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${f}, d2),\n                  getW(wF, wR, wC, ${f} + 1, d2),\n                  getW(wF, wR, wC, ${f} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class uv{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pn(this.outputShape.length);const o=t.padInfo.left,i=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)h+=`\n           vec4 xTexelC${2*m};\n           int xTexelC${2*m}Ready;\n           vec4 xTexelC${2*m+1};\n           int xTexelC${2*m+1}Ready;\n           vec4 xC${m};`;h+=`\n     for (int r = 0; r < ${u}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let m=0;m<c;m++)h+=`\n           xTexelC${2*m} = vec4(0.0);\n           xTexelC${2*m}Ready = 0;\n           xTexelC${2*m+1} = vec4(0.0);\n           xTexelC${2*m+1}Ready = 0;\n           xC${m} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(d+1)/2;m++){const y=2*m;if(h+=`\n           xC = xCCorner + ${y*l};\n           `,1===i){if(y<c&&(o%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n               `,h+=1===l&&y>0?`\n                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);\n                   } else {\n                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xC${y} = xTexelC${y};\n                 `,y+1<c)){const x=o%2==0?Vc(l):l;l%2==0&&o%2==1||l%2!=0&&o%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${x};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${y+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${y+1}Ready = 1;\n                   }\n                   `,h+=l>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);\n                     } else {\n                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);\n                     }\n                     `:`\n                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);\n                     `):h+=1===x?`\n                     xC${y+1} = xTexelC${y};\n                     `:`\n                     xCOffset = xC + ${x};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${y+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${y+1}Ready = 1;\n                     }\n\n                     xC${y+1} = xTexelC${y+1};\n                     `}}else y<c&&(o%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n               `,y+1<c&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {\n                   xTexelC${y} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${y}.zw = vec2(0.0);\n                   }\n                   xTexelC${y}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {\n                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${y+1}.zw = vec2(0.);\n                   }\n                   xTexelC${y+1}Ready = 1;\n                 }\n\n                 xC${y} = vec4(\n                   xTexelC${y}.xy, xTexelC${y+1}.xy);\n               `,y+1<c&&(h+=`\n                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);\n                 `)));y<c&&(h+=`\n             wTexel = getW(r, ${y}, d1, d2);\n             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,y+1<c&&(h+=`\n               wTexel = getW(r, ${y+1}, d1, d2);\n               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let p="",f="";s&&(p=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${s}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${s}\n         }`:`vec4 activation(vec4 x) {\n           ${s}\n         }`,f="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${p}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${g}\n         ${f}\n         setOutput(result);\n       }\n     `}}class j4{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=pn(this.outputShape.length);const{dataFormat:s}=e,r=vn(),a="channelsLast"===s,o=a?1:2,i=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`\n          blockIndex = rc.z + ${d};\n          pos = rc.y + ${c};\n\n          ${l}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${o}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*c+d}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${u}\n\n        ${r.output} = result;\n      }\n    `}}function Fc(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function cv({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const l=n.shape,u=s.texData.get(n.dataId),c=e.inChannels,d=l[0]*l[1]*l[2],h=e.outChannels,p="channelsLast"===e.dataFormat;let m;const y=[];if(null!=a){const w=Fc(a.shape,p);null!=w&&(a=ue({inputs:{x:a},backend:s,attrs:{shape:w}}),y.push(a))}if(null!=r){const w=Fc(r.shape,p);null!=w&&(r=ue({inputs:{x:r},backend:s,attrs:{shape:w}}),y.push(r))}if((1!==d&&1!==h||!(c>1e3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&Qe(u.shape.slice(-3),l.slice(-3))){const C={dataId:n.dataId,shape:[1,l[0]*l[1]*(l[2]+1),e.inChannels],dtype:n.dtype},S=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,I(Cc(u.shape,C.shape),()=>`packed reshape ${u.shape} to ${C.shape} isn't free`);const T=ue({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});y.push(T);const k=Ec({a:C,b:T,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),$=s.texData.get(k.dataId);I($.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=S,$.shape=e.outShape,m=Fn({inputs:{x:k},backend:s}),m.shape=e.outShape,y.push(k)}else{const w=e.outHeight*e.outWidth,C=ue({inputs:{x:n},backend:s,attrs:{shape:p?[e.batchSize,w,e.inChannels]:[e.batchSize,e.inChannels,w]}}),S=ue({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),T=Ec({a:p?C:S,b:p?S:C,transposeA:!p,transposeB:!1,backend:s,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o});m=ue({inputs:{x:T},backend:s,attrs:{shape:e.outShape}}),y.push(C),y.push(S),y.push(T)}for(const w of y)s.disposeIntermediateTensorInfo(w);return m}function dv({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=e,f="channelsLast"===p,g=l*u*c,m=h*d,y=[e.batchSize,g,m],w=[];if(null!=a){const H=Fc(a.shape,f);null!=H&&(a=ue({inputs:{x:a},backend:s,attrs:{shape:H}}),w.push(a))}if(null!=r){const H=Fc(r.shape,f);null!=H&&(r=ue({inputs:{x:r},backend:s,attrs:{shape:H}}),w.push(r))}const C=ue({inputs:{x:t},backend:s,attrs:{shape:[1,g,W(t.shape)/g]}});w.push(C);const S=new j4(y,e),k=s.runWebGLProgram(S,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),$=ue({inputs:{x:k},backend:s,attrs:{shape:y}});w.push(k),w.push($);const E=null!=r,P=null!=a,z="leakyrelu"===i,B=i?Vi(i,!0):null,U=new q1(f?$.shape:C.shape,f?C.shape:$.shape,f?[e.batchSize,m,e.outChannels]:[e.batchSize,e.outChannels,m],!0,!1,E,B,P,z),G=f?[$,C]:[C,$];if(r&&G.push(r),P&&G.push(a),z){const H=s.makeTensorInfo([],"float32",er(o,"float32"));G.push(H),w.push(H)}const q=s.runWebGLProgram(U,G,"float32"),K=ue({inputs:{x:q},backend:s,attrs:{shape:e.outShape}});w.push(q);for(const H of w)s.disposeIntermediateTensorInfo(H);return K}const K4={kernelName:tl,backendName:"webgl",kernelFunc:function q4(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dataFormat:l,dilations:u,dimRoundingMode:c}=s,d=Ls(l),h=Kt(r.shape,a.shape,o,u,i,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&V().getBool("WEBGL_EXP_CONV")){const g=new uv(h);p=e.runWebGLProgram(g,[r,a],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if(V().getBool("WEBGL_CONV_IM2COL"))p=dv({x:r,filter:a,convInfo:h,backend:e});else{const g=new lv(h);p=e.runWebGLProgram(g,[r,a],"float32")}else p=cv({x:r,filter:a,convInfo:h,backend:e});const f=ue({inputs:{x:p},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(p),f}};class X4{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Z4{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,o="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${o?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${o?1:2}], coords[${o?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${o}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Y4{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class J4{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${s-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${s}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${s} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const eU={kernelName:nd,backendName:"webgl",kernelFunc:function Q4(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,pad:i,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,d=Ls(l),h=Kt(r.shape,c,o,1,i,u,!1,d),p=new X4(h);return e.runWebGLProgram(p,[r,a],"float32")}};class tU{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=pn(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int wCPerm = ${s} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const sU={kernelName:nl,backendName:"webgl",kernelFunc:function nU(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{inputShape:o,strides:i,pad:l,dataFormat:u,dimRoundingMode:c}=s,d=Ls(u),h=Kt(o,a.shape,i,1,l,c,!1,d);if(V().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const p=[[h.strideHeight,h.strideWidth]],f=new tU(h);return e.runWebGLProgram(f,[r,a],"float32",p)}{const p=new Z4(h);return e.runWebGLProgram(p,[r,a],"float32")}}},aU={kernelName:sl,backendName:"webgl",kernelFunc:function rU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dilations:l}=s,u=ir(r.shape,a.shape,o,l,i),c=new H4(u);return e.runWebGLProgram(c,[r,a],"float32")}},iU={kernelName:sd,backendName:"webgl",kernelFunc:function oU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,pad:i,filterShape:l}=s,u=ir(r.shape,l,o,1,i),c=new Y4(u);return e.runWebGLProgram(c,[r,a],"float32")}},uU={kernelName:rd,backendName:"webgl",kernelFunc:function lU(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{pad:o,strides:i,inputShape:l}=s,u=ir(l,a.shape,i,1,o),c=new J4(u);return e.runWebGLProgram(c,[r,a],"float32")}},hU=Ke({opSnippet:"if (isnan(x)) return x;\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${oa}\n  return result;\n`}),pU={kernelName:po,backendName:"webgl",kernelFunc:hU},fU=Ke({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),mU={kernelName:fo,backendName:"webgl",kernelFunc:fU};class gU{constructor(t,e,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,l,u]=t,[c]=e,[d,h]=s;this.outputShape=[c,d,h,u];const p="bilinear"===r?1:0,[f,g]=[i-1+".0",l-1+".0"],[m,y,x]=d>1?[""+(i-1)/(d-1),"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,w,C]=h>1?[""+(l-1)/(h-1),"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${o}) {\n          return;\n        }\n\n        float height_scale = ${y};\n        float width_scale = ${w};\n\n        float in_y = ${x};\n        if( in_y < 0.0 || in_y > ${f} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${C};\n        if( in_x < 0.0 || in_x > ${g} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${p} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const yU={kernelName:od,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:a,boxInd:o}=t,{cropSize:i,method:l,extrapolationValue:u}=s,c=new gU(r.shape,a.shape,i,l,u);return e.runWebGLProgram(c,[r,a,o],"float32")}};var Ja=(()=>{return(n=Ja||(Ja={})).Prod="*",n.Sum="+",Ja;var n})();class hv{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=s?this.op===Ja.Prod?"1.0":"0.0":`getX(${pv(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";s?(u=r?"end != "+(l-1):"end != 0",c=r?"end + 1":"end - 1"):(u=r?`end + pow2 < ${l}`:"end >= pow2",c=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${lt(a)} coords = getOutputCoords();\n        int end = ${fv(a,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${u}) {\n          int idx = ${c};\n          ${fv(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${pv(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function pv(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function fv(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function mv(n,t,e,s,r,a){const o=t.shape.length,i=St([s],o);let l=t;null!=i&&(l=Sn({inputs:{x:t},backend:e,attrs:{perm:i}}));const u=At(1,o)[0];if(u!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const c=l.shape[u];let d=Fn({inputs:{x:l},backend:e});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new hv(n,l.shape,!1,a),g=d;d=e.runWebGLProgram(p,[d],d.dtype,[[h]]),e.disposeIntermediateTensorInfo(g)}if(r){const h=new hv(n,l.shape,r,a),p=d;d=e.runWebGLProgram(h,[d],d.dtype),e.disposeIntermediateTensorInfo(p)}if(null!=i){const p=Sn({inputs:{x:d},backend:e,attrs:{perm:ur(i)}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(l),p}return d}const bU={kernelName:ad,backendName:"webgl",kernelFunc:function xU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;return mv(Ja.Prod,r,e,a,o,i)}},vU={kernelName:rl,backendName:"webgl",kernelFunc:function wU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:o,reverse:i}=s;return mv(Ja.Sum,r,e,a,o,i)}},SU={kernelName:id,backendName:"webgl",kernelFunc:function CU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:o,binaryOutput:i}=s;if(1===r.shape.length){const l=e.readSync(r.dataId),u=e.readSync(a.dataId),c=F1(l,u,a.dtype,a.shape,o);return e.makeTensorInfo([o],a.dtype,c)}if(2===r.shape.length){const l=e.bufferSync(r),u=e.bufferSync(a),c=_z(l,u,o,i);return e.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class IU{constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const NU={kernelName:ld,backendName:"webgl",kernelFunc:function TU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:a,dataFormat:o}=s,i=r.shape[0],d=("NHWC"===o?r.shape[1]:r.shape[2])*a,h=("NHWC"===o?r.shape[2]:r.shape[3])*a,p=("NHWC"===o?r.shape[3]:r.shape[1])/(a*a),g=new IU("NHWC"===o?[i,d,h,p]:[i,p,d,h],a,o);return e.runWebGLProgram(g,[r],r.dtype)}};class gv{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pn(this.outputShape.length);const o=t.filterHeight,i=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";s&&(u=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,c="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${u}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${l};\n        int q = d2 - d1 * ${l};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${o}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${d}\n        ${c}\n        setOutput(result);\n      }\n    `}}class yv{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=pn(this.outputShape.length);const o=t.outChannels/t.inChannels,i=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let p="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let y=0;y<d;y++)p+=`\n          vec4 xTexelC${2*y};\n          int xTexelC${2*y}Ready;\n          vec4 xTexelC${2*y+1};\n          int xTexelC${2*y+1}Ready;\n          vec4 xC${y};`;p+=`\n    for (int r = 0; r < ${c}; r++) {\n      `;for(let y=0;y<d;y++)p+=`\n          xTexelC${2*y} = vec4(0.0);\n          xTexelC${2*y}Ready = 0;\n          xTexelC${2*y+1} = vec4(0.0);\n          xTexelC${2*y+1}Ready = 0;\n          xC${y} = vec4(0.0);`;p+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let y=0;y<(h+1)/2;y++){const x=2*y;if(p+=`\n          xC = xCCorner + ${x*u};\n          `,1===l){if(x<d&&(i%2==1?(p+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n              `,p+=1===u&&x>0?`\n                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);\n                  } else {\n                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);\n                  }\n                  `):p+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xC${x} = xTexelC${x};\n                `,x+1<d)){const b=i%2==0?Vc(u):u;u%2==0&&i%2==1||u%2!=0&&i%2!=1?(p+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${x+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${x+1}Ready = 1;\n                  }\n                  `,p+=u>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);\n                    } else {\n                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);\n                    }\n                    `:`\n                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);\n                    `):p+=1===b?`\n                    xC${x+1} = xTexelC${x};\n                    `:`\n                    xCOffset = xC + ${b};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${x+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${x+1}Ready = 1;\n                    }\n\n                    xC${x+1} = xTexelC${x+1};\n                    `}}else x<d&&(i%2==1?(p+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {\n                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${x+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${x+1}Ready = 1;\n                }\n\n                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n              `,x+1<d&&(p+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);\n                `)):(p+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                  xTexelC${x} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${x}.zw = vec2(0.0);\n                  }\n                  xTexelC${x}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${x+1}.zw = vec2(0.);\n                  }\n                  xTexelC${x+1}Ready = 1;\n                }\n\n                xC${x} = vec4(\n                  xTexelC${x}.xy, xTexelC${x+1}.xy);\n              `,x+1<d&&(p+=`\n                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n                `)));x<d&&(p+=`\n            wTexel = getW(r, ${x}, d1, q);\n            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);\n          `,x+1<d&&(p+=`\n              wTexel = getW(r, ${x+1}, d1, q);\n              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}p+="\n    }\n  ",p+="\n      }\n    ";let f="",g="";s&&(f=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,g="result = activation(result);");const m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${f}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${p}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${g}\n        setOutput(result);\n      }\n    `}}const _U={kernelName:al,backendName:"webgl",kernelFunc:function kU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dilations:l,dimRoundingMode:u}=s;let c=l;null==c&&(c=[1,1]),I(nn(o,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const d=Kt(r.shape,a.shape,o,c,i,u,!0);let h;return h=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?new yv(d):new gv(d),e.runWebGLProgram(h,[r,a],"float32",[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]])}};class $U{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class EU{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,l=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${l}; dm++) {\n              int d2 = d1 * ${l} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const DU={kernelName:ud,backendName:"webgl",kernelFunc:function AU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,filterShape:c}=s,d=Kt(r.shape,c,o,i,l,u,!0),h=new $U(d);return e.runWebGLProgram(h,[r,a],"float32")}},FU={kernelName:cd,backendName:"webgl",kernelFunc:function RU(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{strides:o,dilations:i,pad:l,dimRoundingMode:u,inputShape:c}=s,d=Kt(c,a.shape,o,i,l,u,!0),h=new EU(d);return e.runWebGLProgram(h,[r,a],"float32")}};class OU{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const LU={kernelName:"Diag",backendName:"webgl",kernelFunc:function PU(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],a=W(s.shape),o=ue({inputs:{x:s},backend:e,attrs:{shape:[a]}}),i=new OU(a),l=e.runWebGLProgram(i,[o],o.dtype),u=ue({inputs:{x:l},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(l),u}};class MU{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${u};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${l}; w++) {\n              int wIn = wBeg + w * ${c};\n\n              if (wIn >= 0 && wIn < ${s}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const zU={kernelName:ol,backendName:"webgl",kernelFunc:function VU(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:o,pad:i,dilations:l}=s,u=ai(r.shape,a.shape,o,i,"NHWC",l);let c;const d=new MU(u);c=e.runWebGLProgram(d,[r,a],"float32");const h=ue({inputs:{x:c},backend:e,attrs:{shape:u.outShape}});return e.disposeIntermediateTensorInfo(c),h}},WU={kernelName:pd,backendName:"webgl",kernelFunc:function BU(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,a=t,{allDims:o,summedDims:i,idDims:l}=gp(r,a.length);xp(o.length,l,a);const{path:u,steps:c}=bp(i,l),d=c.length;let h=null,p=o.length;const f=[];for(let g=0;g<d;++g){for(const m of c[g]){const{permutationIndices:y,expandDims:x}=yp(p,l[m]);let b;wp(y)?b=a[m]:(b=Sn({inputs:{x:a[m]},backend:e,attrs:{perm:y}}),f.push(b));const w=b.shape.slice();for(let C=0;C<x.length;++C)w.splice(x[C],0,1);Qe(b.shape,w)||(b=ue({inputs:{x:b},backend:e,attrs:{shape:w}}),f.push(b)),null===h?h=b:(h=Yf({inputs:{a:b,b:h},backend:e}),f.push(h))}g<d-1&&(u[g]>=0&&(h=$c({inputs:{x:h},backend:e,attrs:{axis:u[g]-(o.length-p),keepDims:!1}}),f.push(h)),p--)}for(const g of f)g!==h&&e.disposeIntermediateTensorInfo(g);return h}},UU=Ke({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),GU={kernelName:go,backendName:"webgl",kernelFunc:UU},qU={kernelName:fd,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,a=V().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Xa("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new aa("return (b >= 0.0) ? a : a * (b + 1.0);",s.shape,r.shape);return e.runWebGLProgram(a,[s,r],s.dtype)}},KU=rn({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:Rz}),XU={kernelName:il,backendName:"webgl",kernelFunc:KU},YU=Ke({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${lp};\n  float a1 = ${up};\n  float a2 = ${cp};\n  float a3 = ${dp};\n  float a4 = ${hp};\n  float a5 = ${pp};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),JU={kernelName:yo,backendName:"webgl",kernelFunc:YU},xv=Ke({opSnippet:"if (isnan(x)) return x;\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:Fz,dtype:"float32"}),eG={kernelName:xo,backendName:"webgl",kernelFunc:xv};function tm(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:a}=t,o=a.shape.length,i=a.shape.slice();let l=r;return r<0&&(I(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),i.splice(l,0,1),ue({inputs:{x:a},backend:s,attrs:{shape:i}})}const tG={kernelName:ll,backendName:"webgl",kernelFunc:tm},bv="return exp(x) - 1.0;",nG=Ke({opSnippet:bv,packedOpSnippet:bv,cpuKernelImpl:Oz}),sG={kernelName:bo,backendName:"webgl",kernelFunc:nG};class wv{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let i;if("real"===t)i="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${o};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function vv(n,t,e){const s=e.texData.get(n.dataId),r=W(n.shape),a=n.shape[n.shape.length-1],i=ue({inputs:{x:n},backend:e,attrs:{shape:[r/a,a]}}),l=i.shape,u=new wv("real",l,t),c=new wv("imag",l,t),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],h=e.runWebGLProgram(u,d,"float32"),p=e.runWebGLProgram(c,d,"float32"),f=Sr({inputs:{real:h,imag:p},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p);const g=ue({inputs:{x:f},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(f),g}const aG={kernelName:"FFT",backendName:"webgl",kernelFunc:function rG(n){const{inputs:t,backend:e}=n,{input:s}=t;return vv(s,!1,e)}};class oG{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Ui(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:a}=e;if(a=a||pa(r),"string"===a){const o=$t(a,W(s));return o.fill(r),t.makeTensorInfo(s,a,o)}{const o=new oG(s,r);return t.runWebGLProgram(o,[],a,[[r]])}}const iG={kernelName:gd,backendName:"webgl",kernelFunc:Ui};class lG{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const uG={kernelName:yd,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new lG(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}},Cv="return floor(x);",cG=Ke({opSnippet:Cv,packedOpSnippet:Cv,cpuKernelImpl:Pz}),dG={kernelName:wo,backendName:"webgl",kernelFunc:cG},hG=rn({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),pG={kernelName:vo,backendName:"webgl",kernelFunc:hG};class fG{constructor(t){this.variableNames=["A"];const e=vn(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class mG{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=vn(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${s}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const gG={kernelName:"FromPixels",backendName:"webgl",kernelFunc:function yG(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:a}=s,o="undefined"!=typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!=typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],d=[u,l,a];if(i||o){const g=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==Qa||g!==nm)&&(nm=g,Qa=document.createElement("canvas").getContext("2d",{willReadFrequently:nm})),Qa.canvas.width=l,Qa.canvas.height=u,Qa.drawImage(r,0,0,l,u),r=Qa.canvas}const h=e.makeTensorInfo(c,"int32");e.texData.get(h.dataId).usage=Rn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),r);const p=V().getBool("WEBGL_PACK")?new mG(d):new fG(d),f=e.runWebGLProgram(p,[h],"int32");return e.disposeData(h.dataId),f}};let Qa,nm=V().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const bG={kernelName:Kl,backendName:"webgl",kernelFunc:function xG(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=s,g=Ls(c),m=Kt(r.shape,a.shape,l,d,u,h,!1,g);let y;const x=[],b=null!=o,w=null!=i,C="leakyrelu"===p,S=()=>{const k=[r,a],$=(E,P)=>{if("NCHW"===P&&1===E.shape.length&&1!==E.shape[0]){const z=ue({inputs:{x:E},backend:e,attrs:{shape:[E.shape[0],1,1]}});return x.push(z),z}return E};if(b&&k.push($(o,c)),w&&k.push($(i,c)),C){const E=e.makeTensorInfo([],"float32",er(f,"float32"));k.push(E),x.push(E)}return k};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&V().getBool("WEBGL_EXP_CONV")){const k=p?Vi(p,!0):null,$=new uv(m,b,k,w,C),E=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],P=S();y=e.runWebGLProgram($,P,"float32",E)}else if(V().getBool("WEBGL_CONV_IM2COL"))y=dv({x:r,filter:a,convInfo:m,backend:e,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const k=p?Vi(p,!1):null,$=new lv(m,b,k,w,C),E=S();y=e.runWebGLProgram($,E,"float32")}else y=cv({x:r,filter:a,convInfo:m,backend:e,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const T=ue({inputs:{x:y},backend:e,attrs:{shape:m.outShape}});return x.push(y),x.forEach(k=>e.disposeIntermediateTensorInfo(k)),T}},vG={kernelName:Xl,backendName:"webgl",kernelFunc:function wG(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=s,f=[];let g=c;null==g&&(g=[1,1]),I(nn(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);const m=Kt(r.shape,a.shape,l,g,u,d,!0),y=V().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1,x=h?Vi(h,y):null,b=[r,a],w=null!=o,C=null!=i,S="leakyrelu"===h;if(w&&b.push(o),C&&b.push(i),S){const E=e.makeTensorInfo([],"float32",er(p,"float32"));b.push(E),f.push(E)}let T;T=y?new yv(m,w,x,C,S):new gv(m,w,x,C,S);const $=e.runWebGLProgram(T,b,"float32",[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]]);return f.forEach(E=>e.disposeIntermediateTensorInfo(E)),$}};class CG{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const a=lt(s.length);let o="\n    int index;";for(let i=0;i<this.sliceDim;i++)o+=`\n          index = round(getIndices(coords[0], ${i}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};\n          flattenIndex += index * ${this.strides[i]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${o}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const IG={kernelName:vm,backendName:"webgl",kernelFunc:function SG(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,a=r.shape,o=a[a.length-1],i=W(s.shape),[l,u,c,d]=ip(s,r),h=ue({inputs:{x:r},backend:e,attrs:{shape:[u,o]}}),p=ue({inputs:{x:s},backend:e,attrs:{shape:[W(s.shape)/c,c]}});if(e.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const y=e.readSync(r.dataId),x=e.bufferSync(s),b=Lz(y,x,s.dtype,u,o,c,d,s.shape,i);return e.makeTensorInfo(l,s.dtype,b.values)}const f=new CG(o,d,[u,c],s.shape),g=e.runWebGLProgram(f,[p,h],p.dtype),m=ue({inputs:{x:g},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(g),m}};class TG{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=lt(this.rank),r=function NG(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)s.push(2===r?"index":`${e[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Sv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:a}=t,{axis:o,batchDims:i}=s,l=ze(o,r.shape)[0];if(V().get("DEBUG")){const x=e.readSync(a.dataId),b=r.shape[l];for(let w=0;w<x.length;++w){const C=x[w];I(C<=b-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${b-1}]`)}}const u=Sp(r,a,l,i),c=W(a.shape),d=[],h=ue({inputs:{x:r},backend:e,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ue({inputs:{x:a},backend:e,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(e.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const x=e.bufferSync(p),b=e.bufferSync(h),w=Mz(b,x,f);return d.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(u.outputShape,w.dtype,w.values)}const g=new TG(h.shape,f),m=e.runWebGLProgram(g,[h,p],h.dtype);d.push(m);const y=ue({inputs:{x:m},backend:e,attrs:{shape:u.outputShape}});return d.forEach(x=>e.disposeIntermediateTensorInfo(x)),y}const kG={kernelName:cl,backendName:"webgl",kernelFunc:Sv},_G=rn({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:Vz,dtype:"bool"}),$G={kernelName:dl,backendName:"webgl",kernelFunc:_G},EG=rn({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:zz}),AG={kernelName:Co,backendName:"webgl",kernelFunc:EG},RG={kernelName:xd,backendName:"webgl",kernelFunc:function DG(n){const{inputs:t,backend:e}=n,{input:s}=t;return vv(s,!0,e)}},FG=Ke({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),OG={kernelName:Io,backendName:"webgl",kernelFunc:FG},PG=Ke({opSnippet:"return float(isinf(x));",dtype:"bool"}),LG={kernelName:To,backendName:"webgl",kernelFunc:PG},MG=Ke({opSnippet:"return float(isnan(x));",dtype:"bool"}),VG={kernelName:No,backendName:"webgl",kernelFunc:MG},zG=rn({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:Bz,dtype:"bool"}),BG={kernelName:pl,backendName:"webgl",kernelFunc:zG},WG=rn({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:Wz,dtype:"bool"}),UG={kernelName:fl,backendName:"webgl",kernelFunc:WG},HG={kernelName:Cm,backendName:"webgl",kernelFunc:function GG(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:a}=e,o=Uz(s,r,a);return t.makeTensorInfo([o.length],"float32",o)}},qG=Ke({opSnippet:"if (isnan(x)) return x;\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:Gz}),KG={kernelName:ko,backendName:"webgl",kernelFunc:qG},ZG=Ke({opSnippet:"if (isnan(x)) return x;\n  return log(1.0 + x);\n"}),YG={kernelName:_o,backendName:"webgl",kernelFunc:ZG},JG=rn({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),QG={kernelName:ml,backendName:"webgl",kernelFunc:JG},eH=Ke({opSnippet:"return float(!(x >= 1.0));"}),tH={kernelName:gl,backendName:"webgl",kernelFunc:eH},nH=rn({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),sH={kernelName:yl,backendName:"webgl",kernelFunc:nH};class rH{constructor(t,e,s,r,a){this.variableNames=["x"],this.outputShape=[];const o=e,i=t[3]-1;let l;this.outputShape=t;const u=`float(${s}) + float(${r}) * sum`;l=.5===a?`inversesqrt(${u})`:1===a?`1.0/(${u})`:`exp(log(${u}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${o}; j <= ${o}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${l};\n        setOutput(val);\n      }\n    `}}class aH{constructor(t,e,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,i=t[3]-1;let l;this.outputShape=t;const u=`float(${s}) + float(${r}) * sum`;l=.5===a?`inversesqrt(${u})`:1===a?`1.0/(${u})`:`exp(log(${u}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${o};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${o}; j <= ${o}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${l};\n        setOutput(result);\n      }\n    `}}const oH={kernelName:xl,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:a,bias:o,alpha:i,beta:l}=s,u=V().getBool("WEBGL_PACK_NORMALIZATION")?new aH(r.shape,a,o,i,l):new rH(r.shape,a,o,i,l);return e.runWebGLProgram(u,[r],r.dtype)}};class iH{constructor(t,e,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${s});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const lH={kernelName:wd,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:a,dy:o}=t,{depthRadius:i,bias:l,alpha:u,beta:c}=s,d=new iH(r.shape,i,l,u,c);return e.runWebGLProgram(d,[r,a,o],r.dtype)}};function Iv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:a,keepDims:o}=s,i=r.shape.length,l=ze(a,r.shape);let u=l;const c=St(u,i),d=null!=c,h=e.shouldExecuteOnCPU([r]);let p=r;if(d){if(h){const b=e.texData.get(p.dataId).values,w=new Array(i);for(let T=0;T<w.length;T++)w[T]=r.shape[c[T]];const C=Xf(b,r.shape,r.dtype,c,w);p=e.makeTensorInfo(w,r.dtype),e.texData.get(p.dataId).values=C}else p=_c(r,c,e);u=At(u.length,i)}sn("max",u,i);const[f,g]=Xt(p.shape,u);let y,m=f;if(o&&(m=Et(f,l)),h){const b=e.texData.get(p.dataId).values,w=Hz(b,W(g),m,r.dtype);y=e.makeTensorInfo(m,r.dtype),e.texData.get(y.dataId).values=w}else y=function uH(n,t,e,s){const r=W(t),i=ue({inputs:{x:n},attrs:{shape:[W(n.shape)/r,r]},backend:s}),l=ia(i,n.dtype,"max",s),u=ue({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}(p,g,m,e);return d&&e.disposeIntermediateTensorInfo(p),y}const cH={kernelName:bl,backendName:"webgl",kernelFunc:Iv},pH=rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:jz}),fH={kernelName:$o,backendName:"webgl",kernelFunc:pH},gH={kernelName:wl,backendName:"webgl",kernelFunc:function mH(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;Li(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:l}=s;I(nn(o,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '1'`);const c=Kn(r.shape,a,o,1,i,l);if(1===c.filterWidth&&1===c.filterHeight&&Qe(c.inShape,c.outShape))return Fn({inputs:{x:r},backend:e});const d=new zi(c,"max",!1);return e.runWebGLProgram(d,[r],r.dtype)}},xH={kernelName:vl,backendName:"webgl",kernelFunc:function yH(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:o,pad:i,dataFormat:l,dimRoundingMode:u}=s,d=Ps(r.shape,a,o,[1,1,1],i,u,l),h=new Jf(d,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}};class bH{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const a=t.effectiveFilterHeight,o=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${a-1-t.padInfo.top}, ${o-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a*o-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${o} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class wH{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${l-1-t.padInfo.front}, ${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${l};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${u};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${c};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${l*u*c-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${u} * ${c} +\n                  wR * ${c} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const CH={kernelName:Cd,backendName:"webgl",kernelFunc:function vH(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,o=a,{filterSize:i,strides:l,pad:u,dimRoundingMode:c}=s,h=Ps(o.shape,i,l,[1,1,1],u,c),p=new Jf(h,"max",!0),f=e.runWebGLProgram(p,[o],o.dtype),g=new wH(h),m=e.runWebGLProgram(g,[r,f],o.dtype);return e.disposeIntermediateTensorInfo(f),m}},IH={kernelName:vd,backendName:"webgl",kernelFunc:function SH(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a,output:o}=t,i=a;Li([a,o],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=s,h=Kn(i.shape,l,u,1,c,d),f=new zi(h,"max",!0),g=e.runWebGLProgram(f,[i],i.dtype),m=new bH(h),y=e.runWebGLProgram(m,[r,g],i.dtype);return e.disposeIntermediateTensorInfo(g),y}},NH={kernelName:Sm,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=t,l=e;I(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const u=[1,1];I(nn(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Kn(s.shape,r,a,u,o),[d,h]=function TH(n,t,e,s){let r=new zi(e,"max",!1);const a=s.runWebGLProgram(r,[n],"float32");return r=new zi(e,"max",!0,!0,t),[a,s.runWebGLProgram(r,[n],"float32")]}(s,i,c,l);return[d,h]}},_H={kernelName:Cl,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:a}=t,o=e,i=s.shape.length,l=ze(a,s.shape);let u=l;const c=St(u,i),d=null!=c,h=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(d){if(h){const w=o.texData.get(f.dataId).values,C=new Array(i);for(let k=0;k<C.length;k++)C[k]=s.shape[c[k]];const S=Xf(w,s.shape,s.dtype,c,C);f=o.makeTensorInfo(C,s.dtype),o.texData.get(f.dataId).values=S}else f=_c(s,c,o);p.push(f),u=At(u.length,i)}sn("sum",u,i);const[g,m]=Xt(f.shape,u);let y=g;r&&(y=Et(g,l));const x=function kH(n,t,e,s){const r=W(t),i=ue({inputs:{x:n},attrs:{shape:[W(n.shape)/r,r]},backend:s}),l=ia(i,"float32","mean",s),u=ue({inputs:{x:l},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(l),u}(f,m,y,o);for(const b of p)o.disposeIntermediateTensorInfo(b);return x}},EH={kernelName:Sl,backendName:"webgl",kernelFunc:function $H(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,l=ze(a,r.shape);let u=l;const c=St(u,i);let d=r;null!=c&&(d=Sn({inputs:{x:r},backend:e,attrs:{perm:c}}),u=At(u.length,r.shape.length)),sn("min",u,i);const[h,p]=Xt(d.shape,u),g=ue({inputs:{x:d},backend:e,attrs:{shape:[-1,W(p)]}}),m=ia(g,g.dtype,"min",e);let y;return y=ue(o?{inputs:{x:m},backend:e,attrs:{shape:Et(h,l)}}:{inputs:{x:m},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(m),null!=c&&e.disposeIntermediateTensorInfo(d),y}},RH=rn({opSnippet:"\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n",cpuKernelImpl:qz}),FH={kernelName:Eo,backendName:"webgl",kernelFunc:RH};class OH{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const r=t.length,a=lt(r),o=e.map(c=>c[0]).join(","),i=e.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),u="reflect"===s?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${o});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${u};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${l}));\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${u};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${u};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class PH{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((f,g)=>f[0]+t[g]+f[1]);const r=t.length,a=lt(r),o=e.map(f=>f[0]).join(","),i=e.map((f,g)=>f[0]+t[g]).join(","),l=Cn("rc",r),u=Cn("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${u.slice(-2).join()})`,h="reflect"===s?0:1;let p="";if(1===r){const f=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[r-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n      `}else{const f=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;p=`\n        ${a} rc = outputLoc;\n        ${f}\n        result[0] = getChannel(getX(${u.join()}), ${d});\n        ${l[r-1]} += 1;\n        if(${c}) {\n          ${f}\n          result[1] = getChannel(getX(${u.join()}), ${d});\n        }\n        rc = outputLoc;\n        ${l[r-2]} += 1;\n        if(${l[r-2]} < ${this.outputShape[r-2]}) {\n          ${f}\n          result[2] = getChannel(getX(${u.join()}), ${d});\n          ${l[r-1]} += 1;\n          if(${c}) {\n            ${f}\n            result[3] = getChannel(getX(${u.join()}), ${d});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${o});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const LH={kernelName:Il,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:a}=e,o=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PH(s.shape,r,a):new OH(s.shape,r,a);return t.runWebGLProgram(o,[s],s.dtype)}},zH=rn({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),BH={kernelName:Ao,backendName:"webgl",kernelFunc:zH};class WH{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Tv=rn({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),UH={kernelName:mo,backendName:"webgl",kernelFunc:Tv},Nv="return a - b;",kv=rn({opSnippet:Nv,packedOpSnippet:Nv,supportsComplex:!0,cpuKernelImpl:fB}),GH={kernelName:qo,backendName:"webgl",kernelFunc:kv};function _v(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:a}=s,o=ze([a],r.shape),i=Iv({inputs:{x:r},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),l=Et(i.shape,o),u=ue({inputs:{x:i},backend:e,attrs:{shape:l}}),c=kv({inputs:{a:r,b:u},backend:e}),d=xv({inputs:{x:c},backend:e}),h=$c({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),p=ue({inputs:{x:h},backend:e,attrs:{shape:l}}),f=Tv({inputs:{a:d,b:p},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(p),f}const HH={kernelName:Wl,backendName:"webgl",kernelFunc:_v},qH={kernelName:Im,backendName:"webgl",kernelFunc:function jH(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:a,seed:o,normalized:i}=s,l=i?r:_v({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),d=new WH(l.shape[0],l.shape[1],a),p=e.runWebGLProgram(d,[l],"int32",[[o]]);return i||e.disposeIntermediateTensorInfo(l),p}},YH={kernelName:Tl,backendName:"webgl",kernelFunc:function ZH(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const a=e.texData.get(s.dataId),[o,i]=Xz(a.values,s.shape,s.dtype);return e.makeTensorInfo(i,s.dtype,o)}let r;return r=V().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new Cr(s.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new As(s.shape,"if (isnan(x)) return x;\n  return -x;\n"),e.runWebGLProgram(r,[s],s.dtype)}},JH=Xh,e6={kernelName:Sd,backendName:"webgl",kernelFunc:function QH(n){On("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l}=s,u=e.readSync(r.dataId),c=e.readSync(a.dataId),{selectedIndices:d}=JH(u,c,o,i,l);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}},t6=Zh,s6={kernelName:Id,backendName:"webgl",kernelFunc:function n6(n){On("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,padToMaxOutputSize:u}=s,c=e.readSync(r.dataId),d=e.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=t6(c,d,o,i,l,u);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([p]))]}},r6=Yh,o6={kernelName:Td,backendName:"webgl",kernelFunc:function a6(n){On("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:l,softNmsSigma:u}=s,c=e.readSync(r.dataId),d=e.readSync(a.dataId),h=o,p=i,f=l,g=u,{selectedIndices:m,selectedScores:y}=r6(c,d,h,p,f,g);return[e.makeTensorInfo([m.length],"int32",new Int32Array(m)),e.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class i6{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${s}),\n                      float(index == coords.y)));\n      }\n    `}}const l6={kernelName:_l,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:a,depth:o,onValue:i,offValue:l}=s,u=W(r.shape),c=new i6(u,o,i,l),d=ue({inputs:{x:r},backend:e,attrs:{shape:[u]}}),h=e.runWebGLProgram(c,[d],a);e.disposeIntermediateTensorInfo(d);const f=ue({inputs:{x:h},backend:e,attrs:{shape:[...r.shape,o]}});return e.disposeIntermediateTensorInfo(h),f}};function Oc(n){const{inputs:t,backend:e}=n,{x:s}=t;if("complex64"===s.dtype){const r=Bi({inputs:{input:s},backend:e}),a=Oc({inputs:{x:r},backend:e}),o=Rc({inputs:{input:s},backend:e}),i=Oc({inputs:{x:o},backend:e}),l=Sr({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),l}return Ui({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:e})}const u6={kernelName:jl,backendName:"webgl",kernelFunc:Oc},c6={kernelName:kl,backendName:"webgl",kernelFunc:function $v(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const r=Bi({inputs:{input:s},backend:e}),a=$v({inputs:{x:r},backend:e}),o=Rc({inputs:{input:s},backend:e}),i=Oc({inputs:{x:o},backend:e}),l=Sr({inputs:{real:a,imag:i},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),l}return Ui({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}},h6={kernelName:$l,backendName:"webgl",kernelFunc:function d6(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return tm({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const a=t[0].shape,o=t[0].dtype;t.forEach(c=>{Hn(a,c.shape,"All tensors passed to stack must have matching shapes"),I(o===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=iv({inputs:t.map(c=>{const d=tm({inputs:{input:c},backend:e,attrs:{dim:r}});return i.push(d),d}),backend:e,attrs:{axis:r}});return i.forEach(c=>e.disposeIntermediateTensorInfo(c)),u}};class p6{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((u,c)=>u[0]+t[c]+u[1]);const r=t.length,a=lt(r),o=e.map(u=>u[0]).join(","),i=e.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${o});\n      ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${l}));\n        }\n      }\n    `:`\n        int start = ${o};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class f6{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((g,m)=>g[0]+t[m]+g[1]);const r=t.length,a=lt(r),o=e.map(g=>g[0]).join(","),i=e.map((g,m)=>g[0]+t[m]).join(","),l=Cn("rc",r),u=Cn("source",r),c=`${l[r-1]} < ${this.outputShape[r-1]}`,d=1===r?"source":`vec2(${u.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${l[r-1]} += 1;\n       if(${c}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${l[r-2]} += 1;\n       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${l[r-1]} += 1;\n         if(${c}) {`],p=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let g=0,m=1===r?2:4;g<m;g++)f+=`\n        ${h[g]}\n        if (${p}) {\n          result[${g}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${g}] = getChannel(getX(${u.join()}), ${d});\n        }\n      `;f+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${o});\n      const ${a} end = ${a}(${i});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const Ev=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,constantValue:o}=s;if(0===W(r.shape))return Ui({backend:e,attrs:{shape:a.map((c,d)=>c[0]+r.shape[d]+c[1]),value:o,dtype:r.dtype}});const i=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new f6(r.shape,a,o):new p6(r.shape,a,o);return e.runWebGLProgram(i,[r],r.dtype,[[o]])},m6={kernelName:El,backendName:"webgl",kernelFunc:Ev},x6=rn({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  \n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n\n  return result;\n"}),b6={kernelName:Ro,backendName:"webgl",kernelFunc:x6},v6={kernelName:Dl,backendName:"webgl",kernelFunc:function w6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:o}=s,i=r.shape.length,l=[],u=ze(a,r.shape);let c=u;const d=St(c,i);let p,h=r;if(null!=d&&(h=Sn({inputs:{x:r},backend:e,attrs:{perm:d}}),c=At(c.length,i),l.push(h)),sn("prod",c,i),e.shouldExecuteOnCPU([h])){const f=e.texData.get(h.dataId).values,{outVals:g,outShape:m,outDtype:y}=Yz(h.shape,h.dtype,f,c);p=e.makeTensorInfo(m,y,g)}else{const[f,g]=Xt(h.shape,c),m=W(g),y=ue({inputs:{x:h},backend:e,attrs:{shape:[-1,m]}}),b=ia(y,Kd(r.dtype),"prod",e);p=ue({inputs:{x:b},backend:e,attrs:{shape:f}}),l.push(y),l.push(b)}if(o){l.push(p);const f=Et(p.shape,u);p=ue({inputs:{x:p},backend:e,attrs:{shape:f}})}return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}},S6={kernelName:Tm,backendName:"webgl",kernelFunc:function C6(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:o}=t,{outputRaggedRank:i}=s,l=r.map(y=>e.readSync(y.dataId)),u=r.map(y=>y.shape),c=e.readSync(a.dataId),d=e.readSync(o.dataId),[h,p,f]=Jz(l,u,c,a.shape,a.dtype,d,o.shape,i),g=h.map(y=>e.makeTensorInfo([y.length],"int32",y)),m=e.makeTensorInfo(f,a.dtype,p);return g.concat([m])}},T6={kernelName:Nm,backendName:"webgl",kernelFunc:function I6(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:a}=t,o=e.readSync(s.dataId),i=e.readSync(r.dataId),l=e.readSync(a.dataId),[u,c]=Qz(o,s.shape,s.dtype,i,r.shape,l,a.shape);return[e.makeTensorInfo([u.length],"int32",u),e.makeTensorInfo([c.length],s.dtype,c)]}},k6={kernelName:km,backendName:"webgl",kernelFunc:function N6(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:a,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:l}=s,u=e.readSync(r.dataId),c=e.readSync(a.dataId),d=e.readSync(o.dataId),h=i.map(m=>e.readSync(m.dataId)),p=i.map(m=>m.shape),[f,g]=eB(u,r.shape,c,a.shape,a.dtype,d,o.shape,h,p,l);return e.makeTensorInfo(f,a.dtype,g)}},Av=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:a,dtype:o}=e,i=tB(s,r,a,o);return t.makeTensorInfo([i.length],o,i)},_6={kernelName:Nd,backendName:"webgl",kernelFunc:Av},$6=Ke({opSnippet:"return 1.0 / x;"}),E6={kernelName:Fo,backendName:"webgl",kernelFunc:$6},D6=Ke({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),R6={kernelName:Oo,backendName:"webgl",kernelFunc:D6},O6=Ke({opSnippet:"if (isnan(x)) return x;\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),P6={kernelName:Po,backendName:"webgl",kernelFunc:O6};class L6{constructor(t,e,s,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?i-1:i,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class M6{constructor(t,e,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?i-1:i,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const z6={kernelName:Ol,backendName:"webgl",kernelFunc:function V6(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s,[l,u]=i,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new M6(r.shape,l,u,a,o):new L6(r.shape,l,u,a,o);return e.runWebGLProgram(c,[r],"float32")}};class B6{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,o,i]=t,l=[s&&o>1?r-1:r,s&&i>1?a-1:a],u=[s&&o>1?o-1:o,s&&i>1?i-1:i],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const U6={kernelName:$d,backendName:"webgl",kernelFunc:function W6(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:o}=s,i=new B6(a.shape,r.shape,o);return e.runWebGLProgram(i,[a],a.dtype)}};class G6{constructor(t,e,s,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?i-1:i,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let p;p=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${l}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class H6{constructor(t,e,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,l,u]=t;this.outputShape=[o,e,s,u];const c=[r&&e>1?i-1:i,r&&s>1?l-1:l],d=[r&&e>1?e-1:e,r&&s>1?s-1:s];let p;p=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${c[0]/d[0]},\n          ${c[1]/d[1]},\n          ${c[1]/d[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${l}.0,\n                                     ${l}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${p};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${u-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const q6={kernelName:Fl,backendName:"webgl",kernelFunc:function j6(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:o,size:i}=s,[l,u]=i,c=V().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new H6(r.shape,l,u,a,o):new G6(r.shape,l,u,a,o);return e.runWebGLProgram(c,[r],r.dtype)}};class K6{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,o,i]=t,l=[s&&o>1?r-1:r,s&&i>1?a-1:a],u=[s&&o>1?o-1:o,s&&i>1?i-1:i],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=2*Math.ceil(h)+2,g=2*Math.ceil(p)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${c});\n        const float widthScale = float(${d});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${p});\n\n        const int winHeight = int(${f});\n        const int winWidth = int(${g});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${o}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${l[0]}) *\n                (float(dyR) / float(${u[0]}));\n\n            float sourceFracCol =\n                float(${l[1]}) *\n                  (float(dyC) / float(${u[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${s} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${s} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const Z6={kernelName:_d,backendName:"webgl",kernelFunc:function X6(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:o}=s,i=new K6(a.shape,r.shape,o);return e.runWebGLProgram(i,[a],a.dtype)}};class Y6{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,1===s)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const a=t.map((i,l)=>(i=>-1!==e.indexOf(i)&&1!==t[i]?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`)(l)).join(","),o=lt(s);this.userCode=`\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class J6{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=Cn("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=lt(s);function h(f){const g=t.map((x,b)=>function p(f,g){return-1!==e.indexOf(f)&&1!==t[f]?`${t[f]} - ${g[f]} - 1`:`${g[f]}`}(b,f));return`getChannel(getX(${g.join(",")}), vec2(${g.slice(-2).join(",")}))`}this.userCode=1===s?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function l(f){return h(f)}(r.slice())};\n          if(${a}){\n            result.g = ${function u(f){return f[s-1]="("+f[s-1]+" + 1)",h(f)}(r.slice())};\n          }\n          if(${o}) {\n            result.b = ${function c(f){return f[s-2]="("+f[s-2]+" + 1)",h(f)}(r.slice())};\n            if(${a}) {\n              result.a = ${function d(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",h(f)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const ej={kernelName:Pl,backendName:"webgl",kernelFunc:function Q6(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:a}=s,o=r.shape.length,i=ze(a,r.shape);if(0===o)return Fn({inputs:{x:r},backend:e});const l=V().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new J6(r.shape,i):new Y6(r.shape,i);return e.runWebGLProgram(l,[r],r.dtype)}};class tj{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let a="";a="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const nj={kernelName:Wd,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:a,center:o}=t,i=e,l=new tj(s.shape,a),[u,c]=rp(o,s.shape[1],s.shape[2]),d=[[u,c,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(l,[s],s.dtype,d)}},sj=Ke({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),rj={kernelName:Lo,backendName:"webgl",kernelFunc:sj},aj=Ke({opSnippet:"return inversesqrt(x);",cpuKernelImpl:nB}),oj={kernelName:Mo,backendName:"webgl",kernelFunc:aj};class sm{constructor(t,e,s,r,a,o,i=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const u=lt(a.length),c=lt(o.length);let d="";1===s?d="i":2===s&&(d="i, j");let p="";1===r?p="i":2===r&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${a});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${d}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${p});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, float(found)));\n        }\n      `}}class ij{constructor(t,e,s,r,a,o,i=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const u=lt(a.length),c=lt(o.length);let d="";1===s?d="i":2===s&&(d="i, j");let p="";1===r?p="i":2===r&&(p="i, coords[1]");let g="";l&&(g="coords[0], coords[1]"),this.userCode=`\n        ${u} strides = ${u}(${a});\n\n        void main() {\n          ${c} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${d}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${p});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${g}), sum, found));\n        }\n      `}}const uj={kernelName:_m,backendName:"webgl",kernelFunc:function lj(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:a}=t,{shape:o}=s,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=jr(0,r,o),h=[d/u,u];if(0===d)return e.makeTensorInfo(o,r.dtype);const p=ue({inputs:{x:r},backend:e,attrs:{shape:[l,i]}}),f=ue({inputs:{x:a},backend:e,attrs:{shape:[l,u]}}),g=e.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=V().getBool("WEBGL_PACK")?new ij(l,i,p.shape.length,f.shape.length,c,h):new sm(l,i,p.shape.length,f.shape.length,c,h);const y=e.runWebGLProgram(m,[f,p,g],f.dtype),x=ue({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),x}};class cj{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,i=2===V().getNumber("WEBGL_VERSION")?"while (left < right) {":o;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const hj={kernelName:Em,backendName:"webgl",kernelFunc:function dj(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:a}=t,{side:o}=s,i=new cj(r.shape[0],r.shape[1],a.shape[1],o);return e.runWebGLProgram(i,[r,a],"int32",[[r.shape[1]]])}};class pj{constructor(t,e,s){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=e,s>4)throw Error(`Where for rank ${s} is not yet supported`);if(1===s)a="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<e.length;c++)u.push(`${i[c]}`),c<t&&l.push(`${i[c]}`);r=l.join(),a=u.join()}const o=lt(s);this.userCode=`\n      void main() {\n        ${o} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const mj={kernelName:Ll,backendName:"webgl",kernelFunc:function fj(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:a}=t,o=new pj(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(o,[s,r,a],An(r.dtype,a.dtype))}},yj=Ke({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${ku};\n  float scale = ${_u};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),xj={kernelName:Vo,backendName:"webgl",kernelFunc:yj},wj=Ke({opSnippet:"if (isnan(x)) return x;\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:rB}),vj={kernelName:Uo,backendName:"webgl",kernelFunc:wj},Cj=Ke({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),Sj={kernelName:Wo,backendName:"webgl",kernelFunc:Cj},Nj=Ke({opSnippet:"if (isnan(x)) return x;\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${oa}\n  return result;\n`}),kj={kernelName:zo,backendName:"webgl",kernelFunc:Nj},_j=Ke({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),$j={kernelName:Bo,backendName:"webgl",kernelFunc:_j},Ej=Ke({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),Aj={kernelName:Go,backendName:"webgl",kernelFunc:Ej},Dj={kernelName:zl,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,paddings:o}=s;I(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((y,x)=>y*x),l=[[0,0]];l.push(...o);for(let y=1+a.length;y<r.shape.length;++y)l.push([0,0]);const u=[],c=Ev({inputs:{x:r},backend:e,attrs:{paddings:l,constantValue:0}}),d=gi(c.shape,a,i,!1),h=yi(d.length,a.length,!1),p=xi(c.shape,a,i,!1),f=ue({inputs:{x:c},backend:e,attrs:{shape:d}}),g=Sn({inputs:{x:f},backend:e,attrs:{perm:h}}),m=ue({inputs:{x:g},backend:e,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}},Fj={kernelName:Ed,backendName:"webgl",kernelFunc:function Rj(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:a,defaultValue:o}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==o.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${o.shape}`);const i=e.readSync(s.dataId),l=e.readSync(r.dataId),u=e.readSync(a.dataId),c=e.readSync(o.dataId)[0],[d,h,p,f,g]=oB(i,s.shape,s.dtype,l,r.dtype,u,c);return[e.makeTensorInfo(h,s.dtype,d),e.makeTensorInfo([h[0]],r.dtype,p),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),e.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}},Pj={kernelName:Ad,backendName:"webgl",kernelFunc:function Oj(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(e.readSync(r.dataId)),i=e.readSync(s.dataId),l=Array.from(e.readSync(a.dataId)),[u,c,d]=iB(i,s.shape,s.dtype,o,l);return[e.makeTensorInfo(c,s.dtype,u),e.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},Mj={kernelName:Dd,backendName:"webgl",kernelFunc:function Lj(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const o=e.readSync(s.dataId),i=e.readSync(r.dataId),l=e.readSync(a.dataId),[u,c]=P1(o,s.shape,s.dtype,i,l,!0);return e.makeTensorInfo(c,s.dtype,u)}},zj={kernelName:Rd,backendName:"webgl",kernelFunc:function Vj(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const o=e.readSync(s.dataId),i=e.readSync(r.dataId),l=e.readSync(a.dataId),[u,c]=P1(o,s.shape,s.dtype,i,l);return e.makeTensorInfo(c,s.dtype,u)}},Wj={kernelName:Am,backendName:"webgl",kernelFunc:function Bj(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:o}=t,{outputShape:i}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=jr(0,r,i);if("string"===a.dtype){const y=e.bufferSync(r),x=e.bufferSync(a),b=nr(e.readSync(o.dataId)[0]),w=sB(y,x,i,h,c,u,l,d,b,!1);return e.makeTensorInfo(i,w.dtype,w.values)}const f=new sm(u,l,r.shape.length,a.shape.length,d,[h,1],!1),g=e.runWebGLProgram(f,[a,r,o],a.dtype),m=ue({inputs:{x:g},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(g),m}},Gj={kernelName:Bl,backendName:"webgl",kernelFunc:function Uj(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:a,axis:o}=s,i=ze(o,r.shape)[0],l=vp(r,a,i),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return l.map(h=>{const p=[...d];p[i]=h;const f=Ya({inputs:{x:r},backend:e,attrs:{begin:c,size:p}});return c[i]+=h,f})}},Dv="return sqrt(x);",Hj=Ke({opSnippet:Dv,packedOpSnippet:Dv,cpuKernelImpl:lB}),jj={kernelName:Ho,backendName:"webgl",kernelFunc:Hj},Kj={kernelName:Fd,backendName:"webgl",kernelFunc:Ke({opSnippet:"return x * x;"})},Rv="return (a - b) * (a - b);",Xj=rn({opSnippet:Rv,packedOpSnippet:Rv}),Zj={kernelName:jo,backendName:"webgl",kernelFunc:Xj},Jj={kernelName:Ul,backendName:"webgl",kernelFunc:function Yj(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const o=Hs(e.readSync(r.dataId)),i=uB(o,"string",s);return e.makeTensorInfo(r.shape,"string",i)}},eq={kernelName:Yo,backendName:"webgl",kernelFunc:function Qj({inputs:n,attrs:t,backend:e}){const{x:s}=n,a=new As(s.shape,`if (isnan(x)) return x;\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(a,[s],s.dtype)}};class tq{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=lt(s.length),o=lt(s.length);let i="";if(1===r)i="coords * strides + begin";else{let l=0;i=s.map((u,c)=>(l++,1===s.length?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`\n      ${a} begin = ${a}(${t});\n      ${a} strides = ${a}(${e});\n\n      void main() {\n        ${o} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const sq={kernelName:Od,backendName:"webgl",kernelFunc:function nq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,end:o,strides:i,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:y,begin:x,end:b,strides:w}=Ih(r.shape,a,o,i,l,u,c,d,h);let C;if(g)C=ue({inputs:{x:r},backend:e,attrs:{shape:f}});else if(m||y){I(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const T=vh(x,b,w),k=Ya({inputs:{x:r},backend:e,attrs:{begin:x,size:T}});C=ue({inputs:{x:k},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(k)}else if(e.shouldExecuteOnCPU([r])){const k=e.readSync(r.dataId),$=Be(r.shape,r.dtype,k),E=cB(p,$,w,x);C=e.makeTensorInfo(f,r.dtype,E.values)}else{const k=new tq(x,w,p);C=e.runWebGLProgram(k,[r],r.dtype)}const S=ue({inputs:{x:C},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(C),S}},aq={kernelName:Pd,backendName:"webgl",kernelFunc:function rq(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:d}=t,h=e.readSync(c.dataId),p=e.readSync(d.dataId),[f,g]=dB(h,p,r,a,o,i,l,u);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(d.shape,"int32",g)]}},iq={kernelName:Ld,backendName:"webgl",kernelFunc:function oq(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:o}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==o.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=e.readSync(a.dataId),l=e.readSync(o.dataId)[0],[u,c,d]=hB(i,l,r),h=c.length;return[e.makeTensorInfo([h,2],"int32",u),e.makeTensorInfo([h],"string",c),e.makeTensorInfo([2],"int32",new Int32Array(d))]}},uq={kernelName:Md,backendName:"webgl",kernelFunc:function lq(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(a.dataId),i=pB(o,r);return e.makeTensorInfo(a.shape,"int32",i)}},cq=Ke({opSnippet:"return tan(x);"}),dq={kernelName:Ko,backendName:"webgl",kernelFunc:cq},hq=Ke({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),pq={kernelName:Xo,backendName:"webgl",kernelFunc:hq},mq={kernelName:$m,backendName:"webgl",kernelFunc:function fq(n){const{inputs:t,backend:e}=n,{tensor:r,indices:a,updates:o}=t,{sliceRank:i,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=jr(0,a,r.shape),h=[d/u,u];if(0===d)return e.makeTensorInfo(r.shape,a.dtype);const p=ue({inputs:{x:a},backend:e,attrs:{shape:[l,i]}}),f=ue({inputs:{x:o},backend:e,attrs:{shape:[l,u]}}),g=ue({inputs:{x:r},backend:e,attrs:{shape:h}}),m=new sm(l,i,p.shape.length,f.shape.length,c,h,!1,!0),y=e.runWebGLProgram(m,[f,p,g],g.dtype),x=ue({inputs:{x:y},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(y),x}};class gq{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let o=0;o<s.length;o++)s[o]=t[o]*e[o];this.outputShape=s,this.rank=s.length;const r=lt(this.rank),a=function yq(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function Fv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:a}=s;if("string"===r.dtype||r.shape.length>5){const l=e.readSync(r.dataId),u="string"===r.dtype?l.map(h=>nr(h)):l,c=Be(r.shape,r.dtype,u),d=mB(c,a);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new gq(r.shape,a);return e.runWebGLProgram(o,[r],r.dtype)}const xq={kernelName:Zo,backendName:"webgl",kernelFunc:Fv};class bq{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class wq{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function la(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function Ov(n){let t=1;for(;t<n;)t*=2;return t}const Cq={kernelName:Vd,backendName:"webgl",kernelFunc:function vq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:a,sorted:o}=s,i=V().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=V().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(e.shouldExecuteOnCPU([r])||c<i||a>l){const E=e.readSync(r.dataId),[P,z]=gB(E,u,r.dtype,a,o);return[e.makeTensorInfo(P.shape,P.dtype,P.values),e.makeTensorInfo(z.shape,z.dtype,z.values)]}if(0===a)return u[u.length-1]=0,[e.makeTensorInfo(u,r.dtype,[]),e.makeTensorInfo(u,"int32",[])];if(1===c)return[r,Ui({attrs:{shape:u,dtype:"int32",value:0},backend:e})];const d=e.texData.get(r.dataId),h=null!==d&&d.isPacked,p=h?e.unpackTensor(r):r,g=W(u)/c,m=ue({inputs:{x:p},attrs:{shape:[g,c]},backend:e});h&&la(e,p);const y=Ov(a),x=Ov(c);let b=null;const w=()=>null===b?[m,m]:[m,b],C=(E,P,z)=>{const B=w(),U=new bq(z),K=b;b=e.runWebGLProgram(U,B,"int32",[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[E],[P]]),la(e,K)};for(let E=1;E<y;E*=2){const P=2*E;for(let z=E;z>=1;z/=2)C(P,z,[g,x])}for(let E=x;E>y;E/=2){const P=w(),z=new wq([g,E/2]),G=b;b=e.runWebGLProgram(z,P,"int32",[[c],[null===b?1:0],[y]]),la(e,G);const q=y/2,K=2*q;for(let H=q;H>=1;H/=2)C(K,H,b.shape)}let S=b;b=Ya({inputs:{x:b},backend:e,attrs:{begin:0,size:[g,a]}}),la(e,S);let T=Sv({inputs:{x:m,indices:b},backend:e,attrs:{axis:1,batchDims:1}});la(e,m);const k=u.slice(0,-1);k.push(a),S=b,b=ue({inputs:{x:b},attrs:{shape:k},backend:e}),la(e,S);const $=T;return T=ue({inputs:{x:T},attrs:{shape:k},backend:e}),la(e,$),[T,b]}};class Sq{constructor(t,e,s,r,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i="nearest"===s?1:2;let l;switch(r){case"constant":default:l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${l} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${l} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Tq={kernelName:zd,backendName:"webgl",kernelFunc:function Iq(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:a}=t,{interpolation:o,fillMode:i,fillValue:l,outputShape:u}=s,[c,d,h,p]=r.shape,[f,g]=null!=u?u:[d,h],y=new Sq(d,h,o,i,l,[c,f,g,p]);return e.runWebGLProgram(y,[r,a],"float32")}},kq={kernelName:Bd,backendName:"webgl",kernelFunc:function Nq(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:a}=t;Li(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(a.dataId),{outputValues:i,outputShape:l,indices:u}=yB(o,r,a.shape,a.dtype);return[s.makeTensorInfo(l,a.dtype,i),s.makeTensorInfo([u.length],"int32",u)]}},$q={kernelName:Gl,backendName:"webgl",kernelFunc:function _q(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r,i=o.shape.length,l=r.shape[a],u=new Array(i-1);let c=0;for(let g=0;g<i;g++)g!==a&&(u[c++]=o.shape[g]);const d=[],h=new Array(i).fill(0),p=o.shape.slice();p[a]=1;const f=new Array(l);for(let g=0;g<f.length;g++){h[a]=g;const m=Ya({inputs:{x:o},backend:e,attrs:{begin:h,size:p}}),y=ue({inputs:{x:m},backend:e,attrs:{shape:u}});f[g]=y,d.push(m)}return d.forEach(g=>e.disposeIntermediateTensorInfo(g)),f}};class Eq{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,a=t.inSize,o=t.numSegments,i=o*Math.ceil(a/s);this.outputShape=[r,i];const c=4*Math.floor(s/4),d=s%4,h="\n        sumValue += dot(values, segFilter);\n    ";let p="";a%s>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let f="";a%s>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${f}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${o})) * float(${s}));\n        int currentSeg = int(mod(float(outIdx), float(${o})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${c}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${c};\n        if (${1===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===d}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Rq=[dW,pW,gW,bW,vW,IW,NW,_W,DW,FW,LW,zW,UW,qW,ZW,JW,e4,r4,o4,l4,d4,y4,b4,S4,T4,E4,D4,P4,KB,V4,G4,K4,eU,sU,aU,iU,uU,pU,mU,yU,bU,vU,SU,NU,_U,DU,FU,LU,zU,WU,GU,qU,XU,JU,eG,tG,sG,aG,iG,uG,dG,pG,gG,bG,vG,IG,kG,$G,AG,qB,RG,W4,OG,LG,VG,ZB,BG,UG,HG,KG,YG,QG,tH,sH,oH,lH,cH,fH,gH,xH,CH,IH,NH,_H,EH,FH,LH,BH,qH,QB,YH,e6,s6,o6,N4,l6,c6,h6,m6,b6,JB,v6,S6,T6,k6,_6,k4,UH,E6,R6,P6,tW,z6,U6,q6,Z6,ej,nj,rj,oj,uj,hj,mj,xj,vj,Sj,kj,$j,g4,HH,Aj,Dj,Fj,Pj,Mj,zj,Wj,Gj,jj,Kj,Zj,Jj,eq,sq,aq,iq,uq,GH,lW,dq,pq,mq,xq,Cq,Tq,uW,kq,$q,{kernelName:Hl,backendName:"webgl",kernelFunc:function Aq(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:a}=t,{numSegments:o}=s,i=r.shape.length,l=[];let u=0;const c=St([u],i);let d=r;null!=c&&(d=Sn({inputs:{x:r},backend:e,attrs:{perm:c}}),l.push(d),u=At(1,i)[0]);const h=By(d.shape,u,o),p=W([d.shape[u]]),f=ue({inputs:{x:d},backend:e,attrs:{shape:[-1,p]}});l.push(f);const g=Kd(r.dtype),m=(w,C,S,T,k)=>{const $=w.shape[0],E=w.shape[1],P=zy(E,k),B=new Eq({windowSize:P,inSize:E,batchSize:$,numSegments:k},C),U=e.compileAndRun(B,[w,S],T);if(l.push(U),U.shape[1]===k)return U;const G=Av({backend:e,attrs:{start:0,stop:k,step:1,dtype:"float32"}}),q=Fv({inputs:{x:G},backend:e,attrs:{reps:[E/P]}});return l.push(G),l.push(q),m(U,C,q,T,k)},x=ue({inputs:{x:m(f,"unsortedSegmentSum",a,g,o)},backend:e,attrs:{shape:h}});let b=x;if(null!=c){l.push(x);const w=ur(c);b=Sn({inputs:{x:b},backend:e,attrs:{perm:w}})}return l.forEach(w=>e.disposeIntermediateTensorInfo(w)),b}},u6];for(const n of Rq)Gd(n);class Pv{constructor(){this.model=function tD(n){return new sb(n)}(),this.normalizer={}}trainModel(t){var e=this;return Z(function*(){const s=t.map(l=>e.extractFeatures(l)),r=t.map(l=>l.value);e.computeNormalization(s);const a=e.normalizeFeatures(s),o=_a(a),i=xn(r);e.model.add(bf({units:32,activation:"relu",inputShape:[a[0].length]})),e.model.add(bf({units:16,activation:"relu"})),e.model.add(bf({units:1})),e.model.compile({optimizer:Hr.adam(),loss:"meanSquaredError"}),yield e.model.fit(o,i,{epochs:200,validationSplit:.2,callbacks:{onEpochEnd:(l,u)=>{console.log(`Epoch ${l}: loss = ${null==u?void 0:u.loss}`)}}})})()}predictCost(t){const e=this.extractFeatures(t),s=this.normalizeFeatures([e]),r=this.model.predict(_a(s));return Math.round(r.dataSync()[0])}extractFeatures(t){var e,s,r,a,o,i,l,u,c,d,h,p,f;const g=["Hero"===(null===(e=t.stats)||void 0===e?void 0:e.type)?1:0,"Caster"===t.type?1:0,"Leader"===t.type?1:0,(null===(s=t.stats)||void 0===s?void 0:s.shield)?1:0,(null===(a=null===(r=t.stats)||void 0===r?void 0:r.skills)||void 0===a?void 0:a.length)||0,(null===(o=t.stats)||void 0===o?void 0:o.armor)||0,(null===(i=t.stats)||void 0===i?void 0:i.discipline)||0,(null===(l=t.stats)||void 0===l?void 0:l.speed)||0,(null===(u=t.stats)||void 0===u?void 0:u.casting)?1:0,(null===(c=t.stats)||void 0===c?void 0:c.performance)?1:0,(null===(d=t.stats)||void 0===d?void 0:d.focus)?1:0,(null===(h=t.stats)||void 0===h?void 0:h.melee)?t.stats.melee.reduce((y,x)=>y+x.rating+x.damage,0):0,(null===(p=t.stats)||void 0===p?void 0:p.range)?t.stats.range.reduce((y,x)=>y+x.rating*(1+x.distance/12)+x.damage,0):0],m=(null===(f=t.stats)||void 0===f?void 0:f.abilities)||{};return g.push(m.strength||0,m.agility||0,m.dexterity||0,m.endurance||0,m.knowledge||0,m.spirit||0),[..._r.sh,..._r.Mu].forEach(y=>{var x,b;g.push((null===(b=null===(x=t.stats)||void 0===x?void 0:x.talents)||void 0===b?void 0:b.map(w=>w.split("[")[0]).reduce((w,C)=>y.split("[")[0]===C?w+1:w,0))||0)}),g}computeNormalization(t){for(let e=0;e<t[0].length;e++){const s=t.map(o=>o[e]),r=s.reduce((o,i)=>o+i)/s.length,a=Math.sqrt(s.reduce((o,i)=>o+Math.pow(i-r,2),0)/s.length);this.normalizer[e]={mean:r,std:a}}}normalizeFeatures(t){return t.map(e=>e.map((s,r)=>(s-this.normalizer[r].mean)/(this.normalizer[r].std||1)))}}var Lv=J(9134);function Oq(n,t){if(1&n&&(v.TgZ(0,"div",3),v._UZ(1,"mat-progress-spinner",4),v.TgZ(2,"div",5),v._uU(3),v.qZA()()),2&n){const e=v.oxw();v.xp6(3),v.hij(" ",e.currentLoadingText," ")}}function Pq(n,t){if(1&n&&(v.TgZ(0,"mat-option",46),v._uU(1),v.qZA()),2&n){const e=t.$implicit;v.Q6J("value",e),v.xp6(1),v.hij(" ",e.name," ")}}function Lq(n,t){if(1&n){const e=v.EpF();v.TgZ(0,"div",44)(1,"mat-form-field")(2,"mat-label"),v._uU(3,"Select Weapon"),v.qZA(),v.TgZ(4,"mat-select",45)(5,"mat-option",46),v._uU(6,"Select Weapon"),v.qZA(),v.YNc(7,Pq,2,2,"mat-option",25),v.qZA()(),v.TgZ(8,"mat-form-field")(9,"mat-label"),v._uU(10,"Rating"),v.qZA(),v._UZ(11,"input",47),v.qZA(),v.TgZ(12,"button",48),v.NdJ("click",function(){const a=v.CHM(e).index;return v.oxw(2).removeWeapon("melee",a)}),v.TgZ(13,"mat-icon"),v._uU(14,"delete"),v.qZA()()()}if(2&n){const e=t.index,s=v.oxw(2);v.Q6J("formGroupName",e),v.xp6(5),v.Q6J("value",null),v.xp6(2),v.Q6J("ngForOf",s.meleeWeapons)}}function Mq(n,t){if(1&n&&(v.TgZ(0,"mat-option",46),v._uU(1),v.qZA()),2&n){const e=t.$implicit;v.Q6J("value",e),v.xp6(1),v.hij(" ",e.name," ")}}function Vq(n,t){if(1&n){const e=v.EpF();v.TgZ(0,"div",44)(1,"mat-form-field")(2,"mat-label"),v._uU(3,"Select Weapon"),v.qZA(),v.TgZ(4,"mat-select",45)(5,"mat-option",46),v._uU(6,"Select Weapon"),v.qZA(),v.YNc(7,Mq,2,2,"mat-option",25),v.qZA()(),v.TgZ(8,"mat-form-field")(9,"mat-label"),v._uU(10,"Rating"),v.qZA(),v._UZ(11,"input",47),v.qZA(),v.TgZ(12,"button",48),v.NdJ("click",function(){const a=v.CHM(e).index;return v.oxw(2).removeWeapon("range",a)}),v.TgZ(13,"mat-icon"),v._uU(14,"delete"),v.qZA()()()}if(2&n){const e=t.index,s=v.oxw(2);v.Q6J("formGroupName",e),v.xp6(5),v.Q6J("value",null),v.xp6(2),v.Q6J("ngForOf",s.rangeWeapons)}}function zq(n,t){if(1&n&&(v.TgZ(0,"mat-option",46),v._uU(1),v.qZA()),2&n){const e=t.$implicit;v.Q6J("value",e),v.xp6(1),v.hij(" ",e," ")}}function Bq(n,t){if(1&n){const e=v.EpF();v.TgZ(0,"div",49)(1,"mat-form-field")(2,"mat-label"),v._uU(3,"Select Talent"),v.qZA(),v.TgZ(4,"mat-select",50)(5,"mat-option",46),v._uU(6,"Select Talent"),v.qZA(),v.YNc(7,zq,2,2,"mat-option",25),v.qZA()(),v.TgZ(8,"button",48),v.NdJ("click",function(){const a=v.CHM(e).index;return v.oxw(2).removeTalent(a)}),v.TgZ(9,"mat-icon"),v._uU(10,"delete"),v.qZA()()()}if(2&n){const e=t.index,s=v.oxw(2);v.xp6(4),v.Q6J("formControlName",e),v.xp6(1),v.Q6J("value",null),v.xp6(2),v.Q6J("ngForOf",s.talents)}}function Wq(n,t){if(1&n&&(v.TgZ(0,"mat-option",46),v._uU(1),v.qZA()),2&n){const e=t.$implicit;v.Q6J("value",e),v.xp6(1),v.Oqu(e)}}function Uq(n,t){if(1&n&&(v.TgZ(0,"mat-card",51)(1,"mat-card-content")(2,"h3",52),v._uU(3),v.qZA()()()),2&n){const e=v.oxw(2);v.xp6(3),v.hij("Predicted Cost: ",e.predictedCost,"")}}function Gq(n,t){if(1&n){const e=v.EpF();v.TgZ(0,"form",6)(1,"h2",7),v._uU(2,"Character Builder"),v.qZA(),v.TgZ(3,"div",8)(4,"mat-form-field")(5,"mat-label"),v._uU(6,"Character Type"),v.qZA(),v.TgZ(7,"mat-select",9),v.NdJ("selectionChange",function(r){return v.CHM(e),v.oxw().onTypeChange(r)}),v.TgZ(8,"mat-option",10),v._uU(9,"Standard"),v.qZA(),v.TgZ(10,"mat-option",11),v._uU(11,"Leader"),v.qZA(),v.TgZ(12,"mat-option",12),v._uU(13,"Caster"),v.qZA()()()(),v.TgZ(14,"div",13)(15,"mat-form-field")(16,"mat-label"),v._uU(17,"Model Type"),v.qZA(),v.TgZ(18,"mat-select",14),v.NdJ("selectionChange",function(r){return v.CHM(e),v.oxw().onModelTypeChange(r)}),v.TgZ(19,"mat-option",15),v._uU(20,"Follower"),v.qZA(),v.TgZ(21,"mat-option",16),v._uU(22,"Hero"),v.qZA()()(),v.TgZ(23,"h3",17),v._uU(24,"Melee Weapons"),v.qZA(),v.TgZ(25,"div",18)(26,"button",19),v.NdJ("click",function(){return v.CHM(e),v.oxw().addWeapon("melee")}),v.TgZ(27,"mat-icon"),v._uU(28,"add"),v.qZA(),v._uU(29," Add Weapon "),v.qZA(),v.YNc(30,Lq,15,3,"div",20),v.qZA(),v.TgZ(31,"h3",17),v._uU(32,"Ranged Weapons"),v.qZA(),v.TgZ(33,"div",21)(34,"button",19),v.NdJ("click",function(){return v.CHM(e),v.oxw().addWeapon("range")}),v.TgZ(35,"mat-icon"),v._uU(36,"add"),v.qZA(),v._uU(37," Add Weapon "),v.qZA(),v.YNc(38,Vq,15,3,"div",20),v.qZA(),v.TgZ(39,"h3",17),v._uU(40,"Talents"),v.qZA(),v.TgZ(41,"div",22)(42,"button",19),v.NdJ("click",function(){return v.CHM(e),v.oxw().addTalent()}),v.TgZ(43,"mat-icon"),v._uU(44,"add"),v.qZA(),v._uU(45," Add Talent "),v.qZA(),v.YNc(46,Bq,11,3,"div",23),v.qZA(),v.TgZ(47,"h3",17),v._uU(48,"Skills"),v.qZA(),v.TgZ(49,"mat-form-field")(50,"mat-label"),v._uU(51,"Skills"),v.qZA(),v.TgZ(52,"mat-select",24),v.YNc(53,Wq,2,2,"mat-option",25),v.qZA()(),v.TgZ(54,"div",26)(55,"h3",17),v._uU(56,"Abilities"),v.qZA(),v.TgZ(57,"div",27)(58,"mat-form-field")(59,"mat-label"),v._uU(60,"Strength"),v.qZA(),v._UZ(61,"input",28),v.qZA(),v.TgZ(62,"mat-form-field")(63,"mat-label"),v._uU(64,"Agility"),v.qZA(),v._UZ(65,"input",29),v.qZA(),v.TgZ(66,"mat-form-field")(67,"mat-label"),v._uU(68,"Dexterity"),v.qZA(),v._UZ(69,"input",30),v.qZA(),v.TgZ(70,"mat-form-field")(71,"mat-label"),v._uU(72,"Endurance"),v.qZA(),v._UZ(73,"input",31),v.qZA(),v.TgZ(74,"mat-form-field")(75,"mat-label"),v._uU(76,"Knowledge"),v.qZA(),v._UZ(77,"input",32),v.qZA(),v.TgZ(78,"mat-form-field")(79,"mat-label"),v._uU(80,"Spirit"),v.qZA(),v._UZ(81,"input",33),v.qZA()()(),v.TgZ(82,"div",34)(83,"h3",17),v._uU(84,"Other"),v.qZA(),v.TgZ(85,"mat-form-field")(86,"mat-label"),v._uU(87,"Armor"),v.qZA(),v._UZ(88,"input",35),v.qZA(),v.TgZ(89,"mat-form-field")(90,"mat-label"),v._uU(91,"Discipline"),v.qZA(),v._UZ(92,"input",36),v.qZA(),v.TgZ(93,"mat-form-field")(94,"mat-label"),v._uU(95,"Speed"),v.qZA(),v._UZ(96,"input",37),v.qZA(),v.TgZ(97,"mat-checkbox",38),v._uU(98,"Shield"),v.qZA(),v.TgZ(99,"mat-checkbox",39),v._uU(100,"Magic"),v.qZA(),v.TgZ(101,"mat-checkbox",40),v._uU(102,"Performer"),v.qZA(),v.TgZ(103,"mat-checkbox",41),v._uU(104,"Pure Monk"),v.qZA()()(),v.TgZ(105,"button",42),v.NdJ("click",function(){return v.CHM(e),v.oxw().predictCost()}),v.TgZ(106,"mat-icon"),v._uU(107,"calculate"),v.qZA(),v._uU(108," Predict Cost "),v.qZA(),v.YNc(109,Uq,4,1,"mat-card",43),v.qZA()}if(2&n){const e=v.oxw();v.Q6J("formGroup",e.characterForm),v.xp6(18),v.Q6J("disabled",e.isModelTypeDisabled()),v.xp6(12),v.Q6J("ngForOf",e.melee.controls),v.xp6(8),v.Q6J("ngForOf",e.range.controls),v.xp6(8),v.Q6J("ngForOf",e.talent.controls),v.xp6(7),v.Q6J("ngForOf",e.skills),v.xp6(56),v.Q6J("ngIf",null!==e.predictedCost)}}const Hq=[{path:"",component:(()=>{class n{constructor(e,s,r){this.fb=e,this.costPredictor=s,this.modelSelector=r,this.predictedCost=null,this.meleeWeapons=_r.vx,this.rangeWeapons=_r.iR,this.talents=[..._r.sh,..._r.Mu].sort(),this.skills=_r.nA,this.trainingDone=!1,this.currentLoadingText="",this.loadingTexts=["Spike and win!","Sharpening the blades...","Restringing the bows...","Polishing the armor...","Counting the gold coins...","Feeding the warbeasts...","Readying the freeband...","Preparing the ritual...","Securing the camp...","Tuning the instruments...","Studying the maps...","Scouting the battlefield...","The Gaal must be crazy...","Tarch!"],this.currentIndex=0,this.characterForm=this.fb.group({type:["Standard"],stats:this.fb.group({type:["Hero"],armor:[2],discipline:[8],speed:[5],shield:[!1],casting:[!1],performance:[!1],focus:[!1],melee:this.fb.array([this.fb.group({weapon:"",rating:[8]})]),range:this.fb.array([]),talents:this.fb.array([]),skills:[[]],abilities:this.fb.group({strength:[8],agility:[8],dexterity:[8],endurance:[8],knowledge:[8],spirit:[8]})})})}ngOnInit(){var e=this;return Z(function*(){e.rotateLoadingText();const s=qv.k.map(r=>(r.stats=Object.assign(r.stats,e.modelSelector.calculateStats(r.stats,r.value)),r));yield e.costPredictor.trainModel(s),e.trainingDone=!0,e.textInterval&&clearInterval(e.textInterval)})()}ngOnDestroy(){this.textInterval&&clearInterval(this.textInterval)}get melee(){return this.characterForm.get("stats.melee")}get range(){return this.characterForm.get("stats.range")}get talent(){return this.characterForm.get("stats.talents")}onTypeChange(e){var s,r,a,o;const i=e.value;"Leader"===i||"Caster"===i?(null===(s=this.characterForm.get("stats.type"))||void 0===s||s.setValue("Hero"),null===(r=this.characterForm.get("stats.type"))||void 0===r||r.disable(),this.setAbilitiesForModelType("Hero"),"Leader"===i&&!this.talent.value.includes("Leader")&&this.talent.push(this.fb.control("Leader")),"Caster"===i&&(null===(a=this.characterForm.get("stats.casting"))||void 0===a||a.setValue(!0))):null===(o=this.characterForm.get("stats.type"))||void 0===o||o.enable()}onModelTypeChange(e){this.setAbilitiesForModelType(e.value)}setAbilitiesForModelType(e){const s="Hero"===e?8:6,r=this.characterForm.get("stats.abilities");r&&Object.keys(r.value).forEach(a=>{var o;null===(o=r.get(a))||void 0===o||o.setValue(s)})}isModelTypeDisabled(){var e;const s=null===(e=this.characterForm.get("type"))||void 0===e?void 0:e.value;return"Leader"===s||"Caster"===s}predictCost(){const e=this.characterForm.value;e.stats.melee=e.stats.melee.map(s=>({name:s.weapon.name,damage:s.weapon.damage,rating:s.rating})),e.stats.range=e.stats.range.map(s=>({name:s.weapon.name,damage:s.weapon.damage,rating:s.rating,distance:s.weapon.distance})),console.log("Character Data:",e),this.predictedCost=this.costPredictor.predictCost(e)}addWeapon(e){this.characterForm.get(`stats.${e}`).push(this.fb.group({weapon:"",rating:[8]}))}removeWeapon(e,s){this.characterForm.get(`stats.${e}`).removeAt(s)}addTalent(){this.talent.push(this.fb.control(""))}removeTalent(e){this.talent.removeAt(e)}rotateLoadingText(){this.loadingTexts=this.loadingTexts.sort(()=>Math.random()-.5),this.currentLoadingText=this.loadingTexts[0],this.textInterval=setInterval(()=>{this.currentIndex=(this.currentIndex+1)%this.loadingTexts.length,this.currentLoadingText=this.loadingTexts[this.currentIndex]},3e3)}}return n.\u0275fac=function(e){return new(e||n)(v.Y36(_e.qu),v.Y36(Pv),v.Y36(Lv.q))},n.\u0275cmp=v.Xpm({type:n,selectors:[["app-custom-model"]],decls:3,vars:2,consts:[["id","custommodel"],["class","loading-container",4,"ngIf"],["class","form-container",3,"formGroup",4,"ngIf"],[1,"loading-container"],["mode","indeterminate"],[1,"loading-text"],[1,"form-container",3,"formGroup"],[1,"mat-headline-4"],[1,"form-section"],["formControlName","type",3,"selectionChange"],["value","Standard"],["value","Leader"],["value","Caster"],["formGroupName","stats",1,"form-section"],["formControlName","type",3,"disabled","selectionChange"],["value","Follower"],["value","Hero"],[1,"mat-subtitle-1"],["formArrayName","melee",1,"weapon-selections"],["mat-raised-button","","type","button",1,"mat-accent",2,"margin-bottom","1em",3,"click"],["class","weapon-rating-pair",3,"formGroupName",4,"ngFor","ngForOf"],["formArrayName","range",1,"weapon-selections"],["formArrayName","talents",1,"talent-selections"],["class","talent-selection",4,"ngFor","ngForOf"],["multiple","","formControlName","skills"],[3,"value",4,"ngFor","ngForOf"],["formGroupName","abilities",1,"abilities"],[1,"ability-inputs"],["matInput","","type","number","formControlName","strength","min","0","step","2"],["matInput","","type","number","formControlName","agility","min","0","step","2"],["matInput","","type","number","formControlName","dexterity","min","0","step","2"],["matInput","","type","number","formControlName","endurance","min","0","step","2"],["matInput","","type","number","formControlName","knowledge","min","0","step","2"],["matInput","","type","number","formControlName","spirit","min","0","step","2"],[1,"stats"],["matInput","","type","number","formControlName","armor","min","0"],["matInput","","type","number","formControlName","discipline","min","0","step","2"],["matInput","","type","number","formControlName","speed","min","0"],["formControlName","shield"],["formControlName","casting"],["formControlName","performance"],["formControlName","focus"],["mat-raised-button","",1,"mat-accent",3,"click"],["class","prediction-card",4,"ngIf"],[1,"weapon-rating-pair",3,"formGroupName"],["formControlName","weapon"],[3,"value"],["matInput","","type","number","formControlName","rating","min","0","step","2"],["mat-icon-button","","color","warn","type","button",3,"click"],[1,"talent-selection"],[3,"formControlName"],[1,"prediction-card"],[1,"mat-headline-6"]],template:function(e,s){1&e&&(v.TgZ(0,"div",0),v.YNc(1,Oq,4,1,"div",1),v.YNc(2,Gq,110,7,"form",2),v.qZA()),2&e&&(v.xp6(1),v.Q6J("ngIf",!s.trainingDone),v.xp6(1),v.Q6J("ngIf",s.trainingDone))},directives:[Ne.O5,Rs,_e._Y,_e.JL,_e.sg,Le.KE,Le.hX,M.gD,_e.JJ,_e.u,we.ey,_e.x0,_e.CE,ae.lW,he.Hw,Ne.sg,ge.Nt,_e.wV,_e.qQ,_e.Fj,Q.oG,Mt,tt],styles:[".loading-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center}.loading-container[_ngcontent-%COMP%]   .loading-text[_ngcontent-%COMP%]{text-align:center;transition:opacity .3s ease-in-out}"]}),n})()}];let jq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=v.oAB({type:n}),n.\u0275inj=v.cJS({imports:[[om.Bz.forChild(Hq)],om.Bz]}),n})(),qq=(()=>{class n{}return n.\u0275fac=function(e){return new(e||n)},n.\u0275mod=v.oAB({type:n}),n.\u0275inj=v.cJS({providers:[Pv,Lv.q],imports:[[Ne.ez,_e.UX,jq,Le.lN,ge.c,M.LD,ae.ot,he.Ps,Q.p9,$n,jv]]}),n})()},7658:Ze=>{Ze.exports=J;var Ge=null;try{Ge=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(Y){}function J(Y,_,fe){this.low=0|Y,this.high=0|_,this.unsigned=!!fe}function De(Y){return!0===(Y&&Y.__isLong__)}Object.defineProperty(J.prototype,"__isLong__",{value:!0}),J.isLong=De;var Pt={},Ae={};function yt(Y,_){var fe,Fe,Je;return _?(Je=0<=(Y>>>=0)&&Y<256)&&(Fe=Ae[Y])?Fe:(fe=Ne(Y,(0|Y)<0?-1:0,!0),Je&&(Ae[Y]=fe),fe):(Je=-128<=(Y|=0)&&Y<128)&&(Fe=Pt[Y])?Fe:(fe=Ne(Y,Y<0?-1:0,!1),Je&&(Pt[Y]=fe),fe)}function _e(Y,_){if(isNaN(Y))return _?Qt:ct;if(_){if(Y<0)return Qt;if(Y>=v)return tt}else{if(Y<=-be)return st;if(Y+1>=be)return Ye}return Y<0?_e(-Y,_).neg():Ne(Y%Q|0,Y/Q|0,_)}function Ne(Y,_,fe){return new J(Y,_,fe)}J.fromInt=yt,J.fromNumber=_e,J.fromBits=Ne;var Le=Math.pow;function ge(Y,_,fe){if(0===Y.length)throw Error("empty string");if("NaN"===Y||"Infinity"===Y||"+Infinity"===Y||"-Infinity"===Y)return ct;if("number"==typeof _?(fe=_,_=!1):_=!!_,(fe=fe||10)<2||36<fe)throw RangeError("radix");var Fe;if((Fe=Y.indexOf("-"))>0)throw Error("interior hyphen");if(0===Fe)return ge(Y.substring(1),_,fe).neg();for(var Je=_e(Le(fe,8)),He=ct,ot=0;ot<Y.length;ot+=8){var Lt=Math.min(8,Y.length-ot),Mt=parseInt(Y.substring(ot,ot+Lt),fe);if(Lt<8){var on=_e(Le(fe,Lt));He=He.mul(on).add(_e(Mt))}else He=(He=He.mul(Je)).add(_e(Mt))}return He.unsigned=_,He}function M(Y,_){return"number"==typeof Y?_e(Y,_):"string"==typeof Y?ge(Y,_):Ne(Y.low,Y.high,"boolean"==typeof _?_:Y.unsigned)}J.fromString=ge,J.fromValue=M;var Q=4294967296,v=Q*Q,be=v/2,we=yt(1<<24),ct=yt(0);J.ZERO=ct;var Qt=yt(0,!0);J.UZERO=Qt;var en=yt(1);J.ONE=en;var Ds=yt(1,!0);J.UONE=Ds;var ms=yt(-1);J.NEG_ONE=ms;var Ye=Ne(-1,2147483647,!1);J.MAX_VALUE=Ye;var tt=Ne(-1,-1,!0);J.MAX_UNSIGNED_VALUE=tt;var st=Ne(0,-2147483648,!1);J.MIN_VALUE=st;var se=J.prototype;se.toInt=function(){return this.unsigned?this.low>>>0:this.low},se.toNumber=function(){return this.unsigned?(this.high>>>0)*Q+(this.low>>>0):this.high*Q+(this.low>>>0)},se.toString=function(_){if((_=_||10)<2||36<_)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(st)){var fe=_e(_),Fe=this.div(fe),Je=Fe.mul(fe).sub(this);return Fe.toString(_)+Je.toInt().toString(_)}return"-"+this.neg().toString(_)}for(var He=_e(Le(_,6),this.unsigned),ot=this,Lt="";;){var Mt=ot.div(He),Ot=(ot.sub(Mt.mul(He)).toInt()>>>0).toString(_);if((ot=Mt).isZero())return Ot+Lt;for(;Ot.length<6;)Ot="0"+Ot;Lt=""+Ot+Lt}},se.getHighBits=function(){return this.high},se.getHighBitsUnsigned=function(){return this.high>>>0},se.getLowBits=function(){return this.low},se.getLowBitsUnsigned=function(){return this.low>>>0},se.getNumBitsAbs=function(){if(this.isNegative())return this.eq(st)?64:this.neg().getNumBitsAbs();for(var _=0!=this.high?this.high:this.low,fe=31;fe>0&&0==(_&1<<fe);fe--);return 0!=this.high?fe+33:fe+1},se.isZero=function(){return 0===this.high&&0===this.low},se.eqz=se.isZero,se.isNegative=function(){return!this.unsigned&&this.high<0},se.isPositive=function(){return this.unsigned||this.high>=0},se.isOdd=function(){return 1==(1&this.low)},se.isEven=function(){return 0==(1&this.low)},se.equals=function(_){return De(_)||(_=M(_)),(this.unsigned===_.unsigned||this.high>>>31!=1||_.high>>>31!=1)&&this.high===_.high&&this.low===_.low},se.eq=se.equals,se.notEquals=function(_){return!this.eq(_)},se.neq=se.notEquals,se.ne=se.notEquals,se.lessThan=function(_){return this.comp(_)<0},se.lt=se.lessThan,se.lessThanOrEqual=function(_){return this.comp(_)<=0},se.lte=se.lessThanOrEqual,se.le=se.lessThanOrEqual,se.greaterThan=function(_){return this.comp(_)>0},se.gt=se.greaterThan,se.greaterThanOrEqual=function(_){return this.comp(_)>=0},se.gte=se.greaterThanOrEqual,se.ge=se.greaterThanOrEqual,se.compare=function(_){if(De(_)||(_=M(_)),this.eq(_))return 0;var fe=this.isNegative(),Fe=_.isNegative();return fe&&!Fe?-1:!fe&&Fe?1:this.unsigned?_.high>>>0>this.high>>>0||_.high===this.high&&_.low>>>0>this.low>>>0?-1:1:this.sub(_).isNegative()?-1:1},se.comp=se.compare,se.negate=function(){return!this.unsigned&&this.eq(st)?st:this.not().add(en)},se.neg=se.negate,se.add=function(_){De(_)||(_=M(_));var Ot=0,$n=0,_t=0,fn=0;return _t+=(fn+=(65535&this.low)+(65535&_.low))>>>16,$n+=(_t+=(this.low>>>16)+(_.low>>>16))>>>16,Ot+=($n+=(65535&this.high)+(65535&_.high))>>>16,Ot+=(this.high>>>16)+(_.high>>>16),Ne((_t&=65535)<<16|(fn&=65535),(Ot&=65535)<<16|($n&=65535),this.unsigned)},se.subtract=function(_){return De(_)||(_=M(_)),this.add(_.neg())},se.sub=se.subtract,se.multiply=function(_){if(this.isZero())return ct;if(De(_)||(_=M(_)),Ge)return Ne(Ge.mul(this.low,this.high,_.low,_.high),Ge.get_high(),this.unsigned);if(_.isZero())return ct;if(this.eq(st))return _.isOdd()?st:ct;if(_.eq(st))return this.isOdd()?st:ct;if(this.isNegative())return _.isNegative()?this.neg().mul(_.neg()):this.neg().mul(_).neg();if(_.isNegative())return this.mul(_.neg()).neg();if(this.lt(we)&&_.lt(we))return _e(this.toNumber()*_.toNumber(),this.unsigned);var Je=65535&this.high,He=this.low>>>16,ot=65535&this.low,Mt=65535&_.high,on=_.low>>>16,Ot=65535&_.low,$n=0,_t=0,fn=0,ca=0;return fn+=(ca+=ot*Ot)>>>16,_t+=(fn+=He*Ot)>>>16,fn&=65535,_t+=(fn+=ot*on)>>>16,$n+=(_t+=Je*Ot)>>>16,_t&=65535,$n+=(_t+=He*on)>>>16,_t&=65535,$n+=(_t+=ot*Mt)>>>16,$n+=(this.high>>>16)*Ot+Je*on+He*Mt+ot*(_.high>>>16),Ne((fn&=65535)<<16|(ca&=65535),($n&=65535)<<16|(_t&=65535),this.unsigned)},se.mul=se.multiply,se.divide=function(_){if(De(_)||(_=M(_)),_.isZero())throw Error("division by zero");var Fe,Je,He;if(Ge)return this.unsigned||-2147483648!==this.high||-1!==_.low||-1!==_.high?Ne((this.unsigned?Ge.div_u:Ge.div_s)(this.low,this.high,_.low,_.high),Ge.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?Qt:ct;if(this.unsigned){if(_.unsigned||(_=_.toUnsigned()),_.gt(this))return Qt;if(_.gt(this.shru(1)))return Ds;He=Qt}else{if(this.eq(st))return _.eq(en)||_.eq(ms)?st:_.eq(st)?en:(Fe=this.shr(1).div(_).shl(1)).eq(ct)?_.isNegative()?en:ms:(Je=this.sub(_.mul(Fe)),He=Fe.add(Je.div(_)));if(_.eq(st))return this.unsigned?Qt:ct;if(this.isNegative())return _.isNegative()?this.neg().div(_.neg()):this.neg().div(_).neg();if(_.isNegative())return this.div(_.neg()).neg();He=ct}for(Je=this;Je.gte(_);){Fe=Math.max(1,Math.floor(Je.toNumber()/_.toNumber()));for(var Lt=Math.ceil(Math.log(Fe)/Math.LN2),Mt=Lt<=48?1:Le(2,Lt-48),on=_e(Fe),Ot=on.mul(_);Ot.isNegative()||Ot.gt(Je);)Ot=(on=_e(Fe-=Mt,this.unsigned)).mul(_);on.isZero()&&(on=en),He=He.add(on),Je=Je.sub(Ot)}return He},se.div=se.divide,se.modulo=function(_){return De(_)||(_=M(_)),Ge?Ne((this.unsigned?Ge.rem_u:Ge.rem_s)(this.low,this.high,_.low,_.high),Ge.get_high(),this.unsigned):this.sub(this.div(_).mul(_))},se.mod=se.modulo,se.rem=se.modulo,se.not=function(){return Ne(~this.low,~this.high,this.unsigned)},se.and=function(_){return De(_)||(_=M(_)),Ne(this.low&_.low,this.high&_.high,this.unsigned)},se.or=function(_){return De(_)||(_=M(_)),Ne(this.low|_.low,this.high|_.high,this.unsigned)},se.xor=function(_){return De(_)||(_=M(_)),Ne(this.low^_.low,this.high^_.high,this.unsigned)},se.shiftLeft=function(_){return De(_)&&(_=_.toInt()),0==(_&=63)?this:_<32?Ne(this.low<<_,this.high<<_|this.low>>>32-_,this.unsigned):Ne(0,this.low<<_-32,this.unsigned)},se.shl=se.shiftLeft,se.shiftRight=function(_){return De(_)&&(_=_.toInt()),0==(_&=63)?this:_<32?Ne(this.low>>>_|this.high<<32-_,this.high>>_,this.unsigned):Ne(this.high>>_-32,this.high>=0?0:-1,this.unsigned)},se.shr=se.shiftRight,se.shiftRightUnsigned=function(_){if(De(_)&&(_=_.toInt()),0==(_&=63))return this;var fe=this.high;return _<32?Ne(this.low>>>_|fe<<32-_,fe>>>_,this.unsigned):Ne(32===_?fe:fe>>>_-32,0,this.unsigned)},se.shru=se.shiftRightUnsigned,se.shr_u=se.shiftRightUnsigned,se.toSigned=function(){return this.unsigned?Ne(this.low,this.high,!1):this},se.toUnsigned=function(){return this.unsigned?this:Ne(this.low,this.high,!0)},se.toBytes=function(_){return _?this.toBytesLE():this.toBytesBE()},se.toBytesLE=function(){var _=this.high,fe=this.low;return[255&fe,fe>>>8&255,fe>>>16&255,fe>>>24,255&_,_>>>8&255,_>>>16&255,_>>>24]},se.toBytesBE=function(){var _=this.high,fe=this.low;return[_>>>24,_>>>16&255,_>>>8&255,255&_,fe>>>24,fe>>>16&255,fe>>>8&255,255&fe]},J.fromBytes=function(_,fe,Fe){return Fe?J.fromBytesLE(_,fe):J.fromBytesBE(_,fe)},J.fromBytesLE=function(_,fe){return new J(_[0]|_[1]<<8|_[2]<<16|_[3]<<24,_[4]|_[5]<<8|_[6]<<16|_[7]<<24,fe)},J.fromBytesBE=function(_,fe){return new J(_[4]<<24|_[5]<<16|_[6]<<8|_[7],_[0]<<24|_[1]<<16|_[2]<<8|_[3],fe)}},340:(Ze,Ge,J)=>{var De=J(9471),Pt=J(2992),Ae=J(7657),yt=J(5583),_e=J(1929),Ne=J(8083),Le=J(3818);Le.alea=De,Le.xor128=Pt,Le.xorwow=Ae,Le.xorshift7=yt,Le.xor4096=_e,Le.tychei=Ne,Ze.exports=Le},9471:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(M){var ae=this,he=function ge(){var M=4022871197;return function(he){he=String(he);for(var Q=0;Q<he.length;Q++){var v=.02519603282416938*(M+=he.charCodeAt(Q));v-=M=v>>>0,M=(v*=M)>>>0,M+=4294967296*(v-=M)}return 2.3283064365386963e-10*(M>>>0)}}();ae.next=function(){var Q=2091639*ae.s0+2.3283064365386963e-10*ae.c;return ae.s0=ae.s1,ae.s1=ae.s2,ae.s2=Q-(ae.c=0|Q)},ae.c=1,ae.s0=he(" "),ae.s1=he(" "),ae.s2=he(" "),ae.s0-=he(M),ae.s0<0&&(ae.s0+=1),ae.s1-=he(M),ae.s1<0&&(ae.s1+=1),ae.s2-=he(M),ae.s2<0&&(ae.s2+=1),he=null}function Ne(M,ae){return ae.c=M.c,ae.s0=M.s0,ae.s1=M.s1,ae.s2=M.s2,ae}function Le(M,ae){var he=new _e(M),Q=ae&&ae.state,v=he.next;return v.int32=function(){return 4294967296*he.next()|0},v.double=function(){return v()+11102230246251565e-32*(2097152*v()|0)},v.quick=v,Q&&("object"==typeof Q&&Ne(Q,he),v.state=function(){return Ne(he,{})}),v}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.alea=Le}(0,Ze=J.nmd(Ze))},8083:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(ge){var M=this,ae="";M.next=function(){var Q=M.b,v=M.c,be=M.d,we=M.a;return Q=Q<<25^Q>>>7^v,v=v-be|0,be=be<<24^be>>>8^we,we=we-Q|0,M.b=Q=Q<<20^Q>>>12^v,M.c=v=v-be|0,M.d=be<<16^v>>>16^we,M.a=we-Q|0},M.a=0,M.b=0,M.c=-1640531527,M.d=1367130551,ge===Math.floor(ge)?(M.a=ge/4294967296|0,M.b=0|ge):ae+=ge;for(var he=0;he<ae.length+20;he++)M.b^=0|ae.charCodeAt(he),M.next()}function Ne(ge,M){return M.a=ge.a,M.b=ge.b,M.c=ge.c,M.d=ge.d,M}function Le(ge,M){var ae=new _e(ge),he=M&&M.state,Q=function(){return(ae.next()>>>0)/4294967296};return Q.double=function(){do{var we=((ae.next()>>>11)+(ae.next()>>>0)/4294967296)/(1<<21)}while(0===we);return we},Q.int32=ae.next,Q.quick=Q,he&&("object"==typeof he&&Ne(he,ae),Q.state=function(){return Ne(ae,{})}),Q}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.tychei=Le}(0,Ze=J.nmd(Ze))},2992:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(ge){var M=this,ae="";M.x=0,M.y=0,M.z=0,M.w=0,M.next=function(){var Q=M.x^M.x<<11;return M.x=M.y,M.y=M.z,M.z=M.w,M.w^=M.w>>>19^Q^Q>>>8},ge===(0|ge)?M.x=ge:ae+=ge;for(var he=0;he<ae.length+64;he++)M.x^=0|ae.charCodeAt(he),M.next()}function Ne(ge,M){return M.x=ge.x,M.y=ge.y,M.z=ge.z,M.w=ge.w,M}function Le(ge,M){var ae=new _e(ge),he=M&&M.state,Q=function(){return(ae.next()>>>0)/4294967296};return Q.double=function(){do{var we=((ae.next()>>>11)+(ae.next()>>>0)/4294967296)/(1<<21)}while(0===we);return we},Q.int32=ae.next,Q.quick=Q,he&&("object"==typeof he&&Ne(he,ae),Q.state=function(){return Ne(ae,{})}),Q}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.xor128=Le}(0,Ze=J.nmd(Ze))},1929:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(ge){var M=this;M.next=function(){var be,we,he=M.w,Q=M.X,v=M.i;return M.w=he=he+1640531527|0,we=Q[v+34&127],be=Q[v=v+1&127],we^=we<<13,be^=be<<17,we=Q[v]=(we^=we>>>15)^(be^=be>>>12),M.i=v,we+(he^he>>>16)|0},function ae(he,Q){var v,be,we,ct,Qt,en=[],Ds=128;for(Q===(0|Q)?(be=Q,Q=null):(Q+="\0",be=0,Ds=Math.max(Ds,Q.length)),we=0,ct=-32;ct<Ds;++ct)Q&&(be^=Q.charCodeAt((ct+32)%Q.length)),0===ct&&(Qt=be),be^=be<<10,be^=be>>>15,be^=be<<4,be^=be>>>13,ct>=0&&(we=0==(v=en[127&ct]^=be+(Qt=Qt+1640531527|0))?we+1:0);for(we>=128&&(en[127&(Q&&Q.length||0)]=-1),we=127,ct=512;ct>0;--ct)be=en[we+34&127],v=en[we=we+1&127],be^=be<<13,v^=v<<17,en[we]=(be^=be>>>15)^(v^=v>>>12);he.w=Qt,he.X=en,he.i=we}(M,ge)}function Ne(ge,M){return M.i=ge.i,M.w=ge.w,M.X=ge.X.slice(),M}function Le(ge,M){null==ge&&(ge=+new Date);var ae=new _e(ge),he=M&&M.state,Q=function(){return(ae.next()>>>0)/4294967296};return Q.double=function(){do{var we=((ae.next()>>>11)+(ae.next()>>>0)/4294967296)/(1<<21)}while(0===we);return we},Q.int32=ae.next,Q.quick=Q,he&&(he.X&&Ne(he,ae),Q.state=function(){return Ne(ae,{})}),Q}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.xor4096=Le}(0,Ze=J.nmd(Ze))},5583:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(ge){var M=this;M.next=function(){var v,be,he=M.x,Q=M.i;return v=he[Q],be=(v^=v>>>7)^v<<24,be^=(v=he[Q+1&7])^v>>>10,be^=(v=he[Q+3&7])^v>>>3,be^=(v=he[Q+4&7])^v<<7,v=he[Q+7&7],he[Q]=be^=(v^=v<<13)^v<<9,M.i=Q+1&7,be},function ae(he,Q){var v,we=[];if(Q===(0|Q))we[0]=Q;else for(Q=""+Q,v=0;v<Q.length;++v)we[7&v]=we[7&v]<<15^Q.charCodeAt(v)+we[v+1&7]<<13;for(;we.length<8;)we.push(0);for(v=0;v<8&&0===we[v];++v);for(8==v&&(we[7]=-1),he.x=we,he.i=0,v=256;v>0;--v)he.next()}(M,ge)}function Ne(ge,M){return M.x=ge.x.slice(),M.i=ge.i,M}function Le(ge,M){null==ge&&(ge=+new Date);var ae=new _e(ge),he=M&&M.state,Q=function(){return(ae.next()>>>0)/4294967296};return Q.double=function(){do{var we=((ae.next()>>>11)+(ae.next()>>>0)/4294967296)/(1<<21)}while(0===we);return we},Q.int32=ae.next,Q.quick=Q,he&&(he.x&&Ne(he,ae),Q.state=function(){return Ne(ae,{})}),Q}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.xorshift7=Le}(0,Ze=J.nmd(Ze))},7657:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){function _e(ge){var M=this,ae="";M.next=function(){var Q=M.x^M.x>>>2;return M.x=M.y,M.y=M.z,M.z=M.w,M.w=M.v,(M.d=M.d+362437|0)+(M.v=M.v^M.v<<4^Q^Q<<1)|0},M.x=0,M.y=0,M.z=0,M.w=0,M.v=0,ge===(0|ge)?M.x=ge:ae+=ge;for(var he=0;he<ae.length+64;he++)M.x^=0|ae.charCodeAt(he),he==ae.length&&(M.d=M.x<<10^M.x>>>4),M.next()}function Ne(ge,M){return M.x=ge.x,M.y=ge.y,M.z=ge.z,M.w=ge.w,M.v=ge.v,M.d=ge.d,M}function Le(ge,M){var ae=new _e(ge),he=M&&M.state,Q=function(){return(ae.next()>>>0)/4294967296};return Q.double=function(){do{var we=((ae.next()>>>11)+(ae.next()>>>0)/4294967296)/(1<<21)}while(0===we);return we},Q.int32=ae.next,Q.quick=Q,he&&("object"==typeof he&&Ne(he,ae),Q.state=function(){return Ne(ae,{})}),Q}Ae&&Ae.exports?Ae.exports=Le:J.amdD&&J.amdO?void 0!==(De=function(){return Le}.call(Ge,J,Ge,Ae))&&(Ae.exports=De):this.xorwow=Le}(0,Ze=J.nmd(Ze))},3818:function(Ze,Ge,J){var De;!function(Pt,Ae,yt){var v,_e=256,M=yt.pow(_e,6),ae=yt.pow(2,52),he=2*ae,Q=255;function be(Ye,tt,st){var se=[],Y=en(Qt((tt=1==tt?{entropy:!0}:tt||{}).entropy?[Ye,ms(Ae)]:null==Ye?function Ds(){try{var Ye;return v&&(Ye=v.randomBytes)?Ye=Ye(_e):(Ye=new Uint8Array(_e),(Pt.crypto||Pt.msCrypto).getRandomValues(Ye)),ms(Ye)}catch(se){var tt=Pt.navigator,st=tt&&tt.plugins;return[+new Date,Pt,st,Pt.screen,ms(Ae)]}}():Ye,3),se),_=new we(se),fe=function(){for(var Fe=_.g(6),Je=M,He=0;Fe<ae;)Fe=(Fe+He)*_e,Je*=_e,He=_.g(1);for(;Fe>=he;)Fe/=2,Je/=2,He>>>=1;return(Fe+He)/Je};return fe.int32=function(){return 0|_.g(4)},fe.quick=function(){return _.g(4)/4294967296},fe.double=fe,en(ms(_.S),Ae),(tt.pass||st||function(Fe,Je,He,ot){return ot&&(ot.S&&ct(ot,_),Fe.state=function(){return ct(_,{})}),He?(yt.random=Fe,Je):Fe})(fe,Y,"global"in tt?tt.global:this==yt,tt.state)}function we(Ye){var tt,st=Ye.length,se=this,Y=0,_=se.i=se.j=0,fe=se.S=[];for(st||(Ye=[st++]);Y<_e;)fe[Y]=Y++;for(Y=0;Y<_e;Y++)fe[Y]=fe[_=Q&_+Ye[Y%st]+(tt=fe[Y])],fe[_]=tt;(se.g=function(Fe){for(var Je,He=0,ot=se.i,Lt=se.j,Mt=se.S;Fe--;)Je=Mt[ot=Q&ot+1],He=He*_e+Mt[Q&(Mt[ot]=Mt[Lt=Q&Lt+Je])+(Mt[Lt]=Je)];return se.i=ot,se.j=Lt,He})(_e)}function ct(Ye,tt){return tt.i=Ye.i,tt.j=Ye.j,tt.S=Ye.S.slice(),tt}function Qt(Ye,tt){var Y,st=[],se=typeof Ye;if(tt&&"object"==se)for(Y in Ye)try{st.push(Qt(Ye[Y],tt-1))}catch(_){}return st.length?st:"string"==se?Ye:Ye+"\0"}function en(Ye,tt){for(var se,st=Ye+"",Y=0;Y<st.length;)tt[Q&Y]=Q&(se^=19*tt[Q&Y])+st.charCodeAt(Y++);return ms(tt)}function ms(Ye){return String.fromCharCode.apply(0,Ye)}if(en(yt.random(),Ae),Ze.exports){Ze.exports=be;try{v=J(5042)}catch(Ye){}}else void 0!==(De=function(){return be}.call(Ge,J,Ge,Ze))&&(Ze.exports=De)}("undefined"!=typeof self?self:this,[],Math)},5410:()=>{},8628:()=>{},1601:()=>{},7792:()=>{},4977:()=>{},5042:()=>{}}]);